<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Functors, Monads, Applicatives and Monoids</title>
<!-- 2017-03-05 dom 08:15 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Caio Rodrigues" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href='/theme/style.css' rel='stylesheet'>
<link href="/Functional-Programming/theme/style.css" rel="stylesheet">

<script type="text/javascript" src="/theme/org-info.js">
/**
 *
 * @source: /theme/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in /theme/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in /theme/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Functors, Monads, Applicatives and Monoids</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Functors, Monads, Applicatives and Monoids</a>
<ul>
<li><a href="#sec-1-1">1.1. Functors</a></li>
<li><a href="#sec-1-2">1.2. Monads</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. Overview</a></li>
<li><a href="#sec-1-2-2">1.2.2. Bind Operator</a></li>
<li><a href="#sec-1-2-3">1.2.3. Monad Laws</a></li>
<li><a href="#sec-1-2-4">1.2.4. Selected Monad Implementations</a></li>
<li><a href="#sec-1-2-5">1.2.5. Return - Type constructor</a></li>
<li><a href="#sec-1-2-6">1.2.6. Haskell Monads</a></li>
<li><a href="#sec-1-2-7">1.2.7. Monad function composition</a></li>
<li><a href="#sec-1-2-8">1.2.8. Sources</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. Maybe Monad</a></li>
<li><a href="#sec-1-4">1.4. List Monad</a></li>
<li><a href="#sec-1-5">1.5. IO and IO Monad</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. Main action</a></li>
<li><a href="#sec-1-5-2">1.5.2. Read and Show</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. Operator &gt;&gt; (then)</a></li>
<li><a href="#sec-1-7">1.7. Basic I/O Operations</a></li>
<li><a href="#sec-1-8">1.8. Do Notation</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-8-0-1">1.8.0.1. Basic Do Notation</a></li>
<li><a href="#sec-1-8-0-2">1.8.0.2. Do Notation and Let keyword</a></li>
<li><a href="#sec-1-8-0-3">1.8.0.3. Do Notation returning a value</a></li>
<li><a href="#sec-1-8-0-4">1.8.0.4. Combining functions and I/O actions</a></li>
<li><a href="#sec-1-8-0-5">1.8.0.5. Executing a list of actions</a></li>
<li><a href="#sec-1-8-0-6">1.8.0.6. Control Structures</a></li>
<li><a href="#sec-1-8-0-7">1.8.0.7. mapM and mapM_</a></li>
</ul>
</li>
<li><a href="#sec-1-8-1">1.8.1. IO Examples</a>
<ul>
<li><a href="#sec-1-8-1-1">1.8.1.1. Sources</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. State Monad</a></li>
</ul>
</li>
</ul>
</div>
</div>
<lu> 
  <li><a href="/Functional-Programming/index.html">Index</a></li>
  <li><a href="https://github.com/caiorss/Functional-Programming">Repository</a></li>
</lu>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Functors, Monads, Applicatives and Monoids</h2>
<div class="outline-text-2" id="text-1">
<p>
The concepts of functors, monads and applicative comes from <a href="http://en.wikipedia.org/wiki/Category_theory">category
theory</a>.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Functors</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Functors is a prelude class for types which the function fmap is
defined. The function fmap is a generalization of map function.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">class</span>  <span class="org-haskell-type">Functor</span> f  <span class="org-haskell-keyword">where</span>
    fmap        <span class="org-haskell-operator">::</span> (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> f a <span class="org-haskell-operator">-&gt;</span> f b
</pre>
</div>

<ul class="org-ul">
<li>f is a parameterized data type
</li>
<li>(a -&gt; b ) Is a polymorphic function that takes a as parameter and returns b
</li>
<li>f a : a is a parameter, f wraps a
</li>
<li>f b : b is a parameter wrapped by f
</li>
</ul>

<p>
A functor must satisfy the following operations (aka functor laws):
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">-- </span><span class="org-comment">id is the identity function:</span>
<span class="org-haskell-definition">id</span> <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">id</span> x <span class="org-haskell-operator">=</span> x

<span class="org-haskell-definition">fmap</span> (f <span class="org-haskell-operator">.</span> g) <span class="org-haskell-operator">=</span> fmap f <span class="org-haskell-operator">.</span> fmap g  <span class="org-comment-delimiter">-- </span><span class="org-comment">Composition law</span>
<span class="org-haskell-definition">fmap</span> id <span class="org-haskell-operator">=</span> id                    <span class="org-comment-delimiter">-- </span><span class="org-comment">Identity law</span>
</pre>
</div>

<p>
The following functors defined in Haskell standard library
prelude.hs. The function fmap is defined for each of the functor
types.
</p>

<p>
<b>List</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-keyword">where</span>
    fmap <span class="org-haskell-operator">=</span> map
</pre>
</div>

<p>
<b>Maybe</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Maybe</span> x <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> x

<span class="org-haskell-keyword">instance</span>  <span class="org-haskell-type">Functor</span> <span class="org-haskell-type">Maybe</span>  <span class="org-haskell-keyword">where</span>
    fmap f <span class="org-haskell-constructor">Nothing</span>    <span class="org-haskell-operator">=</span>  <span class="org-haskell-constructor">Nothing</span>
    fmap f (<span class="org-haskell-constructor">Just</span> x)   <span class="org-haskell-operator">=</span>  <span class="org-haskell-constructor">Just</span> (f x)
</pre>
</div>

<p>
<b>Either</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Either</span> c d <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Left</span> c <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Right</span> d

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-type">Either</span> a) <span class="org-haskell-keyword">where</span>
    fmap f (<span class="org-haskell-constructor">Left</span> a) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Left</span> a
    fmap f (<span class="org-haskell-constructor">Right</span> b) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Right</span> (f b)
</pre>
</div>

<p>
<b>IO</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span>  <span class="org-haskell-type">Functor</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-keyword">where</span>
   fmap f x           <span class="org-haskell-operator">=</span>  x <span class="org-haskell-operator">&gt;&gt;=</span> (return <span class="org-haskell-operator">.</span> f)
</pre>
</div>

<p>
Examples:
</p>

<p>
The most well known functor is the list functor:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x  <span class="org-haskell-operator">=</span> 10<span class="org-haskell-operator">*</span>x <span class="org-haskell-operator">-</span>2
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> f [1, 2, 3, 10]
[8,18,28,98]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> f (fmap f [1, 2, 3, 10])
[78,178,278,978]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
The Maybe type is a functor which the return value is non deterministic that returns a value if the computation is successful or return a null value Nothing if the computation fails. It is useful to avoid boilerplate successive null checkings and avoid null checking error.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> add10 x <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">+</span> 10
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> add10 <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> add10 <span class="org-haskell-operator">$</span> fmap add10 <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> add10 (<span class="org-haskell-constructor">Just</span> 10)
<span class="org-haskell-constructor">Just</span> 20
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> add10 <span class="org-haskell-operator">$</span> fmap add10 (<span class="org-haskell-constructor">Just</span> 10)
<span class="org-haskell-constructor">Just</span> 30
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Functor Laws Testing</b>
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">-- </span><span class="org-comment">fmap id == id</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> id [1, 2, 3] <span class="org-haskell-operator">==</span> id [1, 2, 3]
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> testLaw_id functor <span class="org-haskell-operator">=</span> fmap id functor <span class="org-haskell-operator">==</span> id functor
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">testLaw_id</span> [1, 2, 3]
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">testLaw_id</span> <span class="org-haskell-constructor">[]</span>
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-comment-delimiter">-- </span><span class="org-comment">Testing for Maybe functor</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">testLaw_id</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">testLaw_id</span> (<span class="org-haskell-constructor">Just</span> 10)
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-comment-delimiter">-- </span><span class="org-comment">Composition Testing</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">fmap (f . g) = fmap f . fmap g  -- Composition law</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">+</span> 1
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> g x <span class="org-haskell-operator">=</span> 2<span class="org-haskell-operator">*</span>x
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> (f <span class="org-haskell-operator">.</span> g)  [1, 2, 3]
[3,5,7]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t (fmap f)
(fmap f) <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Functor</span> f, <span class="org-haskell-type">Num</span> b) <span class="org-haskell-operator">=&gt;</span> f b <span class="org-haskell-operator">-&gt;</span> f b
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> (f <span class="org-haskell-operator">.</span> g)  [1, 2, 3] <span class="org-haskell-operator">==</span>  ((fmap f) <span class="org-haskell-operator">.</span> (fmap g)) [1, 2, 3]
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> test_fcomp f g functor <span class="org-haskell-operator">=</span> fmap (f <span class="org-haskell-operator">.</span> g) functor <span class="org-haskell-operator">==</span>  ((fmap f) <span class="org-haskell-operator">.</span> (fmap g)) functor
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">test_fcomp</span> f g (<span class="org-haskell-constructor">Just</span> 10)
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">test_fcomp</span> f g <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>


<p>
To list all instances of the Functor class:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Functor</span>
<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Functor</span> f <span class="org-haskell-keyword">where</span>
  fmap <span class="org-haskell-operator">::</span> (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> f a <span class="org-haskell-operator">-&gt;</span> f b
  (<span class="org-haskell-operator">&lt;$</span>) <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> f b <span class="org-haskell-operator">-&gt;</span> f a
    <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `GHC.Base'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-type">Either</span> a) <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `Data.Either'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> <span class="org-haskell-type">Maybe</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `Data.Maybe'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> <span class="org-haskell-type">ZipList</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `Control.Applicative'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-type">WrappedMonad</span> m)
  <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `Control.Applicative'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-type">Const</span> m) <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `Control.Applicative'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> <span class="org-haskell-constructor">[]</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `GHC.Base'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> <span class="org-haskell-type">IO</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `GHC.Base'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-constructor">(-&gt;)</span> r) <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `GHC.Base'</span>
<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span> (<span class="org-haskell-constructor">(,)</span> a) <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `GHC.Base'</span>
</pre>
</div>

<p>
References:
</p>

<ul class="org-ul">
<li><a href="http://www.haskellforall.com/2012/09/the-functor-design-pattern.html">The Functor Design Pattern</a>
</li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Applicative_Functors">http://en.wikibooks.org/wiki/Haskell/Applicative_Functors</a>
</li>
<li><a href="http://comonad.com/reader/2008/deriving-strength-from-laziness/">http://comonad.com/reader/2008/deriving-strength-from-laziness/</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Monads</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Monads in Haskell are used to perform IO, State, Parallelism,
Exception Handling, parallelism, continuations and coroutines.
</p>

<p>
Most common applications of monads include:
</p>

<ul class="org-ul">
<li>Representing failure and avoiding null checking using Maybe or Either monad 
</li>
<li>Nondeterminism using List monad to represent carrying multiple values
</li>
<li>State using State monad
</li>
<li>Read-only environment using Reader monad
</li>
<li>I/O using IO monad
</li>
</ul>

<p>
A monad is defined by three things:
</p>

<ul class="org-ul">
<li>a type constructor m that wraps a, parameter a;
</li>
<li>a return  operation: takes a value from a plain type and puts it into a monadic container using the constructor, creating a monadic value. The return operator must not be confused with the "return" from a function in a imperative language. This operator is also known as unit, lift, pure and point. It is a polymorphic constructor.
</li>
<li>a bind operator (&gt;&gt;=). It takes as its arguments a monadic value and a function from a plain type to a monadic value, and returns a new monadic value.
</li>

<li>A monadic function is a function which returns a Monad (a -&gt; m b)
</li>
</ul>


<p>
A type class is an interface which is a set of functions and type
signatures. Each type derived from a type class must implement the
functions described with the same type signatures and same name as
described in the interface/type class. It is similar to a Java
interface.
</p>

<p>
In Haskell, the Monad type class is used to implement monads. It is
provided by the Control.Monad module which is included in the
Prelude. The class has the following methods:
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-keyword">where</span>
    return <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> m a      <span class="org-comment-delimiter">-- </span><span class="org-comment">Constructor (aka unit, lift) </span>
                            <span class="org-comment-delimiter">--</span><span class="org-comment">Not a keyword, but a unfortunate and misleading name.</span>
    (<span class="org-haskell-operator">&gt;&gt;=</span>)  <span class="org-haskell-operator">::</span> m a <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> m b   <span class="org-comment-delimiter">-- </span><span class="org-comment">Bind operator</span>
    (<span class="org-haskell-operator">&gt;&gt;</span>)   <span class="org-haskell-operator">::</span> m a <span class="org-haskell-operator">-&gt;</span> m b <span class="org-haskell-operator">-&gt;</span> m b
    fail   <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m a
</pre>
</div>

<p>
<b>Some Haskell Monads</b>
</p>

<ul class="org-ul">
<li>IO Monads         - Used for output IO
</li>
<li>Maybe and Either  - Error handling and avoinding null checking
</li>
<li>List Monad        - One of the most widely known monads
</li>
<li>Writer Monad
</li>
<li>Reader Monad
</li>
<li>State Monad
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> Bind Operator</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
In a imperative language the bind operator could be described as
below:
</p>

<pre class="example">
-- Operator (&gt;&gt;=)

func: Is a monadic function -&gt;
    func :: a -&gt; m b
        
    In Haskell:
        m a &gt;&gt;= func     == m b
    
    In a Imperative Language        
        bind (m a, func) == m b        

    In a Object Orientated language:
        (m a).bind( func) == m b
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Monad Laws</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
All monads must satisfy the monadic laws:
</p>

<p>
In Haskell, all instances of the Monad type class (and thus all
implementations of (&gt;&gt;=) and return) must obey the following three
laws below:
</p>

<p>
Left identity:
</p>
<pre class="example">
Haskell
    m &gt;&gt;= return =  m       

Imperative Language Equivalent
    bind (m a, unit) == m a -- unit instead of return

Object Orientated Equivalent
    (m a).bind(unit) == m a
</pre>

<p>
Left unit
</p>
<pre class="example">
Haskell
    return x &gt;&gt;= f  ==  f x 

Imperative Language Equivalent
    bind(unit x, f) ==  f x -- f x  == m a

Object Orientated Equivalent
    (unit x).bind(f) == f x
</pre>

<p>
Associativity
</p>
<pre class="example">
Haskell
    (m &gt;&gt;= f) &gt;&gt;= g  =  m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)  

Imperative Language Equivalent
    bind(bind(m a, f), g) == bind(m a, (\x -&gt; bind(f x, g)))

Object Orientated Equivalent
    (m a).bind(f).bind(g) == (m a).bind(\x -&gt; (f x).bind(g))
</pre>

<p>
Nice Version.
</p>

<div class="org-src-container">

<pre class="src src-haskell">1<span class="org-haskell-operator">.</span> return <span class="org-haskell-operator">&gt;=&gt;</span> f       <span class="org-haskell-operator">==</span>    f
2<span class="org-haskell-operator">.</span> f <span class="org-haskell-operator">&gt;=&gt;</span> return       <span class="org-haskell-operator">==</span>    f
3<span class="org-haskell-operator">.</span> (f <span class="org-haskell-operator">&gt;=&gt;</span> g) <span class="org-haskell-operator">&gt;=&gt;</span> h    <span class="org-haskell-operator">==</span>    f <span class="org-haskell-operator">&gt;=&gt;</span> (g <span class="org-haskell-operator">&gt;=&gt;</span> h)
</pre>
</div>

<p>
Credits: <a href="http://mvanier.livejournal.com/4586.html">http://mvanier.livejournal.com/4586.html</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Selected Monad Implementations</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
<b>List Monad</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span>  <span class="org-haskell-type">Monad</span> <span class="org-haskell-constructor">[]</span>  <span class="org-haskell-keyword">where</span>
    m <span class="org-haskell-operator">&gt;&gt;=</span> k          <span class="org-haskell-operator">=</span> concat (map k m)
    return x         <span class="org-haskell-operator">=</span> [x]
    fail s           <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">[]</span>
</pre>
</div>

<p>
<b>Maybe Monad</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Maybe</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> a

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Monad</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-constructor">Just</span> a  <span class="org-haskell-operator">&gt;&gt;=</span> f <span class="org-haskell-operator">=</span> f a
  <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
  return a      <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> a
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">(<span class="org-haskell-definition">&gt;&gt;=</span>) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> a <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> b) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> b
<span class="org-haskell-definition">return</span> <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> a
</pre>
</div>

<p>
<b>IO Monad</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell">(<span class="org-haskell-definition">&gt;&gt;=</span>) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> a <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b
<span class="org-haskell-definition">return</span> <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> Return - Type constructor</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
Return is polymorphic type constructor. This name return is
misleading, it has nothing to do with the return from a function in a
imperative language.
</p>

<p>
Examples:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t return
<span class="org-haskell-definition">return</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> m a
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">return</span> 223.23 <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Double</span>)
<span class="org-haskell-constructor">Just</span> 223.23
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">return</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">return</span> <span class="org-string">"el toro"</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span>  <span class="org-haskell-type">String</span>)
<span class="org-haskell-constructor">Right</span> <span class="org-string">"el toro"</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">return</span> <span class="org-string">"Nichola Tesla"</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>)
<span class="org-string">"Nichola Tesla"</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> Haskell Monads</h4>
<div class="outline-text-4" id="text-1-2-6">

<div class="figure">
<p><img src="images/monadTable.png" alt="monadTable.png" />
</p>
</div>

<p>
From: <a href="https://wiki.haskell.org/All_About_Monads#What_is_a_monad.3F">https://wiki.haskell.org/All_About_Monads#What_is_a_monad.3F</a>
</p>



<p>
Under this interpretation, the functions behave as follows:
</p>

<ul class="org-ul">
<li>fmap applies a given function to every element in a container
</li>
<li>return packages an element into a container,
</li>
<li>join takes a container of containers and flattens it into a single container.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">fmap</span>   <span class="org-haskell-operator">::</span> (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">M</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">M</span> b  <span class="org-comment-delimiter">-- </span><span class="org-comment">functor</span>
<span class="org-haskell-definition">return</span> <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">M</span> a
<span class="org-haskell-definition">join</span>   <span class="org-haskell-operator">::</span> <span class="org-haskell-type">M</span> (<span class="org-haskell-type">M</span> a) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">M</span> a
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> Monad function composition</h4>
<div class="outline-text-4" id="text-1-2-7">
<pre class="example">
(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</pre>

<p>
[Under Construction]
</p>

<pre class="example">
return :: Monad m =&gt; a -&gt; m a

{- Bind Operator -}
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

sequence  :: Monad m =&gt; [m a] -&gt; m [a] 
sequence_ :: Monad m =&gt; [m a] -&gt; m () 
mapM      :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
mapM_     :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()


{- monad composition operator -}
(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
f &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g


data  Maybe a     =  Nothing | Just a  deriving (Eq, Ord, Read, Show)
data  Either a b  =  Left a | Right b  deriving (Eq, Ord, Read, Show)
data  Ordering    =  LT | EQ | GT deriving
                                  (Eq, Ord, Bounded, Enum, Read, Show)
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> Sources</h4>
<div class="outline-text-4" id="text-1-2-8">
<ul class="org-ul">
<li><a href="http://mvanier.livejournal.com/4586.html">http://mvanier.livejournal.com/4586.html</a>
</li>
<li><a href="https://jonaswesterlund.se/monads.html">https://jonaswesterlund.se/monads.html</a>    
</li>
<li><a href="http://learnyouahaskell.com/for-a-few-monads-more">http://learnyouahaskell.com/for-a-few-monads-more</a>
</li>
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">http://learnyouahaskell.com/a-fistful-of-monads</a>    
</li>
<li><a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">http://en.wikipedia.org/wiki/Monad_(functional_programming)</a>    
</li>
<li><a href="https://wiki.haskell.org/All_About_Monads#What_is_a_monad.3F">https://wiki.haskell.org/All_About_Monads#What_is_a_monad.3F</a>
</li>
<li><a href="http://dev.stephendiehl.com/hask/#monad-transformers">http://dev.stephendiehl.com/hask/#monad-transformers</a>
</li>
<li><a href="http://blog.jakubarnold.cz/2014/07/20/mutable-state-in-haskell.html">http://blog.jakubarnold.cz/2014/07/20/mutable-state-in-haskell.html</a>
</li>
<li><a href="https://ro-che.info/articles/2012-01-02-composing-monads">https://ro-che.info/articles/2012-01-02-composing-monads</a>
</li>
<li><a href="http://www.stephanboyer.com/post/9/monads-part-1-a-design-pattern">http://www.stephanboyer.com/post/9/monads-part-1-a-design-pattern</a>
</li>
<li><a href="http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA">http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA</a>
</li>
<li><a href="http://comonad.com/reader/2008/deriving-strength-from-laziness/">http://comonad.com/reader/2008/deriving-strength-from-laziness/</a>
</li>
<li><a href="https://www.haskell.org/tutorial/monads.html">https://www.haskell.org/tutorial/monads.html</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Maybe Monad</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Using the Maybe type is possible to indicate that a function might or
not return value. It is also useful to avoid many boilerplate null
checkings.
</p>

<pre class="example">
data Maybe x = Nothing | Just x

f :: a -&gt; Maybe b
return x  = Just x
Nothing &gt;&gt;= f = Nothing
Just x &gt;&gt;= f = f x


g :: a -&gt; b
fmap g (Just x) = Just( g x)
fmap g  Nothing = Nothing

{- fmap is the same as liftM -}
liftM g (Just x) = Just( g x)
liftM g  Nothing = Nothing
</pre>

<p>
Lift Functions
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">liftM</span>  <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> r) <span class="org-haskell-operator">-&gt;</span> m a1 <span class="org-haskell-operator">-&gt;</span> m r
<span class="org-haskell-definition">liftM2</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> a2 <span class="org-haskell-operator">-&gt;</span> r) <span class="org-haskell-operator">-&gt;</span> m a1 <span class="org-haskell-operator">-&gt;</span> m a2 <span class="org-haskell-operator">-&gt;</span> m r
<span class="org-haskell-definition">liftM3</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> a2 <span class="org-haskell-operator">-&gt;</span> a3 <span class="org-haskell-operator">-&gt;</span> r) <span class="org-haskell-operator">-&gt;</span> m a1 <span class="org-haskell-operator">-&gt;</span> m a2 <span class="org-haskell-operator">-&gt;</span> m a3 <span class="org-haskell-operator">-&gt;</span> m r
<span class="org-haskell-definition">liftM4</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> a2 <span class="org-haskell-operator">-&gt;</span> a3 <span class="org-haskell-operator">-&gt;</span> a4 <span class="org-haskell-operator">-&gt;</span> r) <span class="org-haskell-operator">-&gt;</span> m a1 <span class="org-haskell-operator">-&gt;</span> m a2 <span class="org-haskell-operator">-&gt;</span> m a3 <span class="org-haskell-operator">-&gt;</span> m a4 <span class="org-haskell-operator">-&gt;</span> m r
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> (<span class="org-haskell-operator">+</span>4) (<span class="org-haskell-constructor">Just</span> 10)
<span class="org-haskell-constructor">Just</span> 14 
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> (<span class="org-haskell-operator">+</span>4) <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> (<span class="org-haskell-operator">+</span>) (<span class="org-haskell-constructor">Just</span> 10) (<span class="org-haskell-constructor">Just</span> 5)
<span class="org-haskell-constructor">Just</span> 15
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> (<span class="org-haskell-operator">+</span>) (<span class="org-haskell-constructor">Just</span> 10) <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> (<span class="org-haskell-operator">+</span>) <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Error Handling and avoinding Null Checking</b>
</p>

<p>
Examples without Maybe:
</p>

<div class="org-src-container">

<pre class="src src-haskell">&#955; <span class="org-haskell-definition">:</span>set prompt <span class="org-string">"&gt; "</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>  head [1, 2, 3, 4]
1
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">head</span> <span class="org-haskell-constructor">[]</span>
 <span class="org-haskell-operator">***</span> <span class="org-haskell-constructor">Exception:</span> Prelude.head<span class="org-haskell-constructor">:</span> empty list


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">tail</span> [1, 2, 3, 4]
[2,3,4]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">tail</span> <span class="org-haskell-constructor">[]</span>
 <span class="org-haskell-operator">***</span> <span class="org-haskell-constructor">Exception:</span> Prelude.tail<span class="org-haskell-constructor">:</span> empty list

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div</span> 10 2
5
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div</span> 10 0
 <span class="org-haskell-operator">***</span> <span class="org-haskell-constructor">Exception:</span> divide by zero
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Examples with Maybe monad:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">fromJust</span> (<span class="org-haskell-constructor">Just</span> x) <span class="org-haskell-operator">=</span> x

<span class="org-haskell-definition">safeHead</span> <span class="org-haskell-operator">::</span> [a] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> a
<span class="org-haskell-definition">safeHead</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-definition">safeHead</span> (x<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span>) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> x

<span class="org-haskell-definition">safeTail</span> <span class="org-haskell-operator">::</span> [a] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> [a]
<span class="org-haskell-definition">safeTail</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-definition">safeTail</span> (<span class="org-haskell-keyword">_</span><span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> xs

<span class="org-haskell-definition">safeLast</span> <span class="org-haskell-operator">::</span> [a] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> a
<span class="org-haskell-definition">safeLast</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-definition">safeLast</span> (y<span class="org-haskell-constructor">:[]</span>) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> y
<span class="org-haskell-definition">safeLast</span> (<span class="org-haskell-keyword">_</span><span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> safeLast xs

<span class="org-haskell-definition">safeInit</span> <span class="org-haskell-operator">::</span> [a] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> [a]
<span class="org-haskell-definition">safeInit</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-definition">safeInit</span> (x<span class="org-haskell-constructor">:[]</span>) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-constructor">[]</span>
<span class="org-haskell-definition">safeInit</span> (x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> (x <span class="org-haskell-constructor">:</span> fromJust(safeInit xs))

<span class="org-haskell-definition">safediv</span> y x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">==</span> 0    <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
            <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span>(y<span class="org-haskell-operator">/</span>x)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fromJust</span> (<span class="org-haskell-constructor">Just</span> 10)
10

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safeHead</span> [1<span class="org-haskell-operator">..</span>5]
<span class="org-haskell-constructor">Just</span> 1
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safeHead</span> <span class="org-haskell-constructor">[]</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safeTail</span>  [1<span class="org-haskell-operator">..</span>5]
<span class="org-haskell-constructor">Just</span> [2,3,4,5]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safeTail</span>  <span class="org-haskell-constructor">[]</span>
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> div10by <span class="org-haskell-operator">=</span> safediv 10
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> div100by <span class="org-haskell-operator">=</span> safediv 100


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safediv</span> 10 2
<span class="org-haskell-constructor">Just</span> 5.0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">safediv</span> 10 0
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div10by</span> 2
<span class="org-haskell-constructor">Just</span> 5.0

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div100by</span> 20
<span class="org-haskell-constructor">Just</span> 5.0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div100by</span> 0
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">map</span> div10by [<span class="org-haskell-operator">-</span>2<span class="org-haskell-operator">..</span>2]
[<span class="org-haskell-constructor">Just</span> (<span class="org-haskell-operator">-</span>5.0),<span class="org-haskell-constructor">Just</span> (<span class="org-haskell-operator">-</span>10.0),<span class="org-haskell-constructor">Nothing</span>,<span class="org-haskell-constructor">Just</span> 10.0,<span class="org-haskell-constructor">Just</span> 5.0]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Composition With May be with the &gt;&gt;= (Monad bind operator)
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div100by</span> (div10by 2)

<span class="org-haskell-operator">&lt;</span>interactive<span class="org-haskell-operator">&gt;:</span>102<span class="org-haskell-constructor">:</span>11<span class="org-haskell-constructor">:</span>
    <span class="org-haskell-constructor">Couldn't</span> match expected <span class="org-haskell-keyword">type</span> `<span class="org-haskell-type">Double'</span>
                with actual <span class="org-haskell-keyword">type</span> `<span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Double'</span>
    <span class="org-haskell-constructor">In</span> the return <span class="org-haskell-keyword">type</span> <span class="org-haskell-keyword">of</span> a call <span class="org-haskell-keyword">of</span> `div10by'
    <span class="org-haskell-constructor">In</span> the first argument <span class="org-haskell-keyword">of</span> `div100by', namely `(div10by 2)'
    <span class="org-haskell-constructor">In</span> the expression<span class="org-haskell-constructor">:</span> div100by (div10by 2)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div10by</span> 2 <span class="org-haskell-operator">&gt;&gt;=</span> div100by
<span class="org-haskell-constructor">Just</span> 20.0

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div10by</span> 2 <span class="org-haskell-operator">&gt;&gt;=</span> div10by <span class="org-haskell-operator">&gt;&gt;=</span> div100by 
<span class="org-haskell-constructor">Just</span> 50.0
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div10by</span> 2 <span class="org-haskell-operator">&gt;&gt;=</span> safediv 0 <span class="org-haskell-operator">&gt;&gt;=</span> div100by 
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">div10by</span> 0 <span class="org-haskell-operator">&gt;&gt;=</span> safediv 1000 <span class="org-haskell-operator">&gt;&gt;=</span> div100by 
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Reference:  
</p>

<ul class="org-ul">
<li><a href="http://www.fatvat.co.uk/2009/10/dealing-with-partial-functions.html">http://www.fatvat.co.uk/2009/10/dealing-with-partial-functions.html</a> 
</li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads">http://en.wikibooks.org/wiki/Haskell/Understanding_monads</a>
</li>
<li><a href="https://www21.in.tum.de/teaching/perlen/WS1415/unterlagen/Monads_in_Haskell.pdf">https://www21.in.tum.de/teaching/perlen/WS1415/unterlagen/Monads_in_Haskell.pdf</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> List Monad</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Monad</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-keyword">where</span>
    <span class="org-comment-delimiter">--</span><span class="org-comment">return :: a -&gt; [a]</span>
    return x <span class="org-haskell-operator">=</span> [x] <span class="org-comment-delimiter">-- </span><span class="org-comment">make a list containing the one element given</span>

    <span class="org-comment-delimiter">--</span><span class="org-comment">(&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]</span>
    xs <span class="org-haskell-operator">&gt;&gt;=</span> f <span class="org-haskell-operator">=</span> concat (map f xs) 
        <span class="org-comment-delimiter">-- </span><span class="org-comment">collect up all the results of f (which are lists)</span>
        <span class="org-comment-delimiter">-- </span><span class="org-comment">and combine them into a new list</span>
</pre>
</div>

<p>
Examples Using the bind operator for lists:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> [10,20,30] <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> [2<span class="org-haskell-operator">*</span>x, x<span class="org-haskell-operator">+</span>5] 
[20,15,40,25,60,35]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> [10,20,30] <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> [(2<span class="org-haskell-operator">*</span>x, x<span class="org-haskell-operator">+</span>5)] 
[(20,15),(40,25),(60,35)]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Do Notation for lists
</p>

<p>
The list comprehension is a syntax sugar for do-notation to list monad.
</p>

<p>
File: listMonad.hs 
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">listOfTuples</span> <span class="org-haskell-operator">::</span> [(<span class="org-haskell-type">Int</span>,<span class="org-haskell-type">Char</span>)]  
<span class="org-haskell-definition">listOfTuples</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>  
    n <span class="org-haskell-operator">&lt;-</span> [1,2]  
    ch <span class="org-haskell-operator">&lt;-</span> [<span class="org-string">'a'</span>,<span class="org-string">'b'</span>]  
    return (n,ch)
</pre>
</div>

<p>
Ghci shell
</p>
<pre class="example">
&gt; :l listMonad.hs 
[1 of 1] Compiling Main             ( listMonad.hs, interpreted )
Ok, modules loaded: Main.
&gt; 

&gt; listOfTuples 
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]

&gt; [ (n,ch) | n &lt;- [1,2], ch &lt;- ['a','b'] ]  
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
&gt; 

&gt; do { x &lt;- [10, 20, 30] ; [x, x+1] }
[10,11,20,21,30,31]

&gt; do { x &lt;- [10, 20, 30] ; [(x, x+1)] }
[(10,11),(20,21),(30,31)]
&gt; 

&gt; do { x &lt;- [10, 20, 30] ; y &lt;- [1, 2, 3] ; return (x*y) }
[10,20,30,20,40,60,30,60,90]
&gt; 

&gt; sequence [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
&gt; 
&gt;
</pre>

<p>
Operator: (,)
</p>
<pre class="example">
&gt; (,) 3 4
(3,4)
&gt; 

&gt; map ((,)2) [1, 2, 3, 4]
[(2,1),(2,2),(2,3),(2,4)]
</pre>

<p>
<b>fmap, map and liftM</b>
</p>

<p>
For a list, fmap is equivalent to map
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> (<span class="org-haskell-constructor">(,)</span>3) [1, 2, 3, 4]
[(3,1),(3,2),(3,3),(3,4)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> (<span class="org-haskell-operator">+</span>3) [1, 2, 3, 4]
[4,5,6,7]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> (<span class="org-haskell-constructor">(,)</span>3) [1, 2, 3, 4]
[(3,1),(3,2),(3,3),(3,4)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> (<span class="org-haskell-operator">+</span>3) [1, 2, 3, 4]
[4,5,6,7]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>liftM and Cartesian Product</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> <span class="org-haskell-constructor">(,)</span> [1, 2, 3] [4, 5, 6, 7]
[(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> <span class="org-haskell-constructor">(,)</span> [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>] [1, 2]
[(<span class="org-string">'a'</span>,1),(<span class="org-string">'a'</span>,2),(<span class="org-string">'b'</span>,1),(<span class="org-string">'b'</span>,2),(<span class="org-string">'c'</span>,1),(<span class="org-string">'c'</span>,2)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> (<span class="org-haskell-operator">*</span>) [1, 2, 3] [4, 5, 6, 7]
[4,5,6,7,8,10,12,14,12,15,18,21]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM2</span> (<span class="org-haskell-operator">+</span>) [1, 2, 3] [4, 5, 6, 7]
[5,6,7,8,6,7,8,9,7,8,9,10]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM3</span> <span class="org-haskell-constructor">(,,)</span> [1, 2, 3] [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>, <span class="org-string">'d'</span>] [<span class="org-string">'x'</span>, <span class="org-string">'y'</span>, <span class="org-string">'z'</span>]
[(1,<span class="org-string">'a'</span>,<span class="org-string">'x'</span>),(1,<span class="org-string">'a'</span>,<span class="org-string">'y'</span>),(1,<span class="org-string">'a'</span>,<span class="org-string">'z'</span>),(1,<span class="org-string">'b'</span>,<span class="org-string">'x'</span>),(1,<span class="org-string">'b'</span>,<span class="org-string">'y'</span>),(1,<span class="org-string">'b'</span>,<span class="org-string">'z'</span>),(1,<span class="org-string">'c'</span>,<span class="org-string">'x'</span>),(1,<span class="org-string">'c'</span>,<span class="org-string">'y'</span>),(1,<span class="org-string">'c'</span>,<span class="org-string">'z'</span>),(1,<span class="org-string">'d'</span>,<span class="org-string">'x'</span>),(1,<span class="org-string">'d'</span>,<span class="org-string">'y'</span>),(1,<span class="org-string">'d'</span>,<span class="org-string">'z'</span>),(2,<span class="org-string">'a'</span>,<span class="org-string">'x'</span>),(2,<span class="org-string">'a'</span>,<span class="org-string">'y'</span>),(2,<span class="org-string">'a'</span>,<span class="org-string">'z'</span>),(2,<span class="org-string">'b'</span>,<span class="org-string">'x'</span>),(2,<span class="org-string">'b'</span>,<span class="org-string">'y'</span>),(2,<span class="org-string">'b'</span>,<span class="org-string">'z'</span>),(2,<span class="org-string">'c'</span>,<span class="org-string">'x'</span>),(2,<span class="org-string">'c'</span>,<span class="org-string">'y'</span>),(2,<span class="org-string">'c'</span>,<span class="org-string">'z'</span>),(2,<span class="org-string">'d'</span>,<span class="org-string">'x'</span>),(2,<span class="org-string">'d'</span>,<span class="org-string">'y'</span>),(2,<span class="org-string">'d'</span>,<span class="org-string">'z'</span>),(3,<span class="org-string">'a'</span>,<span class="org-string">'x'</span>),(3,<span class="org-string">'a'</span>,<span class="org-string">'y'</span>),(3,<span class="org-string">'a'</span>,<span class="org-string">'z'</span>),(3,<span class="org-string">'b'</span>,<span class="org-string">'x'</span>),(3,<span class="org-string">'b'</span>,<span class="org-string">'y'</span>),(3,<span class="org-string">'b'</span>,<span class="org-string">'z'</span>),(3,<span class="org-string">'c'</span>,<span class="org-string">'x'</span>),(3,<span class="org-string">'c'</span>,<span class="org-string">'y'</span>),(3,<span class="org-string">'c'</span>,<span class="org-string">'z'</span>),(3,<span class="org-string">'d'</span>,<span class="org-string">'x'</span>),(3,<span class="org-string">'d'</span>,<span class="org-string">'y'</span>),(3,<span class="org-string">'d'</span>,<span class="org-string">'z'</span>)]
</pre>
</div>


<p>
<a href="http://learnyouahaskell.com/a-fistful-of-monads">http://learnyouahaskell.com/a-fistful-of-monads</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> IO and IO Monad</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Haskell separates pure functions from computations where side effects
must be considered by encoding those side effects as values of a
particular type. Specifically, a value of type (IO a) is an action,
which if executed would produce a value of type a.( <a href="https://wiki.haskell.org/Introduction_to_IO">Haskell Wiki</a> )
</p>

<p>
Actions are either atomic, as defined in system primitives, or are a sequential composition of other actions. The I/O monad contains primitives which build composite actions, a process similar to joining statements in sequential order using `;' in other languages. Thus the monad serves as the glue which binds together the actions in a program. [[<a href="https://www.haskell.org/tutorial/io.html][[2">https://www.haskell.org/tutorial/io.html][[2</a>]]]
</p>

<p>
Haskell uses the data type IO (IO monad) for actions.
</p>

<ul class="org-ul">
<li>&gt; let n = v   Binds n to value v
</li>
<li>&gt; n &lt;- a      Executes action a and binds the name n to the result
</li>
<li>&gt; a           Executes action a
</li>
<li>do  notation  is syntactic sugar for (&gt;&gt;=) operations. 
</li>
</ul>


<p>
<b>Intput Functions</b>
</p>

<p>
Stdin - Standard Input
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">getChar</span>             <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Char</span>
<span class="org-haskell-definition">getLine</span>             <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">getContents</span>         <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">interact</span>            <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">String</span>) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">readIO</span>              <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Read</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">readLine</span>            <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Read</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">IO</span> a
</pre>
</div>


<p>
<b>Output Functions</b>
</p>

<p>
Stdout - Standard Output
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">print</span>               <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Show</span> a <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">putStrLn</span>            <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">putStr</span>              <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
</pre>
</div>

<p>
<b>Files</b>
</p>
<pre class="example">
type FilePath = String

writeFile     ::  FilePath -&gt; String            -&gt; IO ()
appendFile    ::  FilePath -&gt; String            -&gt; IO ()
readFile      ::  FilePath                      -&gt; IO String
</pre>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> Main action</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
The only IO action which can really be said to run in a compiled
Haskell program is main.
</p>

<p>
HelloWorld.hs
</p>

<pre class="example">
main :: IO ()
main = putStrLn "Hello, World!"
</pre>

<p>
Compile HelloWorld.hs
</p>
<pre class="example">
$ ghc HelloWorld.hs 
[1 of 1] Compiling Main             ( HelloWorld.hs, HelloWorld.o )
Linking HelloWorld ...

$ file HelloWorld
HelloWorld: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=9cd178d3dd88290e7fcfaf93c9aba9b2308a0e87, not stripped
</pre>

<p>
Running HelloWorld.hs executable.
</p>
<pre class="example">
$ ./HelloWorld 
Hello, World!

$ runhaskell HelloWorld.hs
Hello, World!
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> Read and Show</h4>
<div class="outline-text-4" id="text-1-5-2">
<pre class="example">
show   :: (Show a) =&gt; a -&gt; String
read   :: (Read a) =&gt; String -&gt; a

{- lines 
    split string into substring at new line character \n \r
-}
lines :: String -&gt; [String]
</pre>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> show(12.12 <span class="org-haskell-operator">+</span> 23.445)
<span class="org-string">"35.565"</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">read</span> <span class="org-string">"1.245"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Double</span>
1.245
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> x <span class="org-haskell-operator">=</span> read <span class="org-string">"1.245"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t x
<span class="org-haskell-definition">x</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">read</span> <span class="org-string">"[1, 2, 3, 4, 5]"</span> <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">Int</span>]
[1,2,3,4,5]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Operator &gt;&gt; (then)</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The then combinator (&gt;&gt;) does sequencing when there is no value to
pass:
</p>

<div class="org-src-container">

<pre class="src src-haskell">(<span class="org-haskell-definition">&gt;&gt;</span>)    <span class="org-haskell-operator">::</span>  <span class="org-haskell-type">IO</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b
m <span class="org-haskell-definition">&gt;&gt;</span> n  <span class="org-haskell-operator">=</span>   m <span class="org-haskell-operator">&gt;&gt;=</span> (<span class="org-haskell-operator">\</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> n)
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> echoDup <span class="org-haskell-operator">=</span> getChar <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span>c <span class="org-haskell-operator">-&gt;</span> putChar c <span class="org-haskell-operator">&gt;&gt;</span> putChar c
<span class="org-haskell-operator">&gt;</span> echoDup 
eee<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> echoDup 
ooo<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
It is equivalent in a do-notation to:
</p>

<pre class="example">
echoDup = do
    c &lt;- getChar
    putChar c
    putChar c
</pre>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Basic I/O Operations</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Every IO action returns a value. The returned value is tagged with IO
type.
</p>

<p>
Examples:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">getChar</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Char</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">Performs an action that returns a character</span>

<span class="org-comment-delimiter">{- </span>
<span class="org-comment">    To capture a value returned by an action, the operator &lt;- must be used</span>
<span class="org-comment">-}</span>
<span class="org-haskell-operator">&gt;</span> c <span class="org-haskell-operator">&lt;-</span> getChar 
h<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> c
<span class="org-string">'h'</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t c
<span class="org-haskell-definition">c</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Char</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
IO Actions that returns nothing uses the unit type (). The return type is IO (), it is equivalent to C language void.
</p>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t putChar
<span class="org-haskell-definition">putChar</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Char</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">putChar</span> <span class="org-string">'X'</span>
<span class="org-haskell-constructor">X</span><span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
The operator &gt;&gt; concatenates IO actions, it is equivalent to (;) semicolon operator in imperative languages.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t (<span class="org-haskell-operator">&gt;&gt;</span>)
(<span class="org-haskell-definition">&gt;&gt;</span>) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> m a <span class="org-haskell-operator">-&gt;</span> m b <span class="org-haskell-operator">-&gt;</span> m b
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">putChar</span> <span class="org-string">'X'</span> <span class="org-haskell-operator">&gt;&gt;</span>  putChar <span class="org-string">'\n'</span>
<span class="org-haskell-constructor">X</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Equivalent code in a imperative language, Python.
</p>

<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span class="org-keyword">print</span> (<span class="org-string">'\n'</span>) ; <span class="org-keyword">print</span> (<span class="org-string">'x'</span>)


x
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Do Notation</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The statements in the do-notation are executed in a sequential
order. It is syntactic sugar for the bind (&gt;&gt;=) operator. The values
of local statements are defined using let and result of an action uses
the (&lt;-) operator. The do notation adds syntactic sugar to make
monadic code easier to read.
</p>

<p>
The do notation 
</p>

<pre class="example">
anActon = do {v1 &lt;- e1; e2}
</pre>

<p>
is a syntax sugar notation for the expression:
</p>

<pre class="example">
anActon = e1 &gt;&gt;= \v1 -&gt; e2
</pre>

<p>
Plain Syntax
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">getTwoChars</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> (<span class="org-haskell-type">Char</span>,<span class="org-haskell-type">Char</span>)
<span class="org-haskell-definition">getTwoChars</span> <span class="org-haskell-operator">=</span> getChar   <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span>c1 <span class="org-haskell-operator">-&gt;</span>
              getChar   <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span>c2 <span class="org-haskell-operator">-&gt;</span>
              return (c1,c2)
</pre>
</div>

<p>
Do Notation
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">getTwoCharsDo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span>(<span class="org-haskell-type">Char</span>,<span class="org-haskell-type">Char</span>)
<span class="org-haskell-definition">getTwoCharsDo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span> { c1 <span class="org-haskell-operator">&lt;-</span> getChar ;
                     c2 <span class="org-haskell-operator">&lt;-</span> getChar ;
                     return (c1,c2) }
</pre>
</div>

<p>
Or:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">getTwoCharsDo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span>(<span class="org-haskell-type">Char</span>,<span class="org-haskell-type">Char</span>)
<span class="org-haskell-definition">getTwoCharsDo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span> 
    c1 <span class="org-haskell-operator">&lt;-</span> getChar 
    c2 <span class="org-haskell-operator">&lt;-</span> getChar 
    return (c1,c2)
</pre>
</div>
</div>


<div id="outline-container-sec-1-8-0-1" class="outline-5">
<h5 id="sec-1-8-0-1"><span class="section-number-5">1.8.0.1</span> Basic Do Notation</h5>
<div class="outline-text-5" id="text-1-8-0-1">
<p>
File: do_notation1.hs
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">do1test</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    c <span class="org-haskell-operator">&lt;-</span> getChar 
    putChar <span class="org-string">'x'</span>
    putChar c
    putChar <span class="org-string">'\n'</span>
</pre>
</div>

<p>
In the shell ghci
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l do_notation1<span class="org-haskell-operator">.</span>hs 
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( do_notation1<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> Main.
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t do1test 
<span class="org-haskell-definition">do1test</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> do1test <span class="org-comment-delimiter">-- </span><span class="org-comment">User types character 'a'</span>
axa
<span class="org-haskell-operator">&gt;</span> do1test <span class="org-comment-delimiter">-- </span><span class="org-comment">User types character 'x'</span>
txt
<span class="org-haskell-operator">&gt;</span> do1test <span class="org-comment-delimiter">-- </span><span class="org-comment">User types character 'p'</span>
pxp
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-0-2" class="outline-5">
<h5 id="sec-1-8-0-2"><span class="section-number-5">1.8.0.2</span> Do Notation and Let keyword</h5>
<div class="outline-text-5" id="text-1-8-0-2">
<p>
File: do_notation2.hs
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">make_string</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Char</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-definition">make_string</span> achar <span class="org-haskell-operator">=</span> <span class="org-string">"\nThe character is : "</span> <span class="org-haskell-operator">++</span> [achar]

<span class="org-haskell-definition">do2test</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-keyword">let</span> mychar <span class="org-haskell-operator">=</span> <span class="org-string">'U'</span>
    c <span class="org-haskell-operator">&lt;-</span> getChar     
    putStrLn (make_string c)
    putChar mychar
    putChar <span class="org-string">'\n'</span>

<span class="org-haskell-definition">do3test</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>   
    c <span class="org-haskell-operator">&lt;-</span> getChar     
    <span class="org-haskell-keyword">let</span> phrase <span class="org-haskell-operator">=</span> make_string c
    putStrLn phrase   
    putChar <span class="org-string">'\n'</span>
</pre>
</div>

<p>
In the shell ghci
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l do_notation2<span class="org-haskell-operator">.</span>hs 
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( do_notation1<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> Main.
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t make_string 
<span class="org-haskell-definition">make_string</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Char</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-operator">&gt;</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t do2test 
<span class="org-haskell-definition">do2test</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">make_string</span> <span class="org-string">'q'</span>
<span class="org-string">"\nThe character is : q"</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">make_string</span> <span class="org-string">'a'</span>
<span class="org-string">"\nThe character is : a"</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> do2test 
a
<span class="org-haskell-constructor">The</span> character is <span class="org-haskell-constructor">:</span> a
<span class="org-haskell-constructor">U</span>

<span class="org-haskell-operator">&gt;</span> do2test 
p
<span class="org-haskell-constructor">The</span> character is <span class="org-haskell-constructor">:</span> p
<span class="org-haskell-constructor">U</span>

<span class="org-haskell-operator">&gt;</span> do3test 
a
<span class="org-haskell-constructor">The</span> character is <span class="org-haskell-constructor">:</span> a

<span class="org-haskell-operator">&gt;</span> do3test 
b
<span class="org-haskell-constructor">The</span> character is <span class="org-haskell-constructor">:</span> b
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-0-3" class="outline-5">
<h5 id="sec-1-8-0-3"><span class="section-number-5">1.8.0.3</span> Do Notation returning a value</h5>
<div class="outline-text-5" id="text-1-8-0-3">
<p>
File: do_return.hs
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">doReturn</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    c <span class="org-haskell-operator">&lt;-</span> getChar
    <span class="org-haskell-keyword">let</span> test <span class="org-haskell-operator">=</span> c <span class="org-haskell-operator">==</span> <span class="org-string">'y'</span>
    return test
</pre>
</div>

<p>
In ghci shell
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t doReturn 
<span class="org-haskell-definition">doReturn</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> doReturn 
aFalse
<span class="org-haskell-operator">&gt;</span> doReturn 
bFalse
<span class="org-haskell-operator">&gt;</span> doReturn 
cFalse
<span class="org-haskell-operator">&gt;</span> doReturn 
yTrue
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">&lt;-</span> doReturn 
r<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> x
<span class="org-haskell-constructor">False</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">&lt;-</span> doReturn 
m<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> x
<span class="org-haskell-constructor">False</span>
<span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">&lt;-</span> doReturn 
y<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> x
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-0-4" class="outline-5">
<h5 id="sec-1-8-0-4"><span class="section-number-5">1.8.0.4</span> Combining functions and I/O actions</h5>
<div class="outline-text-5" id="text-1-8-0-4">
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Char</span> (toUpper)
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> shout <span class="org-haskell-operator">=</span> map toUpper 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t shout
<span class="org-haskell-definition">shout</span> <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">Char</span>] <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-type">Char</span>]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-comment-delimiter">{- </span><span class="org-comment">Fmap is Equivalent to liftM , those functions</span>
<span class="org-comment">apply a function to the value wraped in the monad and returns a new monad of </span>
<span class="org-comment">same type with the return value wraped</span>

<span class="org-comment">-}</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t liftM
<span class="org-haskell-definition">liftM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> r) <span class="org-haskell-operator">-&gt;</span> m a1 <span class="org-haskell-operator">-&gt;</span> m r
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t fmap
<span class="org-haskell-definition">fmap</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Functor</span> f <span class="org-haskell-operator">=&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> f a <span class="org-haskell-operator">-&gt;</span> f b
<span class="org-haskell-operator">&gt;</span> 


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">shout</span> <span class="org-string">"hola estados unidos"</span>
<span class="org-string">"HOLA ESTADOS UNIDOS"</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> shout getLine
<span class="org-haskell-constructor">Hello</span> world
<span class="org-string">"HELLO WORLD"</span>


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">fmap</span> shout getLine
heloo
<span class="org-string">"HELOO"</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> upperLine <span class="org-haskell-operator">=</span> putStrLn <span class="org-string">"Enter a line"</span> <span class="org-haskell-operator">&gt;&gt;</span> liftM shout getLine

<span class="org-haskell-operator">&gt;</span> upperLine 
<span class="org-haskell-constructor">Enter</span> a line
<span class="org-haskell-definition">hola</span> estados <span class="org-haskell-constructor">Unidos</span>
<span class="org-string">"HOLA ESTADOS UNIDOS"</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> upperLine 
<span class="org-haskell-constructor">Enter</span> a line
<span class="org-haskell-definition">air</span> lift
<span class="org-string">"AIR LIFT"</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-0-5" class="outline-5">
<h5 id="sec-1-8-0-5"><span class="section-number-5">1.8.0.5</span> Executing a list of actions</h5>
<div class="outline-text-5" id="text-1-8-0-5">
<p>
The list myTodoList doesn't execute any action, it holds them. To join those actions the function sequence_ must be used.
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> myTodoList <span class="org-haskell-operator">=</span> [putChar <span class="org-string">'1'</span>, putChar <span class="org-string">'2'</span>, putChar <span class="org-string">'3'</span>, putChar <span class="org-string">'4'</span>]

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t myTodoList 
<span class="org-haskell-definition">myTodoList</span> <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t sequence_
<span class="org-haskell-definition">sequence_</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> [m a] <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">sequence_</span> myTodoList 
1234<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> newAction <span class="org-haskell-operator">=</span> sequence_ myTodoList 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t newAction 
<span class="org-haskell-definition">newAction</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> newAction 
1234<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
The function sequence_ is defined as:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">sequence_</span>        <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">sequence_</span> <span class="org-haskell-constructor">[]</span>     <span class="org-haskell-operator">=</span>  return <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">sequence_</span> (a<span class="org-haskell-constructor">:</span>as) <span class="org-haskell-operator">=</span>  <span class="org-haskell-keyword">do</span> a
                       sequence_ as
</pre>
</div>

<p>
Or defined as:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">sequence_</span>        <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-definition">sequence_</span>        <span class="org-haskell-operator">=</span>  foldr (<span class="org-haskell-operator">&gt;&gt;</span>) (return <span class="org-haskell-constructor">()</span>)
</pre>
</div>

<p>
The sequence_ function can be used to construct putStr from putChar:
</p>

<pre class="example">
putStr                  :: String -&gt; IO ()
putStr s                =  sequence_ (map putChar s)
</pre>
</div>
</div>

<div id="outline-container-sec-1-8-0-6" class="outline-5">
<h5 id="sec-1-8-0-6"><span class="section-number-5">1.8.0.6</span> Control Structures</h5>
<div class="outline-text-5" id="text-1-8-0-6">
<p>
For Loops
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t forM_
<span class="org-haskell-definition">forM_</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor">()</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t forM
<span class="org-haskell-definition">forM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> m [b]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t (putStrLn <span class="org-haskell-operator">.</span> show)
(putStrLn <span class="org-haskell-operator">.</span> show) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Show</span> a <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> (

<span class="org-haskell-operator">&gt;</span> (putStrLn <span class="org-haskell-operator">.</span> show) 10
10
<span class="org-haskell-operator">&gt;</span> (putStrLn <span class="org-haskell-operator">.</span> show) 200
200
<span class="org-haskell-operator">&gt;</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">forM_</span> [1<span class="org-haskell-operator">..</span>10] (putStrLn <span class="org-haskell-operator">.</span> show)
1
2
3
4
5
6
7
8
9
10
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-0-7" class="outline-5">
<h5 id="sec-1-8-0-7"><span class="section-number-5">1.8.0.7</span> mapM and mapM_</h5>
<div class="outline-text-5" id="text-1-8-0-7">
<p>
Map a monadic function, a function that returns a monad, to a list. It
is similar to forM and formM_.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t mapM
<span class="org-haskell-definition">mapM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> m [b]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t mapM_
<span class="org-haskell-definition">mapM_</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t (putStrLn <span class="org-haskell-operator">.</span> show)
(putStrLn <span class="org-haskell-operator">.</span> show) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Show</span> a <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> (

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">mapM_</span> (putStrLn <span class="org-haskell-operator">.</span> show) [1<span class="org-haskell-operator">..</span>10]
1
2
3
4
5
6
7
8
9
10
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> IO Examples</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
<b>Example 1</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> echo <span class="org-haskell-operator">=</span> getChar <span class="org-haskell-operator">&gt;&gt;=</span> putChar 
<span class="org-haskell-operator">&gt;</span> echo 
aa<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> echo 
cc<span class="org-haskell-definition">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t getChar
<span class="org-haskell-definition">getChar</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Char</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t putChar
<span class="org-haskell-definition">putChar</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Char</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t (<span class="org-haskell-operator">&gt;&gt;=</span>)
(<span class="org-haskell-definition">&gt;&gt;=</span>) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> m a <span class="org-haskell-operator">-&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> m b) <span class="org-haskell-operator">-&gt;</span> m b
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Example 2</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">reverseInput</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span> 
    putStrLn <span class="org-string">"Enter a line of text:"</span>
    x <span class="org-haskell-operator">&lt;-</span> getLine
    putStrLn (reverse x)

<span class="org-haskell-operator">&gt;</span> reverseInput 
<span class="org-haskell-constructor">Enter</span> a line <span class="org-haskell-keyword">of</span> text<span class="org-haskell-constructor">:</span>
<span class="org-haskell-constructor">Hello</span> <span class="org-haskell-constructor">World</span>
<span class="org-haskell-definition">dlroW</span> olleH
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>


<p>
<b>Example 3</b>
</p>

<p>
File: questions.hs
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">questions</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-string">"\nWhat is your name ??"</span>
    name <span class="org-haskell-operator">&lt;-</span> getLine

    putStrLn <span class="org-string">"\nWhere you come from ??"</span>
    country <span class="org-haskell-operator">&lt;-</span> getLine

    putStrLn <span class="org-string">"\nHow old are you ??"</span>
    age <span class="org-haskell-operator">&lt;-</span> getLine


    <span class="org-haskell-keyword">let</span> result <span class="org-haskell-operator">=</span> <span class="org-string">"Your name is : "</span> <span class="org-haskell-operator">++</span> name <span class="org-haskell-operator">++</span> <span class="org-string">"\nYou come from "</span> <span class="org-haskell-operator">++</span> country  <span class="org-haskell-operator">++</span> <span class="org-string">"\nYour age is : "</span> <span class="org-haskell-operator">++</span> age
    putStrLn result
</pre>
</div>

<p>
GHCI Shell
</p>

<div class="org-src-container">

<pre class="src src-haskell">[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( questions<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> Main.
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> questions

<span class="org-haskell-constructor">Whats</span> your name <span class="org-haskell-operator">??</span>
<span class="org-haskell-constructor">George</span> <span class="org-haskell-constructor">Washington</span>

<span class="org-haskell-constructor">Where</span> you come from <span class="org-haskell-operator">??</span>
<span class="org-haskell-constructor">US</span>

<span class="org-haskell-constructor">Whats</span> your age <span class="org-haskell-operator">??</span>
60
<span class="org-haskell-constructor">Your</span> name is <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">George</span> <span class="org-haskell-constructor">Washington</span>
<span class="org-haskell-constructor">You</span> come from <span class="org-haskell-constructor">US</span>
<span class="org-haskell-constructor">Your</span> age is <span class="org-haskell-constructor">:</span> 60
</pre>
</div>

<p>
<b>Example 4 - Reading and Writing a File</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> (show [(x,x<span class="org-haskell-operator">*</span>x) <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> [0,1<span class="org-haskell-operator">..</span>10]])
<span class="org-string">"[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]"</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t writeFile <span class="org-string">"squares.txt"</span> (show [(x,x<span class="org-haskell-operator">*</span>x) <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> [0,1<span class="org-haskell-operator">..</span>10]])
<span class="org-haskell-definition">writeFile</span> <span class="org-string">"squares.txt"</span> (show [(x,x<span class="org-haskell-operator">*</span>x) <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> [0,1<span class="org-haskell-operator">..</span>10]]) <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">writeFile</span> <span class="org-string">"squares.txt"</span> (show [(x,x<span class="org-haskell-operator">*</span>x) <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> [0,1<span class="org-haskell-operator">..</span>10]])
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">readFile</span> <span class="org-string">"squares.txt"</span>
<span class="org-string">"[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]"</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t readFile <span class="org-string">"squares.txt"</span>
<span class="org-haskell-definition">readFile</span> <span class="org-string">"squares.txt"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> content <span class="org-haskell-operator">&lt;-</span> readFile <span class="org-string">"squares.txt"</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t content
<span class="org-haskell-definition">content</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span>
<span class="org-haskell-operator">&gt;</span> content
<span class="org-string">"[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]"</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> array <span class="org-haskell-operator">=</span> read content <span class="org-haskell-operator">::</span> [(<span class="org-haskell-type">Int</span>,<span class="org-haskell-type">Int</span>)]
<span class="org-haskell-operator">&gt;</span> array
[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> readSquareFile <span class="org-haskell-operator">=</span> liftM (<span class="org-haskell-operator">\</span>cont <span class="org-haskell-operator">-&gt;</span> read cont <span class="org-haskell-operator">::</span> [(<span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>)]) (readFile <span class="org-string">"squares.txt"</span>)
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> readSquareFile 
[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t readSquareFile 
<span class="org-haskell-definition">readSquareFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> [(<span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> sq <span class="org-haskell-operator">&lt;-</span> readSquareFile 
<span class="org-haskell-operator">&gt;</span> sq
[(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t sq
<span class="org-haskell-definition">sq</span> <span class="org-haskell-operator">::</span> [(<span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t liftM (map <span class="org-haskell-operator">$</span> uncurry (<span class="org-haskell-operator">+</span>)) readSquareFile 
<span class="org-haskell-definition">liftM</span> (map <span class="org-haskell-operator">$</span> uncurry (<span class="org-haskell-operator">+</span>)) readSquareFile <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> [<span class="org-haskell-type">Int</span>]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">liftM</span> (map <span class="org-haskell-operator">$</span> uncurry (<span class="org-haskell-operator">+</span>)) readSquareFile 
[0,2,6,12,20,30,42,56,72,90,110]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-8-1-1" class="outline-5">
<h5 id="sec-1-8-1-1"><span class="section-number-5">1.8.1.1</span> Sources</h5>
<div class="outline-text-5" id="text-1-8-1-1">
<ul class="org-ul">
<li><a href="https://wiki.haskell.org/Introduction_to_IO">Introduction to IO</a>
</li>
<li><a href="https://www.haskell.org/tutorial/io.html">A Gentle Introduction to Haskell, Version 98 -  Input/Output</a>
</li>

<li><a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads">http://en.wikibooks.org/wiki/Haskell/Understanding_monads</a>
</li>
<li><a href="http://shuklan.com/haskell/lec09.html#/">http://shuklan.com/haskell/lec09.html#/</a>
</li>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">http://learnyouahaskell.com/functors-applicative-functors-and-monoids</a>
</li>
<li><a href="http://squing.blogspot.com.br/2008/01/unmonad-tutorial-io-in-haskell-for-non.html">http://squing.blogspot.com.br/2008/01/unmonad-tutorial-io-in-haskell-for-non.html</a>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> State Monad</h3>
<div class="outline-text-3" id="text-1-9">
<p>
A stateless function or pure function is a function that only relies
on its input. State monad allows to simulate aspects of imperative
language in pure a functional language.
</p>

<p>
Many Haskell tutorials and examples about State Monad won't run or
compile because the Control.Monad.State has changed and State was
deprecated in favor of StateT, unfortunately it makes many tutorials
about State Monads be outdated and it might frustrate newcomers trying
to understand it for the first time. To solve this problem this
tutorial will use the old implementation of State Monad which the
source code is provided here: <a href="src/OldState.hs">OldState</a>.
</p>


<p>
Some StackOverflow threads describing the problem:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/9697980/the-state-monad-and-learnyouahaskell-com">The state monad and learnyouahaskell.com</a> 
</li>
<li><a href="http://stackoverflow.com/questions/24103108/where-is-the-data-constructor-for-state">Where is the data constructor for 'State'?</a>
</li>
<li><a href="http://stackoverflow.com/questions/14157090/has-the-control-monad-state-api-changed-recently">Has the Control.Monad.State API changed recently?</a>
</li>
</ul>

<p>
Reproducing the bug:
</p>

<p>
The example from <a href="http://learnyouahaskell.com/for-a-few-monads-more">Learn You a Haskell's guide on the state monad</a> will
fail when trying to run or compile it.
</p>

<p>
File: stack.hs
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad.State</span>  

<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-operator">=</span> [<span class="org-haskell-type">Int</span>]

<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-type">Int</span>  
<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>(x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">-&gt;</span> (x,xs)  

<span class="org-haskell-definition">push</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-constructor">()</span>  
<span class="org-haskell-definition">push</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>xs <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-constructor">()</span>,a<span class="org-haskell-constructor">:</span>xs)
</pre>
</div>

<p>
Running:
</p>

<div class="org-src-container">

<pre class="src src-haskell">tux<span class="org-haskell-definition">@</span>tux  <span class="org-haskell-operator">/</span>tmp
<span class="org-haskell-operator">$</span> ghci

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l stack<span class="org-haskell-operator">.</span>hs
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( stack<span class="org-haskell-operator">.</span>hs, interpreted )

stack<span class="org-haskell-definition">.</span>hs<span class="org-haskell-constructor">:</span>6<span class="org-haskell-constructor">:</span>7<span class="org-haskell-constructor">:</span>
    <span class="org-haskell-constructor">Not</span> <span class="org-haskell-keyword">in</span> scope<span class="org-haskell-constructor">:</span> <span class="org-haskell-keyword">data</span> constructor `<span class="org-haskell-type">State'</span>
    <span class="org-haskell-constructor">Perhaps</span> you meant `<span class="org-haskell-constructor">StateT'</span> (imported from <span class="org-haskell-constructor">Control.Monad.State</span>)

stack<span class="org-haskell-definition">.</span>hs<span class="org-haskell-constructor">:</span>9<span class="org-haskell-constructor">:</span>10<span class="org-haskell-constructor">:</span>
    <span class="org-haskell-constructor">Not</span> <span class="org-haskell-keyword">in</span> scope<span class="org-haskell-constructor">:</span> <span class="org-haskell-keyword">data</span> constructor `<span class="org-haskell-type">State'</span>
    <span class="org-haskell-constructor">Perhaps</span> you meant `<span class="org-haskell-constructor">StateT'</span> (imported from <span class="org-haskell-constructor">Control.Monad.State</span>)
<span class="org-haskell-constructor">Failed</span>, modules loaded<span class="org-haskell-constructor">:</span> none<span class="org-haskell-operator">.</span>
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Solutions: Use the old Control.Monad.State implementation. That it is
available in the file: <i>OldState.hs</i>
</p>

<p>
File: <i>stack.hs</i>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">--</span><span class="org-comment">import Control.Monad.State  </span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>


<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-operator">=</span> [<span class="org-haskell-type">Int</span>]

<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-type">Int</span>  
<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>(x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">-&gt;</span> (x,xs)  

<span class="org-haskell-definition">push</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-constructor">()</span>  
<span class="org-haskell-definition">push</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>xs <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-constructor">()</span>,a<span class="org-haskell-constructor">:</span>xs) 

<span class="org-haskell-definition">stackStuff</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-constructor">()</span>  
<span class="org-haskell-definition">stackStuff</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>  
    a <span class="org-haskell-operator">&lt;-</span> pop  
    <span class="org-haskell-keyword">if</span> a <span class="org-haskell-operator">==</span> 5  
        <span class="org-haskell-keyword">then</span> push 5  
        <span class="org-haskell-keyword">else</span> <span class="org-haskell-keyword">do</span>  
            push 3  
            push 8  

<span class="org-haskell-definition">moreStack</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Stack</span> <span class="org-haskell-constructor">()</span>  
<span class="org-haskell-definition">moreStack</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>  
    a <span class="org-haskell-operator">&lt;-</span> stackManip  
    <span class="org-haskell-keyword">if</span> a <span class="org-haskell-operator">==</span> 100  
        <span class="org-haskell-keyword">then</span> stackStuff  
        <span class="org-haskell-keyword">else</span> return <span class="org-haskell-constructor">()</span>
</pre>
</div>

<p>
Running:
</p>

<pre class="example">
tux@tux  /tmp
$ ghci

&gt; 
&gt; :load stack.hs 
[1 of 1] Compiling Main             ( stack.hs, interpreted )
Ok, modules loaded: Main.
&gt; 

&gt; runState stackStuff [9,0,2,1,0]  
((),[8,3,0,2,1,0])
&gt; 

&gt; runState stackManip [5,8,2,1] 
(5,[8,2,1])
&gt;
</pre>

<p>
The type (State s a) wraps function that takes an state a and returns
a tuple containing a return value a and new state: \s -&gt; (a, s). Where
(s) is the state type and (a) is the return value.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> s a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> { runState <span class="org-haskell-operator">::</span> s <span class="org-haskell-operator">-&gt;</span> (a, s) }
</pre>
</div>

<p>
The function runState applies a state function / state processor to a
state and returns a value and a new state.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l OldState.hs 
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">OldState</span>         ( OldState.hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> OldState.
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t runState 
<span class="org-haskell-definition">runState</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> s a <span class="org-haskell-operator">-&gt;</span> s <span class="org-haskell-operator">-&gt;</span> (a, s)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> incstate  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> ( <span class="org-haskell-operator">\</span>s <span class="org-haskell-operator">-&gt;</span> (s<span class="org-haskell-operator">+</span>1, s<span class="org-haskell-operator">+</span>1) )
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t incstate 
<span class="org-haskell-definition">incstate</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> incstate 2
(3,3)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> incstate 3
(4,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> incstate 4
(5,5)
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Get - Getting State
</p>

<div class="org-src-container">

<pre class="src src-haskell">    <span class="org-comment-delimiter">--  </span><span class="org-comment">return a        = State $ \s -&gt; (a,s)</span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">runState :: (\s -&gt; (a, s)) -&gt; s -&gt; (a, s)</span>
    <span class="org-comment-delimiter">--  </span>
    <span class="org-comment-delimiter">--  </span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; runState (return 10) 1 </span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; runState (\s -&gt; (10,s)) 1 </span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; (\s -&gt; (10,s)) 1 </span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; (10, 1)</span>
    <span class="org-comment-delimiter">--      </span>
    <span class="org-comment-delimiter">--  </span><span class="org-comment">Generalizing:</span>
    <span class="org-comment-delimiter">--      </span>
    <span class="org-comment-delimiter">--      </span><span class="org-comment">runstate (return a) s = (a, s)</span>
    <span class="org-comment-delimiter">--</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (return 10) 1
(10,1)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (return 10) <span class="org-string">'a'</span>
(10,<span class="org-string">'a'</span>)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (return <span class="org-string">'x'</span>) 10
(<span class="org-string">'x'</span>,10)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-comment-delimiter">{-</span>
<span class="org-comment">    get = State $ \s -&gt; (s,s) </span>
<span class="org-comment">    runState :: (\s -&gt; (a, s)) -&gt; s -&gt; (a, s)</span>

<span class="org-comment">    =&gt; runState get 1</span>
<span class="org-comment">    =&gt; runState (\s -&gt; (s,s))  1</span>
<span class="org-comment">    =&gt; (\s -&gt; (s,s)) 1</span>
<span class="org-comment">    =&gt; (1, 1) </span>

<span class="org-comment">     runState get x = (x, x)</span>
<span class="org-comment">-}</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> get 1
(1,1)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> get <span class="org-string">'z'</span>
(<span class="org-string">'z'</span>,<span class="org-string">'z'</span>)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> get <span class="org-string">"hello"</span>
(<span class="org-string">"hello"</span>,<span class="org-string">"hello"</span>)
</pre>
</div>

<p>
Put - Changing State
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">--  </span><span class="org-comment">put :: s -&gt; State s ()</span>
<span class="org-comment-delimiter">--  </span><span class="org-comment">put newState = State $ \s -&gt; ((),newState) </span>
<span class="org-comment-delimiter">--   </span><span class="org-comment">runState :: (\s -&gt; (a, s)) -&gt; s -&gt; (a, s)</span>
<span class="org-comment-delimiter">--  </span>
<span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; runState  (put 5) 4 </span>
<span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; runState  (\s -&gt; ((), 5)) 4 </span>
<span class="org-comment-delimiter">--  </span><span class="org-comment">=&gt; ((), 5) </span>
<span class="org-comment-delimiter">--  </span>
<span class="org-comment-delimiter">--  </span><span class="org-comment">runstate (put x) s = ((), x)</span>


<span class="org-haskell-operator">&gt;</span>  runState  (put 5) 4 
(<span class="org-haskell-constructor">()</span>,5)
<span class="org-haskell-operator">&gt;</span>  runState  (put 5) 100 
(<span class="org-haskell-constructor">()</span>,5)
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Do Notation</b>
</p>

<p>
This function postincrement is the same as: 
</p>

<pre class="example">
postincrement x = (x, x+1)
</pre>

<p>
where x is the return value of the stateful computation and x + 1 is
the new state.
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">postincrement</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span> 
    x <span class="org-haskell-operator">&lt;-</span> get        <span class="org-comment-delimiter">-- </span><span class="org-comment">x = s (Current State )-}</span>
    put (x<span class="org-haskell-operator">+</span>1)       <span class="org-comment-delimiter">-- </span><span class="org-comment">set the  's' value in (a,s) to x+1. (a, s=x+1)}</span>
    return x        <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the value a (return value to x) =&gt; </span>
                    <span class="org-comment-delimiter">-- </span><span class="org-comment">(a=x, s=x+1)</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> postincrement <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Int</span> ; postincrement <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span> { x <span class="org-haskell-operator">&lt;-</span> get ;  put (x <span class="org-haskell-operator">+</span> 1) ; return x }

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t postincrement 
<span class="org-haskell-definition">postincrement</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Int</span>
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t runState postincrement 
<span class="org-haskell-definition">runState</span> postincrement <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> postincrement 0
(0,1)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> postincrement 1
(1,2)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> postincrement 2
(2,3)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> postincrement 3
(3,4)


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalState</span> postincrement 0
0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalState</span> postincrement 1
1
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalState</span> postincrement 2
2
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalState</span> postincrement 3
3
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execState</span> postincrement 0
1
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execState</span> postincrement 1
2
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execState</span> postincrement 2
3
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execState</span> postincrement 3
4


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t state <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1)
state <span class="org-haskell-definition">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1) <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Num</span> a, <span class="org-haskell-type">MonadState</span> a m) <span class="org-haskell-operator">=&gt;</span> m a
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (state <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1)) 0
(0,1)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (state <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1)) 1
(1,2)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (state <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1)) 2
(2,3)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (state <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> (x, x<span class="org-haskell-operator">+</span>1)) 3
(3,4)
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">-- </span><span class="org-comment">import Control.Monad.State</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>

<span class="org-haskell-definition">test1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Int</span>
<span class="org-haskell-definition">test1</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  put 3         <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the state to 3 --&gt; (\s -&gt; ((), s)) 3 = ((), 3)</span>
  modify (<span class="org-haskell-operator">+</span>1)   <span class="org-comment-delimiter">-- </span><span class="org-comment">Apply the infix function (+1) to the state ((), 4)</span>
  get           <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the return value to the state (4, 4)</span>


<span class="org-haskell-definition">test2</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  put 3         <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the state to 3 --&gt; (\s -&gt; ((), s)) 3 = ((), 3)</span>
  modify (<span class="org-haskell-operator">+</span>1)   <span class="org-comment-delimiter">-- </span><span class="org-comment">Apply the infix function (+1) to the state ((), 4)</span>
                <span class="org-comment-delimiter">-- </span><span class="org-comment">The return value will be ((), 4) </span>

<span class="org-haskell-definition">test3</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  x <span class="org-haskell-operator">&lt;-</span> get          <span class="org-comment-delimiter">-- </span><span class="org-comment">x = current State / Passed by runState </span>
  <span class="org-haskell-keyword">let</span> y <span class="org-haskell-operator">=</span> 10 <span class="org-haskell-operator">*</span> x    
  put (x<span class="org-haskell-operator">+</span>2)         <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the current state to x+2 ==&gt; ((), x+2)</span>
  return y          <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the return value to y ==&gt; (y, x+2)</span>
                    <span class="org-comment-delimiter">-- </span><span class="org-comment">It will compute (10 * x, x + 2)</span>
<span class="org-haskell-definition">test4</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    a <span class="org-haskell-operator">&lt;-</span> get
    b <span class="org-haskell-operator">&lt;-</span> test1
    put (a<span class="org-haskell-operator">+</span>b)
    return (a <span class="org-haskell-operator">+</span> 2<span class="org-haskell-operator">*</span>b)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test1 0
(4,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test1 1
(4,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test1 2
(4,4)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t test2
<span class="org-haskell-definition">test2</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-constructor">()</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">--  </span><span class="org-comment">State Integer () = State s a  ==&gt; s = Interger and a = ()</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test2 3
(<span class="org-haskell-constructor">()</span>,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test2 4
(<span class="org-haskell-constructor">()</span>,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test2 0
(<span class="org-haskell-constructor">()</span>,4)


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t test3
<span class="org-haskell-definition">test3</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-type">Integer</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span>  test3 0  <span class="org-comment-delimiter">-- </span><span class="org-comment">(\x -&gt; 10 * x, x + 2) 0 = (0, 2)</span>
(0,2)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span>  test3 2  <span class="org-comment-delimiter">-- </span><span class="org-comment">(\x -&gt; 10 * x, x + 2) 2 = (20, 4)</span>
(20,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span>  test3 4  <span class="org-comment-delimiter">-- </span><span class="org-comment">(\x -&gt; 10 * x, x + 2) 4 = (10, 6)</span>
(40,6)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span>  test3 6  <span class="org-comment-delimiter">-- </span><span class="org-comment">(\x -&gt; 10 * x, x + 2) 6 = (60, 8)</span>
(60,8)


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t test4
<span class="org-haskell-definition">test4</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Int</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test4 0
(8,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test4 1
(9,5)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test4 2
(10,6)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test4 8
(16,12)
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
The combinators evalStateNtimes, runStateNtimes, execStateNtimes,
evalStateLoop, runStateLoop and execStateLoop defined in <i>OldState.hs</i>,
although they are not defined in the old Control.State.Monad library,
they make easier to compute successive executions of state function.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>

<span class="org-haskell-definition">test3</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  x <span class="org-haskell-operator">&lt;-</span> get          <span class="org-comment-delimiter">-- </span><span class="org-comment">x = current State / Passed by runState </span>
  <span class="org-haskell-keyword">let</span> y <span class="org-haskell-operator">=</span> 10 <span class="org-haskell-operator">*</span> x    
  put (x<span class="org-haskell-operator">+</span>2)         <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the current state to x+2 ==&gt; ((), x+2)</span>
  return y          <span class="org-comment-delimiter">-- </span><span class="org-comment">Set the return value to y ==&gt; (y, x+2)</span>
                    <span class="org-comment-delimiter">-- </span><span class="org-comment">It will compute (10 * x, x + 2)</span>

<span class="org-comment-delimiter">{- </span><span class="org-comment">Instead of do it -}</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 0
(0,2)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 2
(20,4)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 4
(40,6)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 6
(60,8)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 8
(80,10)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 10
(100,12)
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> test3 12
(120,14)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-comment-delimiter">{- </span><span class="org-comment">It is better by this way. -}</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 0
<span class="org-haskell-constructor">[]</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 1
[0]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 2
[0,20]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 3
[0,20,40]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 4
[0,20,40,60]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 5
[0,20,40,60,80]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> test3 0 6
[0,20,40,60,80,100]

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 0
<span class="org-haskell-constructor">[]</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 1
[(0,2)]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 2
[(0,2),(20,4)]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 4
[(0,2),(20,4),(40,6),(60,8)]

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 1
[(0,2)]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 2
[(0,2),(20,4)]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 4
[(0,2),(20,4),(40,6),(60,8)]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 5
[(0,2),(20,4),(40,6),(60,8),(80,10)]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runStateNtimes</span> test3 0 6
[(0,2),(20,4),(40,6),(60,8),(80,10),(100,12)]


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execStateNtimes</span> test3 0 0
<span class="org-haskell-constructor">[]</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execStateNtimes</span> test3 0 1
[2]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execStateNtimes</span> test3 0 2
[2,4]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execStateNtimes</span> test3 0 3
[2,4,6]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execStateNtimes</span> test3 0 6
[2,4,6,8,10,12]
<span class="org-haskell-operator">&gt;</span> 


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">take</span> 3 (evalStateLoop test3 0)
[0,20,40]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">take</span> 10 (evalStateLoop test3 0)
[0,20,40,60,80,100,120,140,160,180]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">take</span> 10 (execStateLoop test3 0)
[2,4,6,8,10,12,14,16,18,20]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">take</span> 10 (runStateLoop test3 0)
[(0,2),(20,4),(40,6),(60,8),(80,10),(100,12),(120,14),(140,16),(160,18),(180,20)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">takeWhile</span> (<span class="org-haskell-operator">&lt;</span>100) (evalStateLoop  test3 0)
[0,20,40,60,80]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 0
0
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 1
20
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 2
40
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 3
60
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 4
80
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalNthState</span> test3 0 5
100
</pre>
</div>

<p>
<b>Example Random Numbers</b>
</p>

<p>
from <a href="http://learnyouahaskell.com/for-a-few-monads-more">For a Few Monads More / Learn You a Haskell book</a>
</p>

<p>
threeCoins is a state function (State s a = \s -&gt; (a, s) which the
state type is StdGen and the return type is a tuple of Bools
(Bool,Bool,Bool)
</p>

<p>
file: <i>randomst.hs</i>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Random</span>  
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>         <span class="org-comment-delimiter">-- </span><span class="org-comment">import Control.Monad.State  </span>

<span class="org-haskell-definition">threeCoins</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">StdGen</span> (<span class="org-haskell-type">Bool</span>,<span class="org-haskell-type">Bool</span>,<span class="org-haskell-type">Bool</span>)  
<span class="org-haskell-definition">threeCoins</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>  
    a <span class="org-haskell-operator">&lt;-</span> randomSt  
    b <span class="org-haskell-operator">&lt;-</span> randomSt  
    c <span class="org-haskell-operator">&lt;-</span> randomSt  
    return (a,b,c)
</pre>
</div>

<p>
Running:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l randomst<span class="org-haskell-operator">.</span>hs 
[1 <span class="org-haskell-keyword">of</span> 2] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">OldState</span>         ( OldState.hs, interpreted )
[2 <span class="org-haskell-keyword">of</span> 2] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( randomst<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">OldState</span>, Main.
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t random
<span class="org-haskell-definition">random</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">RandomGen</span> g, <span class="org-haskell-type">Random</span> a) <span class="org-haskell-operator">=&gt;</span> g <span class="org-haskell-operator">-&gt;</span> (a, g)
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>i random
<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Random</span> a <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-operator">...</span>
  random <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RandomGen</span> g <span class="org-haskell-operator">=&gt;</span> g <span class="org-haskell-operator">-&gt;</span> (a, g)
  <span class="org-haskell-operator">...</span>
    <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `System.Random'</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>t mkStdGen 
<span class="org-haskell-definition">mkStdGen</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">StdGen</span>
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-type">:</span>i mkStdGen 
<span class="org-haskell-definition">mkStdGen</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">StdGen</span>   <span class="org-comment-delimiter">-- </span><span class="org-comment">Defined in `System.Random'</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> threeCoins (mkStdGen 33)
<span class="org-haskell-constructor">Loading</span> package random<span class="org-haskell-operator">-</span>1.0<span class="org-haskell-operator">.</span>1.1 <span class="org-haskell-operator">...</span> linking <span class="org-haskell-operator">...</span> done<span class="org-haskell-operator">.</span>
((<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">True</span>),680029187 2103410263)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> threeCoins (mkStdGen 100)
((<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">False</span>),693699796 2103410263)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalState</span>  threeCoins (mkStdGen 100)
(<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">False</span>)
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">execState</span> threeCoins (mkStdGen 100)
693699796 2103410263
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> threeCoins (mkStdGen 33) 3
[(<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">True</span>),(<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">True</span>),(<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">False</span>,<span class="org-haskell-constructor">False</span>)]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Example: Fibonacci Sequence</b>
</p>

<p>
The Fibonacci sequence is defined by the rule:  
</p>

<pre class="example">
a[n+2] = a[n+1] + a[n]
</pre>

<pre class="example">
0 
    1
        1 = 1 + 0
           2  = 1 + 1
             3  = 2 + 1
                5 = 3 + 2
                    8 = 5 + 3 
                        ...
</pre>

<p>
It is obvious that the function needs to keep track of the last two
values.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l <span class="org-haskell-constructor">OldState</span>
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">OldState</span>         ( OldState.hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> OldState.
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">The new state is set to be (an1, an2) and the return value an2, so</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">it means  \(an, an1) -&gt; (an2, (an1, an2))</span>
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> fibState1 <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span>(an, an1) <span class="org-haskell-operator">-&gt;</span> (an <span class="org-haskell-operator">+</span> an1, (an1, an <span class="org-haskell-operator">+</span> an1))
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t fibState1 
<span class="org-haskell-definition">fibState1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> (<span class="org-haskell-type">Integer</span>, <span class="org-haskell-type">Integer</span>) <span class="org-haskell-type">Integer</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (0, 1)
(1,(1,1))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (1, 1)
(2,(1,2))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (1, 2)
(3,(2,3))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (2, 3)
(5,(3,5))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (3, 5)
(8,(5,8))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibState1 (5, 8)
(13,(8,13))
<span class="org-haskell-operator">&gt;</span> 
<span class="org-comment-delimiter">{-</span><span class="org-comment">- OR --}</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> fibState1 (0, 1)  20
[1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>

<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Fib</span> <span class="org-haskell-operator">=</span> (<span class="org-haskell-type">Integer</span>, <span class="org-haskell-type">Integer</span>)

<span class="org-haskell-definition">fibstate2</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Fib</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">fibstate2</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    (an, an1) <span class="org-haskell-operator">&lt;-</span> get
    <span class="org-haskell-keyword">let</span> an2 <span class="org-haskell-operator">=</span> an <span class="org-haskell-operator">+</span> an1
    put (an1, an2)
    return an2

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>t fibstate2 
<span class="org-haskell-definition">fibstate2</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> <span class="org-haskell-type">Fib</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (0, 1)
(1,(1,1))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (1, 1)
(2,(1,2))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (1, 2)
(3,(2,3))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (2, 3)
(5,(3,5))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (3, 5)
(8,(5,8))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> fibstate2 (5, 8)
(13,(8,13))

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> fibstate2 (0, 1)  20
[1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Example: Root Solving / Secant Method</b>
</p>

<p>
See: <a href="http://en.wikipedia.org/wiki/Secant_method">Secant Method</a>
</p>

<p>
Algorithm:
</p>

<pre class="example">
x[n+2] =  x[n] - y[n]*(x[n+1] - x[n])/(y[n+1] - y[n])
</pre>

<p>
Example: Solve the equation x^2 - 2.0 = 0 whic the solution is sqrt(2)
by the secant method.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>

<span class="org-haskell-definition">secantStateFactory</span> f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    (xn, xn1) <span class="org-haskell-operator">&lt;-</span> get
    <span class="org-haskell-keyword">let</span> yn  <span class="org-haskell-operator">=</span> f xn
    <span class="org-haskell-keyword">let</span> yn1 <span class="org-haskell-operator">=</span> f xn1
    <span class="org-haskell-keyword">let</span> xn2 <span class="org-haskell-operator">=</span> xn <span class="org-haskell-operator">-</span> yn <span class="org-haskell-operator">*</span> (xn1 <span class="org-haskell-operator">-</span> xn)<span class="org-haskell-operator">/</span>(yn1 <span class="org-haskell-operator">-</span> yn)

    put (xn1, xn2)

    return xn2

<span class="org-haskell-definition">f</span> x <span class="org-haskell-operator">=</span> x<span class="org-haskell-operator">**</span>2.0 <span class="org-haskell-operator">-</span> 2.0



<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> (secantStateFactory f) (5.0, 10.0) 8
[3.466666666666667,2.7227722772277225,1.848139063666418,1.5384375855421741,1.4301305124704486,1.4148796301580984,1.4142172888159419,1.4142135632504291]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">If the sequence a0, a1, a2, a3, ... is converging then </span>
<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">-- </span><span class="org-comment">abs(a[i] - a[i-1]) &lt; eps</span>
<span class="org-haskell-operator">&gt;</span>

<span class="org-haskell-definition">withinr</span> tol itmax serie <span class="org-haskell-operator">=</span>
    <span class="org-haskell-keyword">case</span> (itmax, serie) <span class="org-haskell-keyword">of</span>
        (<span class="org-haskell-keyword">_</span>, <span class="org-haskell-constructor">[]</span>)         <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
        (0, x<span class="org-haskell-constructor">:</span>xs)       <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> x
        (i, x1<span class="org-haskell-constructor">:</span>x2<span class="org-haskell-constructor">:</span>xs)   <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">if</span> abs(x1 <span class="org-haskell-operator">-</span> x2)  <span class="org-haskell-operator">&lt;</span> abs(tol <span class="org-haskell-operator">*</span> x2)
                                <span class="org-haskell-keyword">then</span> <span class="org-haskell-constructor">Just</span> x2
                                <span class="org-haskell-keyword">else</span> withinr tol (itmax <span class="org-haskell-operator">-</span> 1) xs


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">withinr</span> 1e-3 1000 <span class="org-haskell-operator">$</span> evalStateLoop  (secantStateFactory f) (5.0, 10.0) 
<span class="org-haskell-constructor">Just</span> 1.4142135632504291
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> secantSolver tol itmax f x0 x1 <span class="org-haskell-operator">=</span> withinr tol itmax <span class="org-haskell-operator">$</span> evalStateLoop  (secantStateFactory f) (x0, x1)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">secantSolver</span> 1e-3 100 (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x<span class="org-haskell-operator">**</span>3.0 <span class="org-haskell-operator">-</span> x <span class="org-haskell-operator">-</span> 2) 1.0 2.0
<span class="org-haskell-constructor">Just</span> 1.5213797079848717
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Example: Bisection Method for Root Solving</b>
</p>


<p>
<a href="http://en.wikipedia.org/wiki/Bisection_method">Bisection method</a>
</p>

<p>
Algorithm:
</p>

<pre class="example">
INPUT: Function f, endpoint values a, b, tolerance TOL, maximum iterations NMAX
CONDITIONS: a &lt; b, either f(a) &lt; 0 and f(b) &gt; 0 or f(a) &gt; 0 and f(b) &lt; 0
OUTPUT: value which differs from a root of f(x)=0 by less than TOL
 
N  1
While N  NMAX # limit iterations to prevent infinite loop
  c  (a + b)/2 # new midpoint
  If f(c) = 0 or (b  a)/2 &lt; TOL then # solution found
    Output(c)
    Stop
  EndIf
  N  N + 1 # increment step counter
  If sign(f(c)) = sign(f(a)) then a  c else b  c # new interval
EndWhile
Output("Method failed.") # max number of steps exceeded
</pre>

<p>
File: <i>bisection_state.hs</i>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">OldState</span>

<span class="org-haskell-definition">bisecStateFactory</span> f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    (a, b) <span class="org-haskell-operator">&lt;-</span> get
    <span class="org-haskell-keyword">let</span> c <span class="org-haskell-operator">=</span> (a <span class="org-haskell-operator">+</span> b) <span class="org-haskell-operator">/</span> 2.0

    <span class="org-comment-delimiter">--  </span><span class="org-comment">If sign(f(c)) = sign(f(a))  else b &#8592; c</span>
    <span class="org-haskell-keyword">if</span> (f c) <span class="org-haskell-operator">*</span> (f a) <span class="org-haskell-operator">&gt;=</span> 0   
        <span class="org-haskell-keyword">then</span>    put (c, b)  <span class="org-comment-delimiter">-- </span><span class="org-comment">then a &#8592; c</span>
        <span class="org-haskell-keyword">else</span>    put (a, c)  <span class="org-comment-delimiter">-- </span><span class="org-comment">else b &#8592; c</span>

    return c

<span class="org-haskell-definition">findRoot</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> (<span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>) <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-type">Double</span>] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">findRoot</span> eps itmax f serie <span class="org-haskell-operator">=</span>
    <span class="org-haskell-keyword">case</span> (itmax, serie) <span class="org-haskell-keyword">of</span>   
        (<span class="org-haskell-keyword">_</span>, <span class="org-haskell-constructor">[]</span>)          <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
        (0, (x<span class="org-haskell-constructor">:</span>xs))      <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">if</span> abs(f x) <span class="org-haskell-operator">&lt;</span> eps <span class="org-haskell-keyword">then</span> <span class="org-haskell-constructor">Just</span> x <span class="org-haskell-keyword">else</span> <span class="org-haskell-constructor">Nothing</span>
        (i, (x<span class="org-haskell-constructor">:</span>xs))      <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">if</span> abs(f x) <span class="org-haskell-operator">&lt;</span> eps 
                                <span class="org-haskell-keyword">then</span> <span class="org-haskell-constructor">Just</span> x
                            <span class="org-haskell-keyword">else</span>
                                findRoot eps (i <span class="org-haskell-operator">-</span> 1) f xs

<span class="org-haskell-definition">bisecSolver</span> eps itmax f x0 x1 <span class="org-haskell-operator">=</span>
    findRoot eps f (evalStateLoop  (bisecStateFactory f (x0, x1)))

<span class="org-haskell-definition">f</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">f</span> x <span class="org-haskell-operator">=</span>  x <span class="org-haskell-operator">**</span> 3.0 <span class="org-haskell-operator">-</span> x <span class="org-haskell-operator">-</span> 2.0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>l bisection_state<span class="org-haskell-operator">.</span>hs 
[1 <span class="org-haskell-keyword">of</span> 2] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">OldState</span>         ( OldState.hs, interpreted )
[2 <span class="org-haskell-keyword">of</span> 2] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( bisection_state<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">OldState</span>, Main.


<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (bisecStateFactory f) (1, 2)
(1.5,(1.5,2.0))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (bisecStateFactory f) (1.5, 2)
(1.75,(1.5,1.75))
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">runState</span> (bisecStateFactory f) (1.5,1.75)
(1.625,(1.5,1.625))
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">eval</span> (bisecStateFactory f) (1.5,1.75)
<span class="org-haskell-definition">evalNthState</span>     evalState        evalStateLoop    evalStateNtimes
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">evalStateNtimes</span> (bisecStateFactory f) (1.5,1.75) 10
[1.625,1.5625,1.53125,1.515625,1.5234375,1.51953125,1.521484375,1.5205078125,1.52099609375,1.521240234375]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">findRoot</span> 1e-3 1000 f (evalStateLoop  (bisecStateFactory f) (10.0, 20.0))
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">bisecSolver</span> 1e-3 1000 f 1.0 2.0
<span class="org-haskell-constructor">Just</span> 1.521484375
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">bisecSolver</span> 1e-3 1000 f 10.0 20.0
<span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">bisecSolver</span> 1e-3 1000 f (<span class="org-haskell-operator">-</span>10.0) 20.0
<span class="org-haskell-constructor">Just</span> 1.521453857421875
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
References:
</p>

<ul class="org-ul">
<li><a href="https://wiki.haskell.org/State_Monad">https://wiki.haskell.org/State_Monad</a>
</li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Monad_transformers">http://en.wikibooks.org/wiki/Haskell/Monad_transformers</a>
</li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State">http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State</a>
</li>
<li><a href="http://www.informatik.uni-bremen.de/agbkb/lehre/ws04-05/fmsd/State.hs">http://www.informatik.uni-bremen.de/agbkb/lehre/ws04-05/fmsd/State.hs</a>
</li>
<li><a href="https://wiki.haskell.org/State_Monad">https://wiki.haskell.org/State_Monad</a>
</li>

<li><a href="http://stackoverflow.com/questions/24103108/where-is-the-data-constructor-for-state">http://stackoverflow.com/questions/24103108/where-is-the-data-constructor-for-state</a>
</li>

<li><a href="http://www.dcc.fc.up.pt/~pbv/aulas/tapf/slides/monads.html">http://www.dcc.fc.up.pt/~pbv/aulas/tapf/slides/monads.html</a>
</li>
<li><a href="http://www2.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/modules.html">http://www2.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/modules.html</a>
</li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Modules">http://en.wikibooks.org/wiki/Haskell/Modules</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Caio Rodrigues</p>
<p class="date">Created: 2017-03-05 dom 08:15</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>