<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Scheme</title>
<!-- 2017-03-06 seg 13:09 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="arch" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href='/theme/style.css' rel='stylesheet'>

<script type="text/javascript" src="/theme/org-info.js">
/**
 *
 * @source: /theme/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in /theme/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in /theme/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Scheme</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Scheme</a>
<ul>
<li><a href="#sec-1-1">1.1. Overview</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. Why Lisp</a></li>
<li><a href="#sec-1-1-2">1.1.2. Scheme Features</a></li>
<li><a href="#sec-1-1-3">1.1.3. Scheme Implementations</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. Basic Syntax</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. Name Conventions</a></li>
<li><a href="#sec-1-2-2">1.2.2. Syntax</a></li>
<li><a href="#sec-1-2-3">1.2.3. Data Types</a></li>
<li><a href="#sec-1-2-4">1.2.4. Variables</a></li>
<li><a href="#sec-1-2-5">1.2.5. Functions</a></li>
<li><a href="#sec-1-2-6">1.2.6. List Operations</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. Higher Order Functions</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Buit-in Functions</a></li>
<li><a href="#sec-1-3-2">1.3.2. Special Functions</a></li>
<li><a href="#sec-1-3-3">1.3.3. Functions Composition</a></li>
<li><a href="#sec-1-3-4">1.3.4. Partial Application and Currying</a></li>
<li><a href="#sec-1-3-5">1.3.5. Applying Multiple Functions to a Single Argument</a></li>
<li><a href="#sec-1-3-6">1.3.6. Miscellaneous</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Lazy Evaluation / Delayed Evaluation</a></li>
<li><a href="#sec-1-5">1.5. Object Orientated Programming</a></li>
<li><a href="#sec-1-6">1.6. Metaprogramming</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. The Abstract Syntax Tree</a></li>
<li><a href="#sec-1-6-2">1.6.2. Macros</a></li>
</ul>
</li>
<li><a href="#sec-1-7">1.7. S-expressions and Serialization</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. Association Lists and Property Lists</a></li>
<li><a href="#sec-1-7-2">1.7.2. Serialization and Deserialization</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. Debugging</a>
<ul>
<li><a href="#sec-1-8-1">1.8.1. MIT Scheme</a></li>
<li><a href="#sec-1-8-2">1.8.2. GNU Guile</a></li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. SCIP</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. Tail Recursion (Iteration)</a></li>
<li><a href="#sec-1-9-2">1.9.2. Higher Order Procedure</a></li>
<li><a href="#sec-1-9-3">1.9.3. Procedure as returned value</a></li>
<li><a href="#sec-1-9-4">1.9.4. Exercises</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. Applications</a>
<ul>
<li><a href="#sec-1-10-1">1.10.1. Lisp Evaluator written in Lisp</a></li>
<li><a href="#sec-1-10-2">1.10.2. Reverse Polish Notation Evaluator</a></li>
</ul>
</li>
<li><a href="#sec-1-11">1.11. Scheme Implementations</a>
<ul>
<li><a href="#sec-1-11-1">1.11.1. Racket</a></li>
<li><a href="#sec-1-11-2">1.11.2. Kawa Scheme - Access Java API from Scheme</a></li>
</ul>
</li>
<li><a href="#sec-1-12">1.12. Resources</a>
<ul>
<li><a href="#sec-1-12-1">1.12.1. Books</a></li>
<li><a href="#sec-1-12-2">1.12.2. Community</a></li>
<li><a href="#sec-1-12-3">1.12.3. Articles</a></li>
<li><a href="#sec-1-12-4">1.12.4. Blogs, Workshops, Conferences</a></li>
<li><a href="#sec-1-12-5">1.12.5. University Courses</a></li>
<li><a href="#sec-1-12-6">1.12.6. Repositories</a></li>
<li><a href="#sec-1-12-7">1.12.7. Misc</a></li>
<li><a href="#sec-1-12-8">1.12.8. Documentation by Subject</a></li>
<li><a href="#sec-1-12-9">1.12.9. Hacker News Threads</a></li>
<li><a href="#sec-1-12-10">1.12.10. Lambda Ultimate Threads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Scheme</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Why Lisp</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>Lisp is used as embedded script language in many products
<ul class="org-ul">
<li>Autocad -&gt; Autolisp
</li>
<li>GNUCash -&gt; GNU Guile Scheme 
</li>
<li>GIMP Editor -&gt; GNU Guile Scheme 
</li>
</ul>
</li>
</ul>

<p>
Products that use lisp:
</p>
<ul class="org-ul">
<li>Emacs -&gt; Emacs Lisp, A lisp dialect based on Common Lisp
</li>
<li>GNU Maxima -&gt; Cumputer Algebra System (CAS), Common Lisp
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Scheme Features</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>Learn the principles of programming languages
</li>
<li>Meta programming
</li>
<li>Lisp dialect that endorses Functional Programming
</li>
<li>Lightweight extension language or embedded language
</li>
<li>Scheme is used as extension language of softwares like GIMP and GnuCash
</li>
<li>Scheme can be used to test JVM and .NET API in the REPL.
<ul class="org-ul">
<li>Google App Engine Uses Kawa scheme which is a implementations for the JVM.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> Scheme Implementations</h4>
<div class="outline-text-4" id="text-1-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Implementation</th>
<th scope="col" class="left">Feature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><a href="http://www.gnu.org/software/mit-scheme">MIT Scheme</a></td>
<td class="left">Classical Scheme Implementation  used by <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">SCIP</a></td>
</tr>

<tr>
<td class="left"><a href="http://www.gnu.org/software/kawa/">Kawa</a></td>
<td class="left">Scheme for the JVM - Java API access. Compiles to the JVM</td>
</tr>

<tr>
<td class="left"><a href="https://ironscheme.codeplex.com/">Iron Scheme</a></td>
<td class="left">Scheme for .NET platform - .NET API Acess</td>
</tr>

<tr>
<td class="left"><a href="http://www.gnu.org/software/guile/gnu-guile-projects.html#Applications">GNU Guile</a></td>
<td class="left">Used as embedded extension language for many apps like GIMP, <a href="http://wiki.gnucash.org/wiki/Custom_Reports">GNUCash</a>, GEDA</td>
</tr>

<tr>
<td class="left"><a href="http://www.call-cc.org/">Chicken</a></td>
<td class="left">Compiles to Native Code, produces portable C code, package manager</td>
</tr>

<tr>
<td class="left"><a href="http://www.lambdanative.org/">Gambit-C + Lambda Native</a></td>
<td class="left">Compiles to IOS, Android, Linux, Windows &#x2026;</td>
</tr>

<tr>
<td class="left"><a href="https://github.com/ashinn/chibi-scheme">Chibi Scheme</a></td>
<td class="left">Minimal Scheme Implementation for use as an Extension Language</td>
</tr>

<tr>
<td class="left"><a href="http://www.biwascheme.org/">BiwaScheme</a></td>
<td class="left">Scheme implemented in Javascript. It can run in the browser, client side.</td>
</tr>

<tr>
<td class="left"><a href="http://racket-lang.org/">Racket</a></td>
<td class="left">IDE Dr Scheme. and Debugger. Superset of scheme, not fully compatible.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><a href="http://scsh.net/">Scsh</a></td>
<td class="left">Scsh is an open-source Unix shell embedded within Scheme, running on all</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">major Unix platforms including AIX, Cygwin, Linux, FreeBSD, GNU Hurd, HP-UX,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">Irix, Mac OS X, Solaris, and some others</td>
</tr>
</tbody>
</table>


<p>
See also: 
</p>

<ul class="org-ul">
<li><a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">What Scheme implementations are there? </a>
</li>

<li><a href="https://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations">An opinionated guide to scheme implementations</a>
</li>

<li><a href="http://www.phyast.pitt.edu/~micheles/scheme/scheme2.html">About Scheme implementations -  The Adventures of a Pythonista in Schemeland</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Basic Syntax</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Name Conventions</h4>
<div class="outline-text-4" id="text-1-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Terminology</th>
<th scope="col" class="left">Description</th>
<th scope="col" class="left">Name Convention</th>
<th scope="col" class="left">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Procedure</td>
<td class="left">functions</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Predicate</td>
<td class="left">Function that returns a boolean, true (#t) or false (#f)</td>
<td class="left">Ends with ?</td>
<td class="left">zero? null?</td>
</tr>

<tr>
<td class="left">Getter</td>
<td class="left">Function that returns a value from a Lisp object</td>
<td class="left">Ends with -ref</td>
<td class="left">list-ref</td>
</tr>

<tr>
<td class="left">Setter</td>
<td class="left">Function that sets a value in a Lisp object</td>
<td class="left">Ends with !</td>
<td class="left">set!</td>
</tr>

<tr>
<td class="left">Constructor</td>
<td class="left">A constructor is a function that creates a Lisp object.</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Converter</td>
<td class="left">Function that converts one type of Lisp object into another type</td>
<td class="left">(from type)-&gt;(to-type)</td>
<td class="left">symbol-&gt;string, number-&gt;string</td>
</tr>

<tr>
<td class="left">Iteration (SCIP book)</td>
<td class="left">Tail Recursion</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> Syntax</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Scheme uses prefix notation, or polish notation. Every operator like +,-,* is a function.
</p>

<p>
<b>Function Application</b>
</p>
<pre class="example">
(&lt;function&gt; &lt;arg1&gt; &lt;arg2&gt; &lt;arg3&gt; ...)

;; 1 + 2 + 3 + 4 + 5
&gt; (+ 1 2 3 4 5)
$1 = 15

;; 1 * 2 * 3 * 4 * 5
&gt; (* 1 2 3 4 5)
$2 = 120

&gt; (/ 1 2 3 4 5)
$3 = 1/120

&gt; (sqrt 100)
$8 = 10
</pre>

<p>
<b>Special Forms</b>
</p>

<p>
Special forms are statements that are not functions like if, then, else, begin, define &#x2026;
</p>

<pre class="example">
(&lt;special form&gt; &lt;arg1&gt; &lt;arg2&gt; &lt;arg3&gt; ...)
</pre>

<ul class="org-ul">
<li>define 
</li>
</ul>

<p>
Bind a name to a value or function (procedure).
</p>

<pre class="example">
(define &lt;name&gt; &lt;value&gt;)
(define (&lt;function-name&gt; arg1 arg2 ...) (&lt;body&gt;))

&gt; (define x 10)

&gt; x
$9 = 10

&gt; (define sqrt2 (sqrt 2))

&gt; sqrt2
$10 = 1.4142135623730951

&gt; (define (f x y) (+ x y))

&gt; f
$12 = #&lt;procedure f (x y)&gt;


&gt; (f 3 4)
$11 = 7

&gt; (define f (lambda (x y) (+ x y)))

&gt; (f 3 4)
$54 = 7
</pre>

<ul class="org-ul">
<li>lambda
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">lambda</span> (arg1 arg2 ...) (<span class="org-type">&lt;body&gt;</span>))

&gt; (<span class="org-keyword">lambda</span> (x y) (+ x y))
$52 = #&lt;procedure 9077370 at &lt;current input&gt;:463:0 (x y)&gt;

&gt; ((<span class="org-keyword">lambda</span> (x y) (+ x y)) 3 4)
$53 = 7
</pre>
</div>

<ul class="org-ul">
<li>if then else
</li>
</ul>

<pre class="example">
(if &lt;condition&gt; &lt;then statement&gt;)
(if &lt;condition&gt; &lt;then statement&gt; &lt;else statement&gt;)

&gt; (if (zero? 4) "zero" "not zero")
$5 = "not zero"

&gt; (if (zero? 4) "zero")

&gt; (if (zero? 0) "zero")
$7 = "zero"
</pre>

<ul class="org-ul">
<li>cond 
</li>
</ul>

<pre class="example">
(cond 
  (&lt;condition 1&gt; &lt;action1&gt;)
  (&lt;condition 2&gt; &lt;action12)
  ...
  (else &lt;action else&gt;)) ;; Optional

&gt; (define x 10)

&gt; x
$15 = 10

&gt; (cond 
  ((zero? x) "is zero")
  ((&lt; x 3) "Less than 3")
  ((&lt; x 5) "Less than 5")
  ((&lt; x 9) "Less than 9")
  (else    "Greater or equal 9"))
$16 = "Greater or equal 9"


;;; Returns nothing
;;
(define x 100)

&gt; (cond 
  ((zero? x) "is zero")
  ((&lt; x 3) "Less than 3")
  ((&lt; x 5) "Less than 5")
  ((&lt; x 9) "Less than 9")) 
&gt;
</pre>

<ul class="org-ul">
<li>begin
</li>
</ul>

<p>
The begin statement is used to execute multiple s-expressions.
</p>

<pre class="example">
(begin &lt;action1&gt; &lt;action2&gt; ...)


&gt; (begin 
  (display 10)
  (display "dummy")
  (newline))
10dummy
</pre>

<ul class="org-ul">
<li>quote or (') tick.
</li>
</ul>

<p>
Don't evaluate a lisp expression, returns the list of symbols, numbers and atoms that forms the list, or in other words, any lisp expression is just a list.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(quote <span class="org-type">&lt;expression&gt;</span>) Or '(<span class="org-type">&lt;epxression&gt;</span>)

&gt; '(exp 3.0)
$11 = (exp 3.0)

&gt; (quote (exp 3.0)) 
$12 = (exp 3.0)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">GNU Guile </span>
&gt; (eval '(exp 3.0) (interaction-environment))
$15 = 20.08553692318766

<span class="org-comment-delimiter">;;; </span><span class="org-comment">(eval (quote (exp 3.0)) (interaction-environment))</span>
$16 = 20.085536923187668

&gt; '(1 2 3 4 5)
$13 = (1 2 3 4 5)

&gt; (quote (1 2 3 4 5))
$14 = (1 2 3 4 5)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">However not all list can be evaluated</span>
&gt; (eval '(1 2 3 4 5) (interaction-environment))
ERROR: In procedure 1:
ERROR: Wrong type to apply: 1
</pre>
</div>

<p>
<b>Important Functions</b>
</p>

<ul class="org-ul">
<li>load 
</li>
</ul>

<p>
Load a scheme source code in the REPL.
</p>

<pre class="example">
(load "&lt;filename.scm&gt;")
(load "tools.scm")
</pre>

<ul class="org-ul">
<li>eval
</li>
</ul>

<p>
Eval evaluates a quoted lis expression, its arguments depends on the scheme implementation. It is better to use macros rather than eval. It is necessary to remember that "eval is evil" since it can allow untrusted code execute arbitrary commands so it must be used with care.
</p>

<p>
Note: In some scheme implementations [] square brackets can be used instead of parenthesis to make the code more readable.
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">(eval &lt;s-expression&gt; &lt;argument&gt;)</span>

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">MIT - Scheme</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">$ rlwrap -c --remember scheme</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">s</span> '((<span class="org-keyword">lambda</span> (x y) (+ (* 2 x) (* 3 y))) 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: s</span>

1 ]=&gt; s

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 17: ((lambda (x y) (+ (* 2 x) (* 3 y))) 3 4</span>

1 ]=&gt; (eval s (the-environment))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 18</span>

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">GNU Guile</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">$ rlwrap -c --remember guile</span>

&gt; [define s '([lambda (x y) (+ (* 2 x) (* 3 y))] 3 4)]
scheme@(guile-user)&gt; 

&gt; s
$1 = ((<span class="org-keyword">lambda</span> (x y) (+ (* 2 x) (* 3 y))) 3 4)

&gt; (eval s (interaction-environment))
$2 = 18

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Chicken Scheme</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">$ rlwrap -c --remember csi</span>

&gt; [define s '([lambda (x y) (+ (* 2 x) (* 3 y))] 3 4)]
&gt; s
((<span class="org-keyword">lambda</span> (x y) (+ (* 2 x) (* 3 y))) 3 4)
&gt; 

&gt; (eval s)
18


<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Kawa Scheme</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">$ rlwrap -c --remember java -jar kawa-2.0.jar </span>

    <span class="org-comment">#|kawa:6|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">s</span> '((<span class="org-keyword">lambda</span> (x y) (+ (* 2 x) (* 3 y))) 3 4))
    <span class="org-comment">#|kawa:7|#</span> s
    ((<span class="org-keyword">lambda</span> (x y) (+ (* 2 x) (* 3 y))) 3 4)
    <span class="org-comment">#|kawa:8|#</span> 

    <span class="org-comment">#|kawa:10|#</span> (eval s)
    18
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Data Types</h4>
<div class="outline-text-4" id="text-1-2-3">
</div><ol class="org-ol"><li><a id="sec-1-2-3-1" name="sec-1-2-3-1"></a>Basic Data Types<br  /><div class="outline-text-5" id="text-1-2-3-1">
<p>
<b>Booleans</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Boolean</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">---------------------------------</span>
1 ]=&gt; #f

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; #t

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>
</pre>
</div>

<p>
<b>Number</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; 12323

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 12323</span>

1 ]=&gt; 123.232

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 123.232</span>

<span class="org-comment-delimiter">;;;;; </span><span class="org-comment">Complex Number</span>

1 ]=&gt; 10+4i

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10+4i</span>

1 ]=&gt; (+ 10+4i 5-3i)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 15+i</span>

1 ]=&gt; (+ 10+4i 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 110+4i</span>

1 ]=&gt; (sqrt 10+4i)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 3.2226021794715067+.6206164734636876i</span>
</pre>
</div>

<p>
<b>String</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; <span class="org-string">"hello world scheme"</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 15: "hello world scheme"</span>
</pre>
</div>

<p>
<b>Characters</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; #\a
$93 = #\a

&gt; #\A
$94 = #\A
scheme@(guile-user) [20]&gt; 

&gt; #\(
$95 = #\(
scheme@(guile-user) [20]&gt; 

&gt; #\)
$96 = #\)
scheme@(guile-user) [20]&gt; 

&gt; #\space
$97 = #\space
scheme@(guile-user) [20]&gt; 

&gt; #\tab
$98 = #\tab
scheme@(guile-user) [20]&gt; 

&gt; #\return
$99 = #\return
scheme@(guile-user) [20]&gt;
</pre>
</div>

<p>
<b>Symbol</b>
</p>

<pre class="example">
1 ]=&gt; 'mysymbol

;Value: mysymbol

1 ]=&gt; (quote mysymbol)

;Value: mysymbol
</pre>

<p>
<b>List</b>
</p>

<p>
Scheme lists are linked lists with sequential access to any element.
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; '(23.23 1000 40 50 102)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 16: (23.23 1000 40 50 102</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">List of Strings</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">---------------------------------</span>
1 ]=&gt; '( <span class="org-string">"hello"</span> <span class="org-string">"world"</span> <span class="org-string">"scheme"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 17: ("hello" "world" "scheme")</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">List of Symbols</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">---------------------------------</span>
1 ]=&gt; '(hello world scheme)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 18: (hello world scheme)</span>

1 ]=&gt; (quote (hello world symbols))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 31: (hello world symbols)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">S-expression</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">---------------------------------</span>

1 ]=&gt; '(+ 10 2)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 19: (+ 10 2)</span>

1 ]=&gt; (quote (+ (sin 0.4) (cos 0.01)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 32: (+ (sin .4) (cos .01))</span>

1 ]=&gt; (quote (1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 33: (1 2 3 4 5 6)</span>
</pre>
</div>

<p>
<b>Vector</b>
</p>

<p>
Vectors are equivalent to C-arrays, are linear data structures of fixed size with random access to any element.
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; #(a b c d e)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: #(a b c d e)</span>

1 ]=&gt; (vector-ref #(a b c d e) 0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: a</span>

1 ]=&gt; (vector-ref #(a b c d e) 4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: e</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-3-2" name="sec-1-2-3-2"></a>Type Predicates<br  /><div class="outline-text-5" id="text-1-2-3-2">
<p>
Scheme is dynamic typed language therefore there is not guarantee about the variable type or the function type signature. The types can be checked with the following predicates.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Predicate</th>
<th scope="col" class="left">Returns true for</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">boolean?</td>
<td class="left">Boolean</td>
</tr>

<tr>
<td class="left">string?</td>
<td class="left">Strings</td>
</tr>

<tr>
<td class="left">number?</td>
<td class="left">Number, integer, real or complex numbers</td>
</tr>

<tr>
<td class="left">integer?</td>
<td class="left">Integer numbers</td>
</tr>

<tr>
<td class="left">real?</td>
<td class="left">Real numbers 2.232 1e3 100</td>
</tr>

<tr>
<td class="left">complex?</td>
<td class="left">Complex numbers 100+45i</td>
</tr>

<tr>
<td class="left">symbol?</td>
<td class="left">Symbols</td>
</tr>

<tr>
<td class="left">list?</td>
<td class="left">Lists</td>
</tr>

<tr>
<td class="left">vector?</td>
<td class="left">Vectors</td>
</tr>

<tr>
<td class="left">procedure?</td>
<td class="left">Procedure or function</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-scheme">(boolean? #f)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (boolean? 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


1 ]=&gt; (symbol? <span class="org-string">"x"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; (symbol? 'x)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>


1 ]=&gt; (integer? 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (integer? 3.232)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


1 ]=&gt; (real? 3232)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (real? 3232.232)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>


1 ]=&gt; (string? <span class="org-string">"hello world Scheme Lisp"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (string? 100232)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


1 ]=&gt; (list? '(1 2 3 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (list? 2323)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>



1 ]=&gt; (procedure? sin)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (procedure? 2323)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


(<span class="org-keyword">define</span> <span class="org-function-name">atom?</span>
  (<span class="org-keyword">lambda</span> (x)
   (<span class="org-keyword">and</span> (not (pair? x)) (not (null? x)))))
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-3-3" name="sec-1-2-3-3"></a>Type Conversion<br  /><div class="outline-text-5" id="text-1-2-3-3">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;</span><span class="org-comment">-------------------------------------;;</span>

1 ]=&gt; (string-&gt;number <span class="org-string">"20e3"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 20000.</span>

1 ]=&gt; (string-&gt;number <span class="org-string">"10.23"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10.23</span>

1 ]=&gt; 


1 ]=&gt; (number-&gt;string 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: "100"</span>

1 ]=&gt; (number-&gt;string -100.23e3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 12: "-100230."</span>

1 ]=&gt; 

<span class="org-comment-delimiter">;;</span><span class="org-comment">-------------------------------------;;</span>

1 ]=&gt; (symbol-&gt;string 'sin)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 13: "sin"</span>

1 ]=&gt; (string-&gt;symbol <span class="org-string">"my-symbol"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: my-symbol</span>


1 ]=&gt; (symbol-&gt;string 'some-symbol)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 14: "some-symbol"</span>

<span class="org-comment-delimiter">;;</span><span class="org-comment">-------------------------------------;;</span>
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Variables</h4>
<div class="outline-text-4" id="text-1-2-4">
</div><ol class="org-ol"><li><a id="sec-1-2-4-1" name="sec-1-2-4-1"></a>Global Variable<br  /><div class="outline-text-5" id="text-1-2-4-1">
<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">g</span> 9.81)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: g</span>

1 ]=&gt; g

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 9.81</span>

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">speed</span> v0 t) (+ (* g t) v0))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: speed</span>

1 ]=&gt; (speed 3 2.4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 26.544</span>
</pre>
</div>
</div>
</li>




<li><a id="sec-1-2-4-2" name="sec-1-2-4-2"></a>Local Variable<br  /><ol class="org-ol"><li><a id="sec-1-2-4-2-1" name="sec-1-2-4-2-1"></a>let<br  /><div class="outline-text-6" id="text-1-2-4-2-1">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">let</span> 
    (
     (x 10)
     (y 20)
     (f (<span class="org-keyword">lambda</span> (a) (* a 10)))
    )
    (f (+ x y))
)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 300</span>

1 ]=&gt; x
<span class="org-comment-delimiter">;</span><span class="org-comment">Unbound variable: x</span>

1 ]=&gt; y
<span class="org-comment-delimiter">;</span><span class="org-comment">Unbound variable: y</span>

1 ]=&gt; f
<span class="org-comment-delimiter">;</span><span class="org-comment">Unbound variable: f</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-4-2-2" name="sec-1-2-4-2-2"></a>let*<br  /><div class="outline-text-6" id="text-1-2-4-2-2">
<p>
The keyword let* is equivalent to a nested let.
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap -c --remember csi

CHICKEN
(c) 2008-2015, The CHICKEN Team
(c) 2000-2007, Felix L. Winkelmann
Version 4.10.0 (rev b259631)
linux-unix-gnu-x86 [ manyargs dload ptables ]
compiled 2015-08-04 on yves.more-magic.net (Linux)

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">This code won't work.</span>

    &gt; 
    (<span class="org-keyword">let</span> 
        (
         (x 10)
         (y (+ x 40))
         (z (* y x))
         (f (<span class="org-keyword">lambda</span> (a) (* a 3)))
        )
        (f (+ x y z))
    )

    Error: unbound variable: x

<span class="org-comment-delimiter">;;; </span><span class="org-comment">This code will, however there is a lot of boilerplate nesteds let</span>

    &gt; (<span class="org-keyword">let</span> ((x 10))
            (<span class="org-keyword">let</span> ((y (+ x 40)))
                 (<span class="org-keyword">let</span> (
                       (z (* y x))
                       (f (<span class="org-keyword">lambda</span> (a) (* a 3))))

                       (f (+ x y z)))))
    1680
    &gt; 

<span class="org-comment-delimiter">;;;;  </span><span class="org-comment">let*</span>


    &gt; (<span class="org-keyword">let*</span> 
        (
         (x 10)
         (y (+ x 40))
         (z (* y x))
         (f (<span class="org-keyword">lambda</span> (a) (* a 3)))
        )
        (f (+ x y z))
    )

    1680
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-4-2-3" name="sec-1-2-4-2-3"></a>letrec<br  /><div class="outline-text-6" id="text-1-2-4-2-3">
<p>
Letrec allows to implement loops or loops with recursive anonymous functions.
</p>

<p>
Example1: 
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">displayln</span> x)
  (<span class="org-keyword">begin</span>
    (display x)
    (display <span class="org-string">"\n"</span>)))

(<span class="org-keyword">letrec</span>
    [(loop  (<span class="org-keyword">lambda</span> (i)
              (<span class="org-keyword">if</span> (&lt; i 10)
                  (<span class="org-keyword">begin</span>
                    (displayln i)
                    (loop (+ i 1))))))]
  (loop 0))
0
1
2
3
4
5
6
7
8
9


&gt; loop
Error: unbound variable: loop
</pre>
</div>

<p>
Example2: Loop over a list and find the sum of all elements:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">alist</span> '(1 2 3 4 5 6))


(<span class="org-keyword">letrec</span>
    [(loop (<span class="org-keyword">lambda</span> (xs)
             (<span class="org-keyword">if</span> (null? xs)
                 0
                 (+ (car xs) (loop (cdr xs))))))]
  (loop alist))
21
</pre>
</div>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> Functions</h4>
<div class="outline-text-4" id="text-1-2-5">
</div><ol class="org-ol"><li><a id="sec-1-2-5-1" name="sec-1-2-5-1"></a>Defining and applying functions<br  /><div class="outline-text-5" id="text-1-2-5-1">
<p>
In Scheme functions are first class, they can be passed as arguments
to other functions and be returned from another functions, in other
words, functions are data.
</p>

<div class="org-src-container">

<pre class="src src-scheme">]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x) (* x 10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

]=&gt; f

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: #[compound-procedure 11 f]</span>

]=&gt; (f 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 100</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Map a function over a list</span>
<span class="org-comment-delimiter">;;;; </span>
]=&gt; (<span class="org-keyword">map</span> f '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 12: (10 20 30 40 50 60)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Define a function of multiple variables</span>
<span class="org-comment-delimiter">;;;;;</span>

]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">fxy</span> x y) (+ (* 4 x) (* 3 y)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: fxy</span>

]=&gt; (fxy 3 5)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 27</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Map a fucntion multiple variables over alist</span>
<span class="org-comment-delimiter">;;;;</span>
]=&gt; (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (y) (fxy 3 y)) '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 14: (15 18 21 24 27 30)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Apply a list as function argument</span>
<span class="org-comment-delimiter">;;;;;</span>
1 ]=&gt; (apply fxy '( 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 38</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Transforms a function f into a new function that accepts</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">a list of arguments</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;;;;;;</span>
1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">currify</span> f) (<span class="org-keyword">lambda</span> (x) (apply f x)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: currify</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">fxy_c</span> (currify fxy))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: fxy_c</span>

1 ]=&gt; (fxy_c '( 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 24</span>

1 ]=&gt; (fxy_c '( 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 38</span>

1 ]=&gt; 

1 ]=&gt; (<span class="org-keyword">map</span> fxy_c (list '(5 6) '(3 7) '(8 9) '( 1 5)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 29: (38 33 59 19)</span>

  <span class="org-comment-delimiter">;;; </span><span class="org-comment">OR</span>

1 ]=&gt; (<span class="org-keyword">map</span> (currify fxy)  (list '(5 6) '(3 7) '(8 9) '( 1 5)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 30: (38 33 59 19)</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-2" name="sec-1-2-5-2"></a>Anonymous Functions/ Lambda Functions<br  /><div class="outline-text-5" id="text-1-2-5-2">
<p>
Anonymous functions are useful to pass functions as arguments to other
functions, callbacks and connect one function to another.
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (<span class="org-keyword">lambda</span> (x) (+ (* x 4) 10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 31: #[compound-procedure 31]</span>

1 ]=&gt; ((<span class="org-keyword">lambda</span> (x) (+ (* x 4) 10))  10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 50</span>

1 ]=&gt; (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (+ (* x 4) 10))  '(10 20 30 40 50))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 32: (50 90 130 170 210)</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">f</span> (<span class="org-keyword">lambda</span> (x) (+ (* x 4) 10)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

1 ]=&gt; f

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 33: #[compound-procedure 33 f]</span>

1 ]=&gt; (<span class="org-keyword">map</span> f '(10 20 30 40 50))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 34: (50 90 130 170 210)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Scheme is a Functional Programming Language,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">so it can return functions from functions that</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">can be used to define curried functions</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">addxy</span> x y) (<span class="org-keyword">lambda</span> (x) (<span class="org-keyword">lambda</span> (y) (+ x y))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: addxy</span>

1 ]=&gt; ((addxy 10) 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 30</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">add10</span> (addxy 10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: add10</span>

1 ]=&gt; (add10 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 30</span>

1 ]=&gt; 


1 ]=&gt; (<span class="org-keyword">map</span> (addxy 10) '(10 20 30 40 50 60))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 37: (20 30 40 50 60 70)</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-3" name="sec-1-2-5-3"></a>Functions with Control Structure<br  /><div class="outline-text-5" id="text-1-2-5-3">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">sign</span> x)
    (<span class="org-keyword">cond</span> 
        ((&gt; x 0)  1)
        ((= x 0)  0)
        ((&lt; x 0) -1)
))


1 ]=&gt; (sign -10)
$49 = -1
1 ]=&gt; (sign 100)
$50 = 1
1 ]=&gt; (sign 0)
$51 = 0


(<span class="org-keyword">define</span> (<span class="org-function-name">absolute</span> x)
    (<span class="org-keyword">cond</span> 
        ((&gt;= x 0)     x)
        ((&lt;  x 0) (- x))
))

1 ]=&gt; (absolute -10)
$52 = 10
1 ]=&gt; (absolute 10)
$53 = 10
1 ]=&gt; (absolute 0)
$54 = 0


(<span class="org-keyword">define</span> (<span class="org-function-name">absolute2</span> x)
    (<span class="org-keyword">cond</span> 
        ((&gt; x 0) x    )
        (<span class="org-keyword">else</span>    (- x))
))

1 ]=&gt; (<span class="org-keyword">map</span> absolute2 '(-10 -9 0 1 2 3))
$57 = (10 9 0 1 2 3)
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-4" name="sec-1-2-5-4"></a>Variadic Function<br  /><div class="outline-text-5" id="text-1-2-5-4">
<p>
Function of many arguments
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">variadic-fun</span> . args) args)

1 ]=&gt; (variadic-fun  10 20 30 40 50 100)
$55 = (10 20 30 40 50 100)

(<span class="org-keyword">define</span> (<span class="org-function-name">variadic2</span> . args)
    (- (apply * args) (apply + args)))

<span class="org-comment-delimiter">;;  </span><span class="org-comment">(- (* 10 20 30) (+ 10 20 30))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(- 6000 60)</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">5940</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (variadic2 10 20 30)
$56 = 5940
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-5" name="sec-1-2-5-5"></a>Recursive Functions<br  /><div class="outline-text-5" id="text-1-2-5-5">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">fib</span> n)
    (<span class="org-keyword">cond</span> 
        ((= n 0) 1)
        ((= n 1) 1)
        (<span class="org-keyword">else</span>    (+ (fib (- n 1))  (fib (- n 2))))))

scheme@(guile-user)&gt; (fib 1)
$6 = 1
scheme@(guile-user)&gt; (fib 5)
$7 = 8
scheme@(guile-user)&gt; (fib 15)
$8 = 987
scheme@(guile-user)&gt; (fib 20)
$9 = 10946
scheme@(guile-user)&gt; (fib 30)
$10 = 1346269


(<span class="org-keyword">define</span> (<span class="org-function-name">fib-aux</span> n a b)
  (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (= n 0) (= n 1))
      b
      (fib-aux (- n 1) b (+ a b))))

(<span class="org-keyword">define</span> (<span class="org-function-name">fib-fast</span> n) (fib-aux n 1 1))

&gt; (fib-aux 30 1 1)
$4 = 1346269
&gt; (fib-aux 40 1 1)
$5 = 165580141
&gt; (fib-aux 100 1 1)
$6 = 573147844013817084101

&gt; (fib-fast 30)
$9 = 1346269
&gt; (fib-fast 130)
$10 = 1066340417491710595814572169
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-6" name="sec-1-2-5-6"></a>Internal Definition<br  /><div class="outline-text-5" id="text-1-2-5-6">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y)
    (<span class="org-keyword">define</span> <span class="org-function-name">a</span> 10)
    (<span class="org-keyword">define</span> (<span class="org-function-name">f1</span> x) (+ (* x 2) 4))
    (<span class="org-keyword">define</span> (<span class="org-function-name">f2</span> i) (+ i 1))
    (+ (f1 x) (f2 y) a))

<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(+ (f1 3) (f2 4) 10))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(+ (+ (* 3 2) 4)))   (+ 4 1) 10)</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(+ 10 5 10) </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">25</span>
<span class="org-comment-delimiter">;;</span>
scheme@(guile-user) [2]&gt; (f 3 4)
$12 = 25

scheme@(guile-user) [2]&gt; (f 2 3)
$13 = 22


scheme@(guile-user) [4]&gt; f1
<span class="org-comment-delimiter">;;; </span><span class="org-comment">&lt;unknown-location&gt;: warning: possibly unbound variable `f1'</span>

scheme@(guile-user) [2]&gt; a
<span class="org-comment-delimiter">;;; </span><span class="org-comment">&lt;unknown-location&gt;:</span>

scheme@(guile-user) [3]&gt; f2
<span class="org-comment-delimiter">;;; </span><span class="org-comment">&lt;unknown-location&gt;: warning: possibly unbound variable `f2'</span>
</pre>
</div>
</div>
</li>


<li><a id="sec-1-2-5-7" name="sec-1-2-5-7"></a>Arithmetic<br  /><div class="outline-text-5" id="text-1-2-5-7">
<p>
The Scheme operators are functions of two arguments and are written in the infix notation, also known as <a href="https://en.wikipedia.org/wiki/Polish_notation">polish notation</a>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap scheme
MIT/GNU Scheme running under GNU/Linux
Type `^C' (control-C) followed by `H' to obtain information about interrupts.

Copyright (C) 2011 Massachusetts Institute of Technology
This is free software<span class="org-comment-delimiter">; </span><span class="org-comment">see the source for copying conditions. There is NO</span>
warranty<span class="org-comment-delimiter">; </span><span class="org-comment">not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>

Image saved on Tuesday October 22, 2013 at 12:31:09 PM
  Release 9.1.1 <span class="org-string">||</span> Microcode 15.3 <span class="org-string">||</span> Runtime 15.7 <span class="org-string">||</span> SF 4.41 <span class="org-string">||</span> LIAR/i386 4.118
  Edwin 3.116

]=&gt; 

]=&gt; (+ 10 20 )

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 30</span>

]=&gt; (+ 1 2 3 4 5 6)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 21</span>

]=&gt; (* 3 5)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 15</span>

]=&gt; (* 1 2 3 4 5 6)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 720</span>

]=&gt; (/ 10 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1/2</span>

]=&gt; (/ 10.0 20.0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .5</span>

1 ]=&gt; (/ 29 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 29/3</span>

1 ]=&gt; (/ 29 3 7)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 29/21</span>

1 ]=&gt; (/ 29 3 7 2)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 29/42</span>

1 ]=&gt; (exact-&gt;inexact (/ 29 3 7 2))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .6904761904761905</span>


<span class="org-comment-delimiter">;;; </span><span class="org-comment">10 - 20</span>
]=&gt; (- 10 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: -10</span>

]=&gt; 

<span class="org-comment-delimiter">;;; </span><span class="org-comment">3 * 4 + 8 / 4 + (-3) * 5</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (+ (* 3 4) (/ 8 4) (* -3 5))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: -1</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-8" name="sec-1-2-5-8"></a>Comparison<br  /><div class="outline-text-5" id="text-1-2-5-8">
<p>
<b>Equality Operators</b>
</p>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Operator</th>
<th scope="col" class="left">Description</th>
<th scope="col" class="left">Use</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">=</td>
<td class="left">Numerical Equality</td>
<td class="left">(= 10 10)</td>
</tr>

<tr>
<td class="left">eqv?</td>
<td class="left">Test if non numeric values are equal</td>
<td class="left">(= 'sym1 'sym1)</td>
</tr>

<tr>
<td class="left">eq?</td>
<td class="left">Check if the two objects represents the same location in memory</td>
<td class="left">The return value depends on implementation.</td>
</tr>

<tr>
<td class="left">equal?</td>
<td class="left">Structural Equality</td>
<td class="left">(= (list 'a 'b 10) (list 'a 'b 10))</td>
</tr>
</tbody>
</table>



<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap -c --remember csi

CHICKEN
(c) 2008-2015, The CHICKEN Team
(c) 2000-2007, Felix L. Winkelmann
Version 4.10.0 (rev b259631)
linux-unix-gnu-x86 [ manyargs dload ptables ]
compiled 2015-08-04 on yves.more-magic.net (Linux)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Numerical Equality</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">--------------------------------</span>

    &gt; (= 'symbol1 'symbol2)

    Error: (=) bad argument type: symbol1


    (= 100 100)
    #t
    &gt; 
    (= 10 1)
    #f
    &gt; 

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">eq?</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">Cannot compare lists and strings</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">--------------------------------</span>

    &gt; (eq? 'a-symbol 'a-symbol)
    #t
    &gt; (eq? 'a-symbol 'a-symb)
    #f
    &gt; 

    &gt; (eq? 10 10)
    #t
    &gt; (eq? 10 10.0)
    #f

    &gt; (eq? 10.0 10.0)
    #f
    &gt; 

    &gt; (eq? 10 <span class="org-string">"hello"</span>)

    &gt; (eq? <span class="org-string">"hello"</span> <span class="org-string">"hello"</span>)
    #f
    &gt; 

    &gt; (eq? (list 1 <span class="org-string">"string"</span> 'symbol1) (list 1 <span class="org-string">"string"</span> 'symbol1))
    #f
    &gt; 

    &gt; (eq? '() '())
    #t
    &gt; 

<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">eqv?</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">It is preferable to use eqv? instead of eq?</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">-------------------------------</span>

    &gt; (eqv? 'symbol1 'symbol1)
    #t
    &gt; 

    &gt; (eqv? 10.0 10.0)
    #t
    &gt; 

    &gt; (eqv? '() '())
    #t
    &gt; 

    &gt; (eqv? <span class="org-string">"hello"</span> <span class="org-string">"hello"</span>)
    #f
    &gt; 

    &gt; (eqv? (list 1 <span class="org-string">"string"</span> 'symbol1) (list 1 <span class="org-string">"string"</span> 'symbol1))
    #f
    &gt; 

<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">equal?</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Structural equality.</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">-------------------------------</span>

    (= (list 1 <span class="org-string">"string"</span> 'symbol1) (list <span class="org-string">"string"</span> 'symbol1))

    Error: (=) bad argument type: (1 <span class="org-string">"string"</span> symbol1)

    <span class="org-comment-delimiter">;; </span><span class="org-comment">Recursively compare every element of a list </span>
    <span class="org-comment-delimiter">;;</span>
    &gt; (equal? (list 1 <span class="org-string">"string"</span> 'symbol1) (list 1 <span class="org-string">"string"</span> 'symbol1))
    #t
    &gt; 

    &gt; (equal? <span class="org-string">"hello"</span> <span class="org-string">"hello"</span>)
    #t
    &gt;
</pre>
</div>


<p>
<b>Comparison Operators</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Comparison Operators</span>

]=&gt; (&gt; 10 200)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

]=&gt; (= 10 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

]=&gt; (&lt; 10 200)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

]=&gt; 

]=&gt; (&lt;= 10 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

]=&gt; (&gt;= 10 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

]=&gt; (&gt;= 10 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

]=&gt;
</pre>
</div>

<p>
<b>Logical Operators</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (not #t)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; (not #f)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt;     

1 ]=&gt; (<span class="org-keyword">and</span> #f #t)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; (<span class="org-keyword">and</span> #t #t)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (<span class="org-keyword">or</span> #t #t)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (<span class="org-keyword">or</span> #t #f)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-9" name="sec-1-2-5-9"></a>Math Functions<br  /><div class="outline-text-5" id="text-1-2-5-9">
<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (sqrt 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 3.1622776601683795</span>

1 ]=&gt; (sqrt 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; (<span class="org-keyword">map</span> sqrt '(4 9 16 25 36))
$44 = (2.0000000929222947 3.00009155413138 4.000000636692939 5.000023178253949 6.000000005333189)


<span class="org-comment-delimiter">;;</span><span class="org-comment">========================================</span>

<span class="org-comment-delimiter">;;;  </span><span class="org-comment">x ^ y</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (expt 2 2)
$40 = 4
1 ]=&gt; (expt 2 3)
$41 = 8

(<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (expt 2 x)) '(2 3 4 5 6 7 8))
$42 = (4 8 16 32 64 128 256)

<span class="org-comment-delimiter">;;</span><span class="org-comment">========================================</span>

1 ]=&gt; (exp 1.0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2.718281828459045</span>

1 ]=&gt; (<span class="org-keyword">map</span> exp '(-2 -1 0 1 2 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 20: (.1353352832366127 .36787944117144233 1 2.718281828459045 7.38905609893065 20.08553692318767)</span>

1 ]=&gt; (log 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2.302585092994046</span>

1 ]=&gt; (log (exp 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1.</span>


1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">logbase</span> base) (<span class="org-keyword">lambda</span> (x) (/ (log x) (log base))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: logbase</span>

1 ]=&gt; (logbase 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: #[compound-procedure 21]</span>

1 ]=&gt; ((logbase 10) 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1.</span>

1 ]=&gt; ((logbase 10) 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2.</span>

1 ]=&gt; 

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">log10</span> (logbase 10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: log10</span>

1 ]=&gt; (log10 1000)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2.9999999999999996</span>

1 ]=&gt; (<span class="org-keyword">map</span> log10 '(0.01 1.0 10.0 100.0))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 22: (-1.9999999999999996 0. 1. 2.)</span>



<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="org-comment-delimiter">;;; </span><span class="org-comment">Trigonometric Functions</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Create PI constant</span>
1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">pi</span> (* 4 (atan 1.0)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: pi</span>

1 ]=&gt; pi

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 3.141592653589793</span>


1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">rad2deg</span> rad) (* (/ rad pi) 180))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: rad2deg</span>

1 ]=&gt; (rad2deg pi)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 180.</span>

1 ]=&gt; 

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">deg2rad</span> deg) (* (/ deg 180) pi))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: deg2rad</span>

1 ]=&gt; (deg2rad 180)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 3.141592653589793</span>


<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">Transforms a function that accepts angle in radians to a function</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">that accepts a angle in degrees</span>

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">make-deg-func</span> func) (<span class="org-keyword">lambda</span> (deg) (func (deg2rad deg))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: make-deg-func</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">sind</span> (make-deg-func sin))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: sind</span>

1 ]=&gt; (sind 60)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .8660254037844386</span>

1 ]=&gt; (sind 30)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .49999999999999994</span>

1 ]=&gt; (sind 90)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1.</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">cosd</span> (make-deg-func cos))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: cosd</span>

1 ]=&gt; (<span class="org-keyword">map</span> cosd '(0 30 60 90 180))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 23: (1 .8660254037844387 .5000000000000001 6.123233995736766e-17 -1.)</span>



<span class="org-comment-delimiter">;;; </span><span class="org-comment">Inverse Trigonometric Functions</span>

1 ]=&gt; (asin 0.5)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .523598775598298</span>

1 ]=&gt; (atan 1)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .7853981633974483</span>

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">make-inv-deg-func</span> func) (<span class="org-keyword">lambda</span> (x) (rad2deg (func x))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: make-inv-deg-func</span>

1 ]=&gt; ((make-inv-deg-func atan) 1)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 45.</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">atand</span> (make-inv-deg-func atan))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: atand</span>

1 ]=&gt; (atand 1.0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 45.</span>

1 ]=&gt; (<span class="org-keyword">map</span> atand '(0.0 0.5 1.0 2.0 1e10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 26: (0. 26.565051177077986 45. 63.43494882292201 89.99999999427042)</span>

<span class="org-comment-delimiter">;;</span><span class="org-comment">==================================;;</span>

1 ]=&gt;  (abs -10)
$46 = 10
1 ]=&gt;  (abs 100)
$47 = 100
1 ]=&gt;  (abs 0)
$48 = 0
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-5-10" name="sec-1-2-5-10"></a>String Functions<br  /><div class="outline-text-5" id="text-1-2-5-10">
<p>
<b>Predicates</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;;; </span><span class="org-comment">Test if is String</span>

1 ]=&gt; (string? <span class="org-string">"scheme"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (string? 1000)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Test is String is null, empty</span>

1 ]=&gt; (string-null? <span class="org-string">""</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (string-null? <span class="org-string">"scheme"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Test if String starts with prefix</span>

1 ]=&gt; (string-prefix?  <span class="org-string">"example"</span> <span class="org-string">"example-11232.x"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (string-prefix?  <span class="org-string">"example"</span> <span class="org-string">"11232.x"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Test if String ends with suffix</span>

1 ]=&gt; (string-suffix? <span class="org-string">"class"</span> <span class="org-string">"machine.class"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

1 ]=&gt; (string-suffix? <span class="org-string">"class"</span> <span class="org-string">"machine.dex"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>
</pre>
</div>

<p>
<b>Misc</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;;; </span><span class="org-comment">String Construction</span>

1 ]=&gt; (make-string 10 #\x)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: "xxxxxxxxxx"</span>

1 ]=&gt; (make-string 20 #\a)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 22: "aaaaaaaaaaaaaaaaaaaa</span>

1 ]=&gt; (string #\s #\c #\h #\e #\m #\e)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 23: "scheme"</span>

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Length of a String</span>

1 ]=&gt; (string-length <span class="org-string">"1234567890"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Trim String</span>

1 ]=&gt; (string-trim <span class="org-string">" \n\nlisp\n scheme    \n\n"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 18: "lisp\n scheme"</span>

1 ]=&gt; (string-trim-left <span class="org-string">" \n\nlisp\n scheme    \n\n"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 19: "lisp\n scheme    \n\n"</span>

1 ]=&gt; (string-trim-right <span class="org-string">" \n\nlisp\n scheme    \n\n"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 20: " \n\nlisp\n scheme"</span>

1 ]=&gt; 

<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Append Strings</span>

1 ]=&gt; (string-append <span class="org-string">"hello "</span> <span class="org-string">"world"</span> <span class="org-string">"  scheme"</span> <span class="org-string">" lisp "</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 25: "hello world  scheme lisp "</span>


<span class="org-comment-delimiter">;;; </span><span class="org-comment">Split String </span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Not defined in MIT-Scheme, but defined in </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Chicken Scheme (csi Repl), GNU Guile and others.</span>
<span class="org-comment-delimiter">;;</span>
&gt; (string-split <span class="org-string">"hello world"</span>)
(<span class="org-string">"hello"</span> <span class="org-string">"world"</span>)

&gt; (string-split <span class="org-string">"hello:world"</span>  <span class="org-string">":"</span>)
(<span class="org-string">"hello"</span> <span class="org-string">"world"</span>)
</pre>
</div>

<p>
<b>To String</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (number-&gt;string 12.323)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: "12.323"</span>

1 ]=&gt; (symbol-&gt;string 'asymbol)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 12: "asymbol"</span>

1 ]=&gt; 

1 ]=&gt; (list-&gt;string '(#\h #\e #\l #\l #\o #\space #\w #\o #\r #\l #\d))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 16: "hello world"</span>
</pre>
</div>

<p>
<b>From String</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (string-&gt;number <span class="org-string">"222.23"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 222.23</span>

1 ]=&gt; (string-&gt;symbol  <span class="org-string">"asymbol"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: asymbol</span>


<span class="org-comment-delimiter">;;; </span><span class="org-comment">To list of characters</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (string-&gt;list <span class="org-string">"hello world"</span>)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 15: (#\h #\e #\l #\l #\o #\space #\w #\o #\r #\l #\d)</span>

1 ]=&gt; (char-&gt;integer #\x)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 120</span>

1 ]=&gt; (<span class="org-keyword">map</span> char-&gt;integer (string-&gt;list <span class="org-string">"lisp"</span>))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 28: (108 105 115 112)</span>
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> List Operations</h4>
<div class="outline-text-4" id="text-1-2-6">
</div><ol class="org-ol"><li><a id="sec-1-2-6-1" name="sec-1-2-6-1"></a>Defining a List<br  /><div class="outline-text-5" id="text-1-2-6-1">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">A scheme list can hold arbitrary values</span>

&gt; '(1 2.23 1e3 hello world lisp (2 5 <span class="org-string">"a string"</span>))
$55 = (1 2.23 1000.0 hello world lisp (2 5 <span class="org-string">"a string"</span>))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">List of Symbols</span>

&gt; '(a b c d e)
$56 = (a b c d e)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">List with values</span>

(<span class="org-keyword">define</span> <span class="org-function-name">x</span> 1)
(<span class="org-keyword">define</span> <span class="org-function-name">y</span> 2)
(<span class="org-keyword">define</span> <span class="org-function-name">z</span> 10)
(<span class="org-keyword">define</span> <span class="org-function-name">w</span> 'a-symbol)
(<span class="org-keyword">define</span> <span class="org-function-name">z</span> 'theta)

&gt; (list x y z w)
$61 = (1 2 theta a-symbol)

(list 'x x 'y y 'z z 'w w)
$62 = (x 1 y 2 z theta w a-symbol)

&gt; (list (cons 'x x) (cons 'y y) (cons 'z z))
$66 = ((x . 1) (y . 2) (z . theta))
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-6-2" name="sec-1-2-6-2"></a>Quasiquote<br  /><div class="outline-text-5" id="text-1-2-6-2">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="org-comment-delimiter">;;; </span><span class="org-comment">Lists with Quasiquotes</span>

&gt; `(the product of 3 and 4 is ,(* 3 4))
$106 = (the product of 3 and 4 is 12)

&gt; `(<span class="org-string">"the product of 3 and 4 is"</span> ,(* 3 4))
$107 = (<span class="org-string">"the product of 3 and 4 is"</span> 12)

(<span class="org-keyword">define</span> <span class="org-function-name">xs</span> '(1 2 3))
(<span class="org-keyword">define</span> <span class="org-function-name">ys</span> '(a b c))

&gt; `(x ,x y ,y z ,z)
$69 = (x 1 y 2 z theta)

&gt; `( (x ,x) (y ,y) (z ,z))
$71 = ((x 1) (y 2) (z theta))

&gt; `( (x ,x) (y ,y) (z ,z) ,@xs)
$72 = ((x 1) (y 2) (z theta) 1 2 3)

&gt; `( (x ,x) (y ,y) (z ,z) ,@xs ,@ys)
$73 = ((x 1) (y 2) (z theta) 1 2 3 a b c)

&gt; `( (x ,x) (y ,y) (z ,z) (xs ,@xs) (ys ,@ys))
$74 = ((x 1) (y 2) (z theta) (xs 1 2 3) (ys a b c))

&gt; `( (x ,x) (y ,y) (z ,z) (xs ,xs) (ys ,ys))
$92 = ((x 1) (y 2) (z theta) (xs (1 2 3)) (ys (a b c)))


&gt; `(x ,x y ,y ,(<span class="org-keyword">if</span> (&gt; 2 x) w z))
$77 = (x 1 y 2 a-symbol)

&gt; `(x ,x y ,y ,(<span class="org-keyword">if</span> (&lt; 2 x) w z))
$78 = (x 1 y 2 theta)

&gt; `(x ,x y ,y ,(<span class="org-keyword">if</span> (&lt; 2 x) `(w ,w) `(z ,z)))
$79 = (x 1 y 2 (z theta))


&gt; `(x ,x y ,y ,(<span class="org-keyword">if</span> (&gt; 5 x) `(w ,w) `(z ,z)))
$80 = (x 1 y 2 (w a-symbol))

&gt; `(x ,x y ,y (<span class="org-keyword">if</span> (&gt; 5 x) (w ,w) (z ,z)))
$82 = (x 1 y 2 (<span class="org-keyword">if</span> (&gt; 5 x) (w a-symbol) (z theta)))


(list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3))
$83 = ((f1 . #&lt;procedure f1 (x)&gt;) (f2 . #&lt;procedure f2 (x)&gt;) (f3 . #&lt;procedure f3 (x)&gt;))

<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="org-comment-delimiter">;;;  </span><span class="org-comment">List of functions</span>
<span class="org-comment-delimiter">;;;</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">f1</span> x) (* 2 x))
(<span class="org-keyword">define</span> (<span class="org-function-name">f2</span> x) (+ x 5))
(<span class="org-keyword">define</span> (<span class="org-function-name">f3</span> x) (+ 2 (* 6 x)))

(<span class="org-keyword">define</span> (<span class="org-function-name">call-with</span> x) (<span class="org-keyword">lambda</span> (f) (f x)))


&gt; (list f1 f2 f3)
$64 = (#&lt;procedure f1 (x)&gt; #&lt;procedure f2 (x)&gt; #&lt;procedure f3 (x)&gt;)

&gt; (<span class="org-keyword">map</span> (call-with 5) (list f1 f2 f3))
$65 = (10 10 32)

&gt; (list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3))
$83 = ((f1 . #&lt;procedure f1 (x)&gt;) (f2 . #&lt;procedure f2 (x)&gt;) (f3 . #&lt;procedure f3 (x)&gt;))

&gt; (cdr (assoc 'f1 (list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3))))
$85 = #&lt;procedure f1 (x)

&gt; (cdr (assoc 'f2 (list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3))))
$86 = #&lt;procedure f2 (x)&gt;

&gt; ((cdr (assoc 'f2 (list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3)))) 10)
$88 = 15

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">f-dispatch</span> key arg)
    ((cdr (assoc key  (list (cons 'f1 f1) (cons 'f2 f2) (cons 'f3 f3)))) arg))

&gt; (f-dispatch 'f1 5)
$89 = 10

&gt; (f-dispatch 'f2 5)
$90 = 10

&gt; (f-dispatch 'f3 5)
$91 = 32


<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Lisp programs are list of symbols numbers and strings</span>
<span class="org-comment-delimiter">;; </span>

&gt; '(+ 1 2 3 4 5)
$75 = (+ 1 2 3 4 5)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">GNU Guile</span>
<span class="org-comment-delimiter">;;</span>
&gt; (eval '(+ 1 2 3 4 5) (interaction-environment))
$76 = 15
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-6-3" name="sec-1-2-6-3"></a>Primitive List Operations<br  /><div class="outline-text-5" id="text-1-2-6-3">
<ul class="org-ul">
<li><b>Nil</b> - Empty List '()
</li>

<li><b>Cons</b> - List constructor, Construct a list cell 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (<span class="org-keyword">define</span> <span class="org-function-name">Nil</span> '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: nil</span>

&gt; Nil

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

&gt; (Cons 5 Nil)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 19: (5)</span>

&gt; (Cons 5 (Cons 6 Nil))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 20: (5 6)</span>

&gt; (Cons 4 (Cons 5 (Cons 6 Nil)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: (4 5 6)</span>
</pre>
</div>

<ul class="org-ul">
<li><b>car</b> - It selects the first element, "head" of a list cell
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (car (list 1 2 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1</span>

&gt; (car '(2 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2</span>

&gt; (car '(x y z))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: x</span>
</pre>
</div>

<ul class="org-ul">
<li><b>cdr</b> - It selects the "tail" of a list, removes the first element
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (cdr (list 1 2 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 17: (2 3 4)</span>

&gt; (cdr '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 18: (y z w)</span>
</pre>
</div>

<ul class="org-ul">
<li><b>caddr</b> - It gets the second element of a list
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (cadr '(a b c d e f))
$14 = b
&gt;
</pre>
</div>

<ul class="org-ul">
<li><b>caddr</b> - It gets the third element of a list 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (caddr '(a b c d e f))
$16 = c
</pre>
</div>

<ul class="org-ul">
<li><b>cadddr</b> - It gets the forth element of alist.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (cadddr '(a b c d e f))
$17 = d
</pre>
</div>

<ul class="org-ul">
<li><b>cddr</b> - Removes the first two elements of a list.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (cddr '(a b c d e f))
$3 = (c d e f)
</pre>
</div>

<ul class="org-ul">
<li><b>cdddr</b> - Removes the first three elements of a list.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (cadddr '(a b c d e f))
$4 = d
</pre>
</div>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Function</th>
<th scope="col" class="left">Output</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>(car       '[a b c)</code></td>
<td class="left">a</td>
<td class="left">First element</td>
</tr>

<tr>
<td class="left"><code>(cadr     '[a b c d e f])</code></td>
<td class="left">b</td>
<td class="left">Second element</td>
</tr>

<tr>
<td class="left"><code>(caddr    '[a b c d e f])</code></td>
<td class="left">c</td>
<td class="left">Third element</td>
</tr>

<tr>
<td class="left"><code>(cadddr   '[a b c d e f])</code></td>
<td class="left">d</td>
<td class="left">Forth element</td>
</tr>

<tr>
<td class="left"><code>(caddddr  '[a b c d e f])</code></td>
<td class="left">e</td>
<td class="left">Fifth element</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>(cdr     '[a b c e f)</code></td>
<td class="left">='(b c e f)=</td>
<td class="left">Remove first, tail</td>
</tr>

<tr>
<td class="left"><code>(cddr    '[a b c e f)</code></td>
<td class="left">='(c e f)=</td>
<td class="left">Remove first two elements</td>
</tr>

<tr>
<td class="left"><code>(cdddr   '[a b c e f)</code></td>
<td class="left">='(e f)=</td>
<td class="left">Remove first three elements</td>
</tr>

<tr>
<td class="left"><code>(cddddr  '[a b c e f)</code></td>
<td class="left">='(f)=</td>
<td class="left">Remove first four elements</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="sec-1-2-6-4" name="sec-1-2-6-4"></a>Basic List Functions<br  /><div class="outline-text-5" id="text-1-2-6-4">
<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (length '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 6</span>

1 ]=&gt; (reverse '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 27: (6 5 4 3 2 1)</span>

1 ]=&gt; (append '(1 2 3 4) '(5 6 7) '(8 9 10)) 

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 28: (1 2 3 4 5 6 7 8 9 10)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Test if list is empty </span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (null? '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; (null? '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Test if a value is member of a list</span>

1 ]=&gt; (member 'y '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 24: (y z w)</span>

1 ]=&gt; (member 'a '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>

1 ]=&gt; (member 'x '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 25: (x y z w)</span>

1 ]=&gt; (member 'k '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #f</span>


<span class="org-comment-delimiter">;;;; </span><span class="org-comment">Reverse a list</span>

1 ]=&gt; (reverse '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 26: (w z y x</span>


<span class="org-comment-delimiter">;;; </span><span class="org-comment">First and Last Element</span>

1 ]=&gt; (first '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: x</span>

1 ]=&gt; (last '(x y z w))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: w</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Pick the nth element of a list</span>

1 ]=&gt; (list-ref '(x y z w) 0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: x</span>

1 ]=&gt; (list-ref '(x y z w) 1)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: y</span>

1 ]=&gt; (list-ref '(x y z w) 2)
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Higher Order Functions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
All the functions defined are in the file:
<i>hof_functions.scm</i> that can be loaded in
scheme by typing:
</p>

<pre class="example">
$ curl -O https://raw.githubusercontent.com/caiorss/Functional-Programming/master/scheme/src/hof_functions.scm

$ rlwrap -c --remember scheme

1 ]=&gt;   (load "hof_functions.scm")
</pre>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Buit-in Functions</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Fundamental higher order functions defined in Scheme.
</p>

<ul class="org-ul">
<li><b>map</b>
</li>
</ul>

<pre class="example">
&gt; (map [lambda (x) (+ x 4)] '(1 2 3 4 5 6))
(5 6 7 8 9 10)

&gt; (map [lambda (x y) (+ x y)] '(1 2 3 4)  '(2 3 4 5))
(3 5 7 9)

&gt; (map [lambda (x y z) (+ x y z)] '(1 2 3 4)  '(2 3 4 5) '(9 18 10 20))
(12 23 17 29)
 

&gt; (define (hypot a b) [sqrt (+ (* a a) (* b b))])


&gt; (hypot 4 3)
5.0

&gt; (map hypot '(1 3 4) '(2 6 8))
(2.23606797749979 6.70820393249937 8.94427190999916)
</pre>

<ul class="org-ul">
<li><b>for-each</b>
</li>
</ul>

<p>
Similar to map, however it used for functions with side effects.
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Using map</span>

(<span class="org-keyword">map</span> [lambda (x) (display x) (newline)]  '(1 2 3 4))
1
2
3
4
(#&lt;unspecified&gt; #&lt;unspecified&gt; #&lt;unspecified&gt; #&lt;unspecified&gt;)


&gt; (<span class="org-keyword">for-each</span> [lambda (x) (display x) (newline)]  '(1 2 3 4))
1
2
3
4

&gt; (<span class="org-keyword">for-each</span> [lambda (a b) (display a) (display b) (newline)] '(a b c d) '(1 2 3 4))
a1
b2
c3
d4
</pre>
</div>

<ul class="org-ul">
<li><b>apply</b>
</li>
</ul>

<p>
Apply a function to a list of arguments.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">hypot3d</span> a b c) [sqrt (+ (* a a) (* b b) (* c c) )])

&gt; (hypot3d 3 4 5)
7.07106781186548

&gt; (apply hypot3d '(3 4 5))
7.07106781186548

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">map-apply</span> f list-of-args) 
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (apply f x)) list-of-args))

&gt; (map-apply hypot3d '( (1 2 3) (3 4 5) (6 7 8)))
(3.74165738677394 7.07106781186548 12.2065556157337)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Special Functions</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Constant function - Will return a,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">regardless the value of x</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">constant</span> a)
  (<span class="org-keyword">lambda</span> (x) a))

(<span class="org-keyword">define</span> (<span class="org-function-name">id</span> x) x)

1 ]=&gt; (id 10)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; (<span class="org-keyword">map</span> id '(1 2 3 4 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: (1 2 3 4 6)</span>

1 ]=&gt; ((constant 10) 20)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; ((constant 10) 2000)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">f</span> (constant 10))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

1 ]=&gt; f

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 12: #[compound-procedure 12]</span>

1 ]=&gt; (f 45)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; (f 100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>

1 ]=&gt; (<span class="org-keyword">map</span> (constant 5) '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 13: (5 5 5 5 5 5)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> Functions Composition</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
<b>Basic Function Composition</b>
</p>


<div class="org-src-container">

<pre class="src src-scheme">1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">compose</span> f g) (<span class="org-keyword">lambda</span> (x) (f (g x))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: compose</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Foward Composition</span>
1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">fcompose</span> f g) (<span class="org-keyword">lambda</span> (x) (g (f x))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: fcompose</span>


<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">pi</span> (* 4 (atan 1.0)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: pi</span>

1 ]=&gt; pi

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 3.141592653589793</span>

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">deg2rad</span> deg) (* (/ deg 180) pi))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: deg2rad</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">sind</span> (compose sin deg2rad))

1 ]=&gt; (<span class="org-keyword">map</span> sind '(0 45 60 90 180 270))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 13: (0 .7071067811865475 .8660254037844386 1. 1.2246467991473532e-16 -1.)</span>

<span class="org-comment-delimiter">;;</span><span class="org-comment">---------------</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">sind</span> (fcompose deg2rad sin))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: sind</span>

1 ]=&gt; (<span class="org-keyword">map</span> sind '(0 45 60 90 180 270))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 15: (0 .7071067811865475 .8660254037844386 1. 1.2246467991473532e-16 -1.)</span>
</pre>
</div>

<p>
<b>Composition of a List of Functions</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">__compose-funcs</span> list-of-functions x)
  (<span class="org-keyword">if</span> (null? list-of-functions)
      x
      (__compose-funcs (cdr list-of-functions) ((car list-of-functions) x))
  ))      

(<span class="org-keyword">define</span> (<span class="org-function-name">compose-funcs</span> . list-of-functions)
  (<span class="org-keyword">lambda</span> (x)(__compose-funcs list-of-functions x)))

<span class="org-comment-delimiter">;;;</span><span class="org-comment">------------------------------;;;</span>

1 ]=&gt; ((compose-funcs log exp sin asin) 0.60)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .6000000000000001</span>

1 ]=&gt; 
(<span class="org-keyword">define</span> <span class="org-function-name">sind</span> (compose-funcs deg2rad sin))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: sind</span>

1 ]=&gt; (sind 30)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .49999999999999994</span>

1 ]=&gt; (sind 90)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Partial Application and Currying</h4>
<div class="outline-text-4" id="text-1-3-4">
</div><ol class="org-ol"><li><a id="sec-1-3-4-1" name="sec-1-3-4-1"></a>Partial Application<br  /><div class="outline-text-5" id="text-1-3-4-1">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">partial</span> fun . args)
      (<span class="org-keyword">lambda</span> x (apply fun (append args x))))

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y z) (+ (* 3 x) (* 2 y) (* -2 z)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

1 ]=&gt; (f 2 3 4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 4</span>

1 ]=&gt; ((partial f 1) 2 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1</span>

1 ]=&gt; ((partial f 1 2) 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1</span>


1 ]=&gt; (<span class="org-keyword">map</span> (partial f 1 2) '(1 2 3 4 5 6)) <span class="org-comment-delimiter">;;</span>

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 23: (5 3 1 -1 -3 -5)</span>
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> Applying Multiple Functions to a Single Argument</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Returns a functions that takes a list of functions and applies it to a single value.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">juxt</span> . fxs)
  (<span class="org-keyword">lambda</span> (x)
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (f) (f x)) fxs)))

1 ]=&gt; ((juxt sqrt exp log) 3.0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 20: (1.7320508075688772 20.08553692318767 1.0986122886681098)</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">f</span> (juxt sqrt exp log))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

1 ]=&gt; (f 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: (1.7320508075688772 20.08553692318767 1.0986122886681098)</span>


(<span class="org-keyword">map</span> f '(1 2 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 23: ((1 2.718281828459045 0) (1.4142135623730951 7.38905609893065 .6931471805599453) (1.7320508075688772 20.08553692318767 1.0986122886681098))</span>
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-1-3-5-1" name="sec-1-3-5-1"></a>Currying<br  /><div class="outline-text-5" id="text-1-3-5-1">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;;;; </span><span class="org-comment">Currying Transformations</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Turn a non curried function into a curried function </span>
<span class="org-comment-delimiter">;;</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">curry2</span> f)
    (<span class="org-keyword">lambda</span> (x)
        (<span class="org-keyword">lambda</span> (y)
            (f x y))))

(<span class="org-keyword">define</span> (<span class="org-function-name">curry3</span>  f)
    (<span class="org-keyword">lambda</span> (x)
        (<span class="org-keyword">lambda</span> (y)
            (<span class="org-keyword">lambda</span> (z)
                (f x y z)))))


(<span class="org-keyword">define</span> (<span class="org-function-name">curry4</span>  f)
    (<span class="org-keyword">lambda</span> (x)
        (<span class="org-keyword">lambda</span> (y)
            (<span class="org-keyword">lambda</span> (z)
                (<span class="org-keyword">lambda</span> (w)
                (f x y z w))))))

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">mul</span> x y) (* x y))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: mul</span>

1 ]=&gt; (mul 3 4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 12</span>

1 ]=&gt; (((curry2 mul) 3) 4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 12</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">mul3</span> ((curry2 mul) 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: mul3</span>


1 ]=&gt; (mul3 4)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 12</span>

1 ]=&gt; (<span class="org-keyword">map</span> mul3 '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 24: (3 6 9 12 15 18)</span>

1 ]=&gt;  

<span class="org-comment-delimiter">;;</span><span class="org-comment">--------------------------</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y z) (+ (* 3 x) (* 2 y) (* -2 z)))

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">cf</span> (curry3 f))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: cf</span>


1 ]=&gt; (((cf 1) 2) 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 1</span>


1 ]=&gt; (<span class="org-keyword">map</span> ((cf 1) 2) '( 1 2 3 4 5))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 27: (5 3 1 -1 -3)</span>
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> Miscellaneous</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
<b>Replicate N times a value</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">replicate</span> n x)
    (<span class="org-keyword">if</span> (zero? n)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (cons x (replicate (- n 1) x))
    )
)<span class="org-comment-delimiter">;; </span><span class="org-comment">End of replicate</span>


1 ]=&gt; (replicate 4 0)
$12 = (0 0 0 0)

1 ]=&gt; (replicate 8 <span class="org-string">"abc"</span>)
$13 = (<span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span> <span class="org-string">"abc"</span>)

1 ]=&gt; (replicate 3 'symbol)
$15 = (symbol symbol symbol)
</pre>
</div>

<p>
<b>Cycle</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">cycle_aux</span> n xs acc)
    (<span class="org-keyword">if</span>  (zero? n)     <span class="org-comment-delimiter">;;</span><span class="org-comment">(or (zero? n) (null? xs))</span>
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (<span class="org-keyword">if</span> (null? xs)
            (cycle_aux (- n 1) acc acc)
            (cons (car xs) (cycle_aux (- n 1) (cdr xs) acc))
        )
    )<span class="org-comment-delimiter">;; </span><span class="org-comment">End if</span>
)<span class="org-comment-delimiter">;; </span><span class="org-comment">End of cycle_aux</span>



1 ]=&gt; (cycle_aux 10 '(1 2 3) '(1 2 3))
$16 = (1 2 3 1 2 3 1 2)

1 ]=&gt; (cycle_aux 20 '(1 2 3) '(1 2 3))
$17 = (1 2 3 1 2 3 1 2 3 1 2 3 1 2 3)

(<span class="org-keyword">define</span> (<span class="org-function-name">cycle</span> n xs)
    (cycle_aux n xs xs))

1 ]=&gt; (cycle 10 '(a b c))
$18 = (a b c a b c a b)

1 ]=&gt; (cycle 20 '(0 1))
$19 = (0 1 0 1 0 1 0 1 0 1 0 1 0 1)
</pre>
</div>

<p>
<b>Intersperse</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">intersperse</span> a xs)  
  (<span class="org-keyword">if</span> (null? xs)
      '()
      [cons (car xs)
            (<span class="org-keyword">if</span> (null? (cdr xs))
                (cdr xs)
                (cons a (intersperse a (cdr xs))))]))


&gt; (intersperse 'x '(1 2 3 4 5))
(1 x 2 x 3 x 4 x 5) 

&gt; (intersperse '(x y) '(1 2 3 4 5))
(1 (x y) 2 (x y) 3 (x y) 4 (x y) 5)
</pre>
</div>


<p>
<b>Mapi</b>
</p>

<p>
Similar to Ocaml function mapi, map a function of index and value each index and element of a list.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">mapi</span> func lst)  
  (<span class="org-keyword">define</span> (<span class="org-function-name">mapi_acc</span> acc lst idx)
    (<span class="org-keyword">if</span> (null? lst)
        acc
        (mapi_acc
         (cons (func idx (car lst)) acc) 
         (cdr lst)                       
         (+ idx 1 ))))

  (reverse (mapi_acc '() lst 0)))

(<span class="org-keyword">define</span> (<span class="org-function-name">f_i_a</span> i a) (list i a)) 

&gt; (mapi f_i_a '(a b c d e f))
'((0 a) (1 b) (2 c) (3 d) (4 e) (5 f))
&gt;
</pre>
</div>

<p>
<b>Count Number of Elements</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">count-list</span> alist)
    (<span class="org-keyword">if</span> (null? alist)
        0
        (+ 1 (count-list (cdr alist)))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: count-list</span>

1 ]=&gt; (count-list '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 0</span>

1 ]=&gt; (count-list '(8 91 293 23))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 4</span>

1 ]=&gt; (count-list '(20 2932 1923 129 12 535 22))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 7</span>
</pre>
</div>

<p>
<b>Sum of list elements</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">sum-list</span> alist)
    (<span class="org-keyword">if</span> (null? alist)
        0
        (+ (car alist) (sum-list (cdr alist)))))

1 ]=&gt; (sum-list '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 21</span>
</pre>
</div>

<p>
<b>Find Element in a List</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">find</span> predicate alist)
    (<span class="org-keyword">if</span> (null? alist)
        (error <span class="org-string">"Error: Predicate not found"</span>)
        (<span class="org-keyword">if</span> (predicate (car alist))
            (car alist)
            (find predicate (cdr alist)))))

1 ]=&gt; (find (<span class="org-keyword">lambda</span> (x) (&lt; x 10)) '( 20 40 8 9 100 50 7))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 8</span>

1 ]=&gt; (find (<span class="org-keyword">lambda</span> (x) (&gt; x 50))  '( 20 40 8 9 100 50 7))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 100</span>


1 ]=&gt; (find (<span class="org-keyword">lambda</span> (x) (&gt; x 500))  '( 20 40 8 9 100 50 7))

<span class="org-comment-delimiter">;</span><span class="org-comment">Error: Predicate not found</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">To continue, call RESTART with an option number:</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">(RESTART 1) =&gt; Return to read-eval-print level 1.</span>

2 error&gt;
</pre>
</div>

<p>
<b>Drop / Take n elements</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">take</span> n alist)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? alist) (= n 0))
        '()
        (cons (car alist) (take (- n 1) (cdr alist)))))

1 ]=&gt; (take 10 '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (take 3 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 17: (1 2 3)</span>

1 ]=&gt; (take 4 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 18: (1 2 3 4)</span>

1 ]=&gt; (take 100 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 19: (1 2 3 4 5 6)</span>

1 ]=&gt; 

(<span class="org-keyword">define</span> (<span class="org-function-name">drop</span> n alist)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? alist) (= n 0))
        alist
        (drop (- n 1) (cdr alist))))

1 ]=&gt; (drop 3 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 20: (4 5 6)</span>

1 ]=&gt; (drop 5 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: (6)</span>

1 ]=&gt; (drop 15 '(1 2 3 4 5 6 ))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (drop 15 '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt;
</pre>
</div>

<p>
<b>Take while and Drop While</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">take_while</span> predicate alist)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? alist) (not (predicate (car alist))))
        '()
        (cons (car alist) (take_while predicate (cdr alist)))))

1 ]=&gt; (take_while (<span class="org-keyword">lambda</span> (x) (&lt; x 10)) '(1 8 7 9 10 20 5 62 2 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 29: (1 8 7 9)</span>

1 ]=&gt; (take_while (<span class="org-keyword">lambda</span> (x) (&gt; x 10)) '(1 8 7 9 10 20 5 62 2 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (take_while (<span class="org-keyword">lambda</span> (x) (&lt; x 10)) '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>


(<span class="org-keyword">define</span> (<span class="org-function-name">drop_while</span> predicate alist)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? alist) (not (predicate (car alist))))
        alist
        (drop_while predicate (cdr alist))))


1 ]=&gt; (drop_while (<span class="org-keyword">lambda</span> (x) (&lt; x 10)) '(1 8 7 9 10 20 5 62 2 3))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 30: (10 20 5 62 2 3)</span>

1 ]=&gt; (drop_while (<span class="org-keyword">lambda</span> (x) (&lt; x 100)) '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>
</pre>
</div>

<p>
<b>Select (Filter) / Reject list elements</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">select</span> predicate alist)
    (<span class="org-keyword">if</span> (null? alist)
    '()
    (<span class="org-keyword">if</span> (predicate (car alist))        
        (cons (car alist) (select predicate (cdr alist)))        
        (select predicate (cdr alist)))))


1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">is_even</span> x) (= 0 (modulo x 2)))

1 ]=&gt; (select is_even '( 1 2 3 4 5 6 7 8 9 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 34: (2 4 6 8)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Higher Order function to invert Predicate</span>
1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">neg</span> predicate) (<span class="org-keyword">lambda</span> (x) (not (predicate x))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: neg</span>

1 ]=&gt; (select (neg is_even) '( 1 2 3 4 5 6 7 8 9 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 35: (1 3 5 7 9 1)</span>

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">is_odd</span> (neg is_even))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: is_odd</span>


1 ]=&gt; (select is_odd  '( 1 2 3 4 5 6 7 8 9 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 36: (1 3 5 7 9 1)</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">reject</span> predicate alist)
    (<span class="org-keyword">if</span> (null? alist)
    '()
    (<span class="org-keyword">if</span> (not (predicate (car alist)))        
        (cons (car alist) (reject predicate (cdr alist)))        
        (reject predicate (cdr alist)))))

1 ]=&gt; (reject is_even '( 1 2 3 4 5 6 7 8 9 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: (1 3 5 7 9 1)</span>

1 ]=&gt;  (reject (neg is_even) '( 1 2 3 4 5 6 7 8 9 1))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 13: (2 4 6 8)</span>
</pre>
</div>


<p>
<b>Folds: Fold Right/ Fold Left</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">Fold Right - https://en.wikipedia.org/wiki/Fold_(higher-order_function)</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldr f z []     = z</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldr f z (x:xs) = f x (foldr f z xs)</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">foldr</span> f_el_acc acc alist)
    (<span class="org-keyword">if</span> (null? alist)
        acc
        (f_el_acc (car alist) (foldr f_el_acc acc (cdr alist)))))

1 ]=&gt; (foldr + 0 '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 21</span>

1 ]=&gt; (foldr (<span class="org-keyword">lambda</span> (el acc) (+ el (* 10 acc))) 0 '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 654321</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">Fold Left - https://en.wikipedia.org/wiki/Fold_(higher-order_function)</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldl f z []     = z</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">foldl f z (x:xs) = foldl f (f z x) xs       </span>

(<span class="org-keyword">define</span> (<span class="org-function-name">foldl</span> f_el_acc acc alist)
    (<span class="org-keyword">if</span> (null? alist)
        acc
        (foldl f_el_acc (f_el_acc acc (car alist)) (cdr alist))))

1 ]=&gt; (foldl + 0 '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 21</span>

1 ]=&gt; (foldl (<span class="org-keyword">lambda</span> (el acc) (+ (* 10 el)  acc)) 0 '(1 2 3 4 5 6))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 123456</span>
</pre>
</div>

<p>
<b>Zip Lists</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">zip2</span> list1 list2)

    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? list1) (null? list2))
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()        
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (cons (list (car list1) (car list2)) 
            (zip2 (cdr list1) (cdr list2)))
    )
)

1 ]=&gt; (zip2 '() '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (zip2 '() '(1 2 3 4))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (zip2 '(1 2 3 4 5) '())

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ()</span>

1 ]=&gt; (zip2 '(1 2 3 4 5) '(a b c d e f g i j l m n))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 11: ((1 a) (2 b) (3 c) (4 d) (5 e))</span>

1 ]=&gt; 

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">The function zip is defined in MIT-Scheme, but not in other Schemes</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">like GNU-Guile.</span>
<span class="org-comment-delimiter">;;</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Returns true if any element of a list satisfies the predicate </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">function</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">any</span> predicate alist)
    (<span class="org-keyword">if</span> (null? alist)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        #f
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (<span class="org-keyword">if</span> (predicate (car alist))
            #t
            (any predicate (cdr alist))
        )
    ) <span class="org-comment-delimiter">;; </span><span class="org-comment">End if</span>
)<span class="org-comment-delimiter">;; </span><span class="org-comment">End of any</span>


1 ]=&gt; (any (<span class="org-keyword">lambda</span> (x) (&gt; x 10))  '( -3 4 5 8 9))
$1 = #f

1 ]=&gt; (any (<span class="org-keyword">lambda</span> (x) (&gt; x 10))  '( -3 10 4 5 8 20 9))
$2 = #t

1 ]=&gt; (any (<span class="org-keyword">lambda</span> (x) (&gt; x 10))  '())
$3 = #f


1 ]=&gt; (any null? (list '(1 2) '(3 5)))
$5 = #f

1 ]=&gt; (any null? (list '(1 2) '(3 5) '()))
$6 = #t


(<span class="org-keyword">define</span> (<span class="org-function-name">zip_aux</span> list-of-lists)
    (<span class="org-keyword">if</span> (any null? list-of-lists)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (cons (<span class="org-keyword">map</span> car list-of-lists) (zip_aux (<span class="org-keyword">map</span> cdr list-of-lists)))
    )
)

(<span class="org-keyword">define</span> (<span class="org-function-name">zip</span> . lists) (zip_aux lists))

1 ]=&gt; (zip_aux (list '( 1 2 3 4 5) '(a b c d e f g h) '(<span class="org-string">"hello"</span> <span class="org-string">"schme"</span> <span class="org-string">"lisp"</span> <span class="org-string">"fp"</span>)))
$7 = ((1 a <span class="org-string">"hello"</span>) (2 b <span class="org-string">"schme"</span>) (3 c <span class="org-string">"lisp"</span>) (4 d <span class="org-string">"fp"</span>))

1 ]=&gt; (zip '( 1 2 3 4 5) '(a b c d e f g h) '(<span class="org-string">"hello"</span> <span class="org-string">"schme"</span> <span class="org-string">"lisp"</span> <span class="org-string">"fp"</span>))
$7 = ((1 a <span class="org-string">"hello"</span>) (2 b <span class="org-string">"schme"</span>) (3 c <span class="org-string">"lisp"</span>) (4 d <span class="org-string">"fp"</span>))
</pre>
</div>


<p>
<b>Unzip Lists</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">unzip2</span> list-of-pairs)
    (<span class="org-keyword">if</span> (null? list-of-pairs)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else        </span>
        (list (<span class="org-keyword">map</span> car list-of-pairs)  (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (xy) (car (cdr xy)))  list-of-pairs))
    )
)

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">xys</span> '((1 a) (2 b) (3 c) (4 d)))

1 ]=&gt; xys
$9 = ((1 a) (2 b) (3 c) (4 d))

1 ]=&gt; (unzip2 xys)
$11 = ((1 2 3 4) (a b c d))

<span class="org-comment-delimiter">;;  </span><span class="org-comment">Unzip with foldr</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Haskell:</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">unzip :: [(a, b)] -&gt; ([a], [b])</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">unzip = foldr f ([],[])</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">where f (x,y) ~(xs,ys) = (x:xs,y:ys)</span>
<span class="org-comment-delimiter">;;</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">foldr</span> f_el_acc acc alist)
    (<span class="org-keyword">if</span> (null? alist)
        acc
        (f_el_acc (car alist) (foldr f_el_acc acc (cdr alist)))))

(<span class="org-keyword">define</span> <span class="org-function-name">fst</span> car)
(<span class="org-keyword">define</span> (<span class="org-function-name">snd</span> xs) (car (cdr xs)))

(<span class="org-keyword">define</span> (<span class="org-function-name">unzip2f</span> list-of-pairs)
    (<span class="org-keyword">if</span> (null? list-of-pairs)
        '()
        (foldr 
            (<span class="org-keyword">lambda</span> (xy xys)  
                (list 
                    (cons (fst xy) (fst xys))
                    (cons (snd xy) (snd xys))
                )
            )
            (list '() '()) <span class="org-comment-delimiter">;; </span><span class="org-comment">([],[])</span>
            list-of-pairs
        )
    )
)

1 ]=&gt; (unzip2f '((1 a) (2 b) (3 c) (4 d)))
$24 = ((1 2 3 4) (a b c d))

1 ]=&gt; (unzip2f '())
$25 = ()


<span class="org-comment-delimiter">;;;;; </span><span class="org-comment">Unzip for list of multiple lists</span>
<span class="org-comment-delimiter">;;;;;</span>
<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>


<span class="org-comment-delimiter">;;; </span><span class="org-comment">Constant function - Will return a,</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">regardless the value of x</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">constant</span> a)
  (<span class="org-keyword">lambda</span> (x) a))

(<span class="org-keyword">define</span> (<span class="org-function-name">unzip-aux</span> alist)
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (list x)) alist)
    )

(<span class="org-keyword">define</span> (<span class="org-function-name">unzip</span> list-of-list)
    (<span class="org-keyword">if</span> (null? list-of-list)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()        
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (foldr 
            (<span class="org-keyword">lambda</span> (t ts)

               (<span class="org-keyword">map</span>
                (<span class="org-keyword">lambda</span> (x) (cons (car x) (car (cdr x)))) 
                (zip t ts)
               )             
              )<span class="org-comment-delimiter">;; </span><span class="org-comment">End lambda</span>

            (<span class="org-keyword">map</span> (constant '()) list-of-list)
            list-of-list

        )<span class="org-comment-delimiter">;; </span><span class="org-comment">End foldr</span>

    )<span class="org-comment-delimiter">;; </span><span class="org-comment">End If</span>
)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Variadic version of unzip</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">unzip-v</span> . lists) (unzip lists))

1 ]=&gt; (unzip '( (1 2 3) (11 10 20) (30 40 50)))
$4 = ((1 11 30) (2 10 40) (3 20 50)

1 ]=&gt; (unzip '( (1 a <span class="org-string">"c"</span>) (230 b <span class="org-string">"xs"</span>) (1000 sym <span class="org-string">"ccw"</span>) (434 con <span class="org-string">"xyzw"</span>)))
$5 = ((1 230 1000 434) (a b sym con) (<span class="org-string">"c"</span> <span class="org-string">"xs"</span> <span class="org-string">"ccw"</span> <span class="org-string">"xyzw"</span>))

1 ]=&gt; (unzip-v '(1 2 3) '(11 10 20) '(30 40 50))
$6 = ((1 11 30) (2 10 40) (3 20 50))

1 ]=&gt; (unzip-v '(1 a <span class="org-string">"c"</span>) '(230 b <span class="org-string">"xs"</span>) '(1000 sym <span class="org-string">"ccw"</span>) '(434 con <span class="org-string">"xyzw"</span>))
$7 = ((1 230 1000 434) (a b sym con) (<span class="org-string">"c"</span> <span class="org-string">"xs"</span> <span class="org-string">"ccw"</span> <span class="org-string">"xyzw"</span>))
</pre>
</div>

<p>
<b>Zip With</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">zip_aux</span> list-of-lists)
    (<span class="org-keyword">if</span> (any null? list-of-lists)
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Then</span>
        '()
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Else</span>
        (cons (<span class="org-keyword">map</span> car list-of-lists) (zip_aux (<span class="org-keyword">map</span> cdr list-of-lists)))
    )
)

(<span class="org-keyword">define</span> (<span class="org-function-name">zip_with</span> f list-of-lists)
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (xs) (apply f xs)) (zip_aux list-of-lists))
)

1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y z) (+ (* 3 x) (* 4 y) (* -5 z)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: f</span>

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">-22 = f 1 5 9 = (+ (* 3 1) (* 4 5) (* -5 9))) = (+ 3 20 -45) = -22</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">-5 = f 2 6 7 = (+ (* 3 2) (* 4 6) (* -5 7))) = (+ 6 24 -35) = -5</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">22 = f 3 7 3 = (+ (* 3 3) (* 4 7) (* -5 3))) = (+ 9 28 -15) =  22</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (zip_with f '((1 2 3) (5 6 7) (9 7 3)))
<span class="org-comment-delimiter">;</span><span class="org-comment">Value 15: (-22 -5 22)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Lazy Evaluation / Delayed Evaluation</h3>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Object Orientated Programming</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Objects can be implemented with closures as can be seen in:
</p>

<ul class="org-ul">
<li><a href="http://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/swob.txt">Scheming  with  Objects</a>
</li>
<li><a href="http://okmij.org/ftp/Scheme/oop-in-fp.txt">FP, OO and relations. Does anyone trump the others?</a>
</li>
</ul>

<p>
<b>Example - 2D Points</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-point</span> x y)
  (<span class="org-keyword">define</span> (<span class="org-function-name">get-x</span>) x)
  (<span class="org-keyword">define</span> (<span class="org-function-name">get-y</span>) y)
  (<span class="org-keyword">define</span> (<span class="org-function-name">set-x!</span> x_new) (set! x x_new))
  (<span class="org-keyword">define</span> (<span class="org-function-name">set-y!</span> y_new) (set! y y_new))
  (<span class="org-keyword">define</span>  (<span class="org-function-name">pos</span>) (list x  y))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">Message Passying Style</span>
  (<span class="org-keyword">lambda</span> (message . args)
    (<span class="org-keyword">case</span> message
        ((get-x)  (apply get-x args))
        ((get-y)  (apply get-y args))
        ((set-x!) (apply set-x! args))
        ((set-y!) (apply set-y! args))
        ((pos)    (apply pos args))
        (<span class="org-keyword">else</span> (error <span class="org-string">"POINT: Unknown message -&gt;"</span> message))

    )
   )<span class="org-comment-delimiter">;; </span><span class="org-comment">End of self</span>
)<span class="org-comment-delimiter">;; </span><span class="org-comment">End of make-point </span>

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">point-1</span> (make-point 3 4))
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">point-2</span> (make-point 10 5))


&gt; point-1
$21 = #&lt;procedure 99e0060 at &lt;current input&gt;:307:2 (message . args)&gt;


&gt; point-2
$22 = #&lt;procedure 9978e00 at &lt;current input&gt;:277:2 (self message . args)&gt;



&gt; (point-1 'get-x)
$12 = 3
&gt; (point-1 'get-y)
$13 = 4
&gt; (point-1 'pos)
$43 = (3 4)


<span class="org-comment-delimiter">;; </span><span class="org-comment">Apply a function of multiple arguments to a list of arguments</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">map-args</span> f list-of-args)
   (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (args) (apply f args)) list-of-args))

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">get-attr</span> attr) (<span class="org-keyword">lambda</span> (object) (object attr)))

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">set-attr</span> attr)
    (<span class="org-keyword">lambda</span> (object value) (object attr value)))


&gt; (<span class="org-keyword">map</span> (get-attr 'get-x)  (list point-1 point-2))
$14 = (3 10)

&gt; (<span class="org-keyword">map</span> (get-attr 'get-y)  (list point-1 point-2))
$15 = (4 5)


&gt; (<span class="org-keyword">map</span> (get-attr 'pos)  (list point-1 point-2))
$16 = ((3 4) (10 5))


&gt; (point-1 'set-x! 100)

&gt; (point-1 'pos)
$47 = (100 4)




(<span class="org-keyword">define</span> <span class="org-function-name">points</span> (map-args make-point '( (2 3) (5 4) (8 7) (9 10))))


&gt; (<span class="org-keyword">map</span> (get-attr 'get-x) points)
$49 = (2 5 8 9)

&gt; (<span class="org-keyword">map</span> (get-attr 'get-y) points)
$51 = (3 4 7 10)

&gt; (<span class="org-keyword">map</span> (get-attr 'pos) points)
$52 = ((2 3) (5 4) (8 7) (9 10))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Function call style </span>


&gt; (<span class="org-keyword">define</span> <span class="org-function-name">get-x</span> (get-attr 'get-x))
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">get-y</span> (get-attr 'get-y))

&gt; (<span class="org-keyword">map</span> get-x points)
$54 = (2 5 8 9)

&gt; (<span class="org-keyword">map</span> get-y points)
$55 = (3 4 7 10)

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">set-x!</span> (set-attr 'set-x))

&gt; (get-x point-1)
$57 = 100

&gt; (set-x! point-1 78)

&gt; (get-x point-1)
$58 = 78
</pre>
</div>

<p>
<b>Example: Stack</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-stack</span>)   
  (<span class="org-keyword">define</span> <span class="org-function-name">stack</span> '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">show</span>) stack)
  (<span class="org-keyword">define</span> (<span class="org-function-name">top</span>) (car stack))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty?</span>)
    (null? stack))

  (<span class="org-keyword">define</span> (<span class="org-function-name">reset</span>)
    (set! stack '()))

  (<span class="org-keyword">define</span> (<span class="org-function-name">push</span> x)
    (set! stack (cons x stack)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">pop</span>)
    (<span class="org-keyword">let</span>
        ((p (car stack)))
      (<span class="org-keyword">begin</span>
        (set! stack (cdr stack))
        p)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">pop-all</span>)
    (<span class="org-keyword">let</span>
        ((p stack))
      (<span class="org-keyword">begin</span>
        (set! stack '())
        p)))
  (<span class="org-keyword">lambda</span> (selector . args)
    (<span class="org-keyword">case</span> selector
      ((show)    (apply show args))
      ((reset)   (apply reset args))
      ((push)    (apply push args))
      ((pop)     (apply pop args))
      ((top)     (apply top args))
      ((pop-all) (apply pop-all args)))))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">s</span> (make-stack))
&gt; (s 'show)
()
&gt; (s 'push 10)
&gt; (s 'push 20)
&gt; (s 'push 30)
&gt; (s 'show)
(30 20 10)
&gt; (s 'top)
30
&gt; (s 'pop)
30
&gt; (s 'show)
(20 10)
&gt; (s 'empty)
&gt; (s 'push 1000)
&gt; (s 'show)
(1000 20 10)
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Metaprogramming</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Metaprogramming is the ability to create that code that writes
code. Like any lisp scheme has great metaprogramming capabilities
like:
</p>

<ul class="org-ul">
<li>Code is data and data is code 
</li>
<li>Exposes the AST abstract syntax tree, that is an atom (symbol, string or a number) or a list 
</li>
<li>The AST is a list of lists and atoms or a single atom
</li>
<li>The AST can be manipulated like any list
</li>
<li>Lisp programs can build itself
</li>
<li>The macro system allows the user to create new syntax rules and create new language constructs.
</li>
</ul>
</div>



<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> The Abstract Syntax Tree</h4>
<div class="outline-text-4" id="text-1-6-1">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">A lisp AST is a list of lists and atoms or an atom </span>
<span class="org-comment-delimiter">;;</span>

1 ]=&gt; (quote (<span class="org-keyword">if</span> (&gt; x 5) 100 200))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 17: (if (&gt; x 5) 100 200)</span>

<span class="org-comment-delimiter">;;;  </span><span class="org-comment">OR</span>

1 ]=&gt; '(<span class="org-keyword">if</span> (&gt; x 5) 100 200))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 18: (if (&gt; x 5) 100 200)</span>

<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>


1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">ast</span> '(<span class="org-keyword">if</span> (&gt; x 5) 100 200))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ast</span>

1 ]=&gt; ast

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 19: (if (&gt; x 5) 100 200)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">The abstract synxtax tree is a list</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (list? ast)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: #t</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Decomposing the AST</span>
<span class="org-comment-delimiter">;;</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">inspect-aux</span> obj)
 (<span class="org-keyword">cond</span> 
   ((list? obj  )     <span class="org-string">"list"</span>)
   ((number? obj)     <span class="org-string">"number"</span>)
   ((symbol? obj)     <span class="org-string">"symbol"</span>)
   ((string? obj)     <span class="org-string">"string"</span>)
 )
) <span class="org-comment-delimiter">;; </span><span class="org-comment">End of inspect</span>


(<span class="org-keyword">define</span> (<span class="org-function-name">inspect</span> obj)
    (list obj (inspect-aux obj))
)

1 ]=&gt; (<span class="org-keyword">map</span> inspect ast)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 21: ((if "symbol") ((&gt; x 5) "list") (100 "number") (200 "number"))</span>

<span class="org-comment-delimiter">;;  </span><span class="org-comment">Extracting AST</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">----------------------------------</span>

1 ]=&gt; (cdr ast)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 22: ((&gt; x 5) 100 200)</span>

1 ]=&gt; (list-ref ast 0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: if</span>

1 ]=&gt; (list-ref ast 1)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 23: (&gt; x 5)</span>

1 ]=&gt; (list-ref ast 2)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 100</span>

1 ]=&gt; (list-ref ast 3)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 200</span>

1 ]=&gt; 


1 ]=&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">ast-ref</span> ast i) (inspect (list-ref ast i)))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ast-ref</span>

1 ]=&gt; (ast-ref ast 0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 24: (if "symbol")</span>

1 ]=&gt; (ast-ref ast 1)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 25: ((&gt; x 5) "list")</span>

1 ]=&gt; 

<span class="org-comment-delimiter">;; </span><span class="org-comment">Evaluating the AST</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

1 ]=&gt; (eval '(<span class="org-keyword">define</span> <span class="org-function-name">z</span> 10) (the-environment))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: z</span>

1 ]=&gt; z

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10</span>




1 ]=&gt;  (<span class="org-keyword">define</span> <span class="org-function-name">ast</span> '(<span class="org-keyword">if</span> (&gt; x 5) 100 200))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: ast</span>

1 ]=&gt; ast

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 29: (if (&gt; x 5) 100 200)</span>

1 ]=&gt; (eval ast (the-environment))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 100</span>

1 ]=&gt; 

1 ]=&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> -100)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: x</span>

1 ]=&gt; (eval ast (the-environment))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 200</span>

1 ]=&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> Macros</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
Macros allows to redefine the synxtax, create new language constructs,
expand the language and create DSL - Domain Specific Languages.
</p>

<p>
Note: all the macros bellow were tested on GNU GUILE that was started with the command:
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap --remember -c guile
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-1-6-2-1" name="sec-1-6-2-1"></a>Hygienic Macros - Define-syntax<br  /><div class="outline-text-5" id="text-1-6-2-1">
<p>
Examples:
</p>

<p>
<b>Increment a variable</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(define-syntax-rule
  (incr var)
  (set! var (+ 1 var)))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 10)
&gt; x
$1 = 10
&gt; 
&gt; (incr x)
&gt; x
$2 = 11

$3 = x
&gt; ,expand (incr x)
$4 = (set! x (+ 1 x))
&gt;
</pre>
</div>

<p>
<b>Swap two variables</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">-! is idomatic for mutation</span>

(define-syntax-rule (swap! x y) 
  (<span class="org-keyword">let</span> ((tmp x))
    (set! x y)
    (set! y tmp)))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">a</span> 10)
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">b</span> 90)
&gt; a
$19 = 10
&gt; b
$20 = 90

&gt; (swap! a b)
&gt; a
$21 = 90
&gt; b
$22 = 10
&gt; 

&gt; ,expand (swap! a b)
&gt; $34 = (<span class="org-keyword">let</span> ((tmp a)) (set! a b) (set! b tmp))
&gt;
</pre>
</div>

<p>
<b>Convert Infix Operator to prefix operator</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">$</span>
  (<span class="org-keyword">syntax-rules</span> ()
    (($ a operator b)
     (operator a b))))

&gt; ($ 2 &lt; 10)
$1 = #t

&gt; ($ 10 = 2)
$2 = #f


&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">myoperator</span> x y) ($ ($ 3 *  x) +  ($ 4 *  y)))

&gt; (myoperator 2 5)
$3 = 26


&gt; ($ 2 myoperator 5)
$6 = 26

&gt; ($ 2 myoperator 5)
$6 = 26


&gt; ($ 10 + 3)
$5 = 13

&gt; ,expand ($ 10 + 3)
$4 = (+ 10 3)

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 100)

&gt; (<span class="org-keyword">if</span> ($ x &lt; 10) <span class="org-string">"less than 10"</span> <span class="org-string">"greater than 10"</span>)
$7 = <span class="org-string">"greater than 10"</span>


&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 1)

&gt; (<span class="org-keyword">if</span> ($ x &lt; 10) <span class="org-string">"less than 10"</span> <span class="org-string">"greater than 10"</span>)
$8 = <span class="org-string">"less than 10"</span>
</pre>
</div>

<p>
<b>Invert Predicate</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(define-syntax-rule
    ($n pred args ...)
    (not (pred args ...)))

&gt; (list? '(1 2 3 4))
$1 = #t

&gt; ($n list? '(1 2 3 4))
$2 = #f

&gt; ,expand ($n list? 100)
$4 = (not (list? 100))

&gt; ,expand ($n or (pair? x) (list? x))
$6 = (not (<span class="org-keyword">or</span> (pair? x) (list? x)))
</pre>
</div>

<p>
<b>Delay and force a computation</b>
</p>

<p>
Lazy evaluation.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(define-syntax-rule
  (thunk computation )
  (<span class="org-keyword">lambda</span> () computation))

&gt; (thunk (/ 3 0))
$9 = #&lt;procedure 960e670 at &lt;current input&gt;:37:0 ()&gt;
&gt; 

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">t</span> (thunk (/ 3 0)))
&gt; t
$10 = #&lt;procedure t ()&gt;
&gt; 

&gt; (t)
&lt;unnamed port&gt;:42:17: In procedure t:
&lt;unnamed port&gt;:42:17: Throw to key `numerical-overflow' with args `(<span class="org-string">"/"</span> <span class="org-string">"Numerical overflow"</span> #f #f)'.

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
&gt;

(define-syntax-rule
  (force-thunk computation )
  (computation)       <span class="org-comment-delimiter">;; </span><span class="org-comment">computation ()</span>
) 

&gt; (force-thunk t)
&lt;unnamed port&gt;:59:17: In procedure t:
&lt;unnamed port&gt;:59:17: Throw to key `numerical-overflow' with args `(<span class="org-string">"/"</span> <span class="org-string">"Numerical overflow"</span> #f #f)'.

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
&gt;
</pre>
</div>

<p>
<b>Define alias</b>
</p>

<p>
Change the define statement to def.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">def</span>
  (<span class="org-keyword">syntax-rules</span> ()
    ((def name value )
     (<span class="org-keyword">define</span> <span class="org-function-name">name</span> value ))))

&gt; (def x 100)


&gt; ,expand (def x 100)
$10 = (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 100)

&gt; (def (f x y) (+ (* 3 x) (* 4 y)))

&gt; (f 3 5)
$11 = 29

&gt; ,expand (def (f x y) (+ (* 3 x) (* 4 y)))
$12 = (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y) (+ (* 3 x) (* 4 y)))
</pre>
</div>

<p>
<b>Common-lisp defun statement</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(define-syntax-rule
  (defun name params body ...)
  (<span class="org-keyword">define</span> (<span class="org-function-name">name</span> . params)
    body ...))

&gt; (defun f (x y) (+ (* 3 x) (* 4 y)))

&gt; f
$5 = #&lt;procedure f (x y)&gt;

&gt; (f 2 3)
$6 = 18
&gt; 

&gt; ,expand (defun f (x y) (+ (* 3 x) (* 4 y)))
$7 = (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y) (+ (* 3 x) (* 4 y)))
&gt;
</pre>
</div>

<p>
<b>Multi define statement</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">define-multi</span> 
    (<span class="org-keyword">syntax-rules</span> () 
     ((define-multi (var val)  ...) 
      (<span class="org-keyword">begin</span> 
        (<span class="org-keyword">define</span> <span class="org-function-name">var</span> val) ...))))

(define-multi 
   (a 10)
   (b 200)
   (c 300)
   (d <span class="org-string">"something"</span>)
   (e 'a-symbol))

&gt; a
$13 = 10

&gt; b
$14 = 200


&gt; c
$15 = 300


&gt; d
$16 = <span class="org-string">"something"</span>

&gt; e
$17 = a-symbol

&gt; ,expand (define-multi 
   (a 10)
   (b 200)
   (c 300)
   (d <span class="org-string">"something"</span>)
   (e 'a-symbol))
$4 = (<span class="org-keyword">begin</span>
  (<span class="org-keyword">define</span> <span class="org-function-name">a</span> 10)
  (<span class="org-keyword">define</span> <span class="org-function-name">b</span> 200)
  (<span class="org-keyword">define</span> <span class="org-function-name">c</span> 300)
  (<span class="org-keyword">define</span> <span class="org-function-name">d</span> <span class="org-string">"something"</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">e</span> 'a-symbol))
</pre>
</div>


<p>
<b>Print Variable name and value</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">show-var</span>
    (<span class="org-keyword">syntax-rules</span> ()
      ((_ var)
       (cons 'var  var))))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> '( it is all symbols (list of symbols)))
&gt; x
$36 = (it is all symbols (litst of symbols))
&gt; 

1 ]=&gt; (show-var x)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value 39: (x it is all symbols (list of symbols))</span>

1 ]=&gt;
</pre>
</div>

<p>
<b>Association List</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">define-assoc</span>
    (<span class="org-keyword">syntax-rules</span> () 
     (( define-assoc name ((sym value) ...))
      (<span class="org-keyword">define</span> <span class="org-function-name">name</span> (list (cons sym value) ...)))))

&gt; (define-assoc colors (('red 1) ('blue 2) ('white 3) ('green 5)))

&gt; colors
$94 = ((red . 1) (blue . 2) (white . 3) (green . 5))

,expand (define-assoc colors (('red 1) ('blue 2) ('white 3) ('green 5)))
$95 = (<span class="org-keyword">define</span> <span class="org-function-name">colors</span>
  (list (cons 'red 1)
        (cons 'blue 2)
        (cons 'white 3)
        (cons 'green 5)))

(assoc 'red colors)
$96 = (red . 1)


(car (assoc 'red colors))
$97 = red
</pre>
</div>


<p>
<b>Dispatch Table</b>
</p>

<p>
Create a symbol dispatch table macro
</p>

<p>
Example: Without Macro
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">dispatch-table</span>
  (list
   (cons 'cons cons)
   (cons  'car  car)
   (cons  'cdr  cdr)
   (cons 'list list)
   (cons '+ +)
   (cons '- -)
   (cons '* *)
   (cons '/ *)   
   (cons 'expt expt)
   (cons 'sin sin)
   (cons 'cos cos)
   (cons 'tan tan)
   (cons 'exp exp)
   (cons 'sqrt sqrt)
   (cons 'log log)))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-key</span>  key assoclist)
      (cdr (assoc key assoclist)))

(<span class="org-keyword">define</span> (<span class="org-function-name">has-key?</span> key assoclist)
  (member key (<span class="org-keyword">map</span> car assoclist)))

(get-key '+ dispatch-table)
$78 = #&lt;procedure + (<span class="org-builtin">#:optional</span> _ _ . _)&gt;

((get-key 'exp dispatch-table) 3)
$80 = 20.085536923187668

((get-key (string-&gt;symbol <span class="org-string">"exp"</span>) dispatch-table) 3)
$81 = 20.085536923187668
</pre>
</div>

<p>
With Macro:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">define-dispatch-table</span>
    (<span class="org-keyword">syntax-rules</span> () 
     ((define-dispatch-table name (sym ...)) 
      (<span class="org-keyword">define</span> <span class="org-function-name">name</span> (list
                    (cons 'sym sym) ...)))))

(define-dispatch-table dispatch-table 
  (cons car cdr list + - * / expt sin cos tan exp sqrt log))

&gt; ((get-key 'exp dispatch-table) 3)
$84 = 20.085536923187668 

&gt; ((get-key '+ dispatch-table) 1 2 3 4 5 6)
$85 = 21  

&gt; ,expand (define-dispatch-table dispatch-table 
  (cons car cdr list + - * / expt sin cos tan exp sqrt log))
$86 = (<span class="org-keyword">define</span> <span class="org-function-name">dispatch-table</span>
  (list (cons 'cons cons)
        (cons 'car car)
        (cons 'cdr cdr)
        (cons 'list list)
        (cons '+ +)
        (cons '- -)
        (cons '* *)
        (cons '/ /)
        (cons 'expt expt)
        (cons 'sin sin)
        (cons 'cos cos)
        (cons 'tan tan)
        (cons 'exp exp)
        (cons 'sqrt sqrt)
        (cons 'log log)))
</pre>
</div>

<p>
<b>Clojure defn, def and fn statements</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(def &lt;name&gt; &lt;value&gt;)</span>
<span class="org-comment-delimiter">;;</span>
(define-syntax-rule
    (def name value)
    (<span class="org-keyword">define</span> <span class="org-function-name">name</span> value))

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(defn &lt;name&gt; [&lt;params&gt;] (&lt;body&gt;))</span>
<span class="org-comment-delimiter">;;    </span>
(define-syntax-rule
    (defn name params body ...)
    (<span class="org-keyword">define</span> (<span class="org-function-name">name</span> . params)
      body ...))    


<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(fn [vars] (&lt;body&gt;)))</span>
<span class="org-comment-delimiter">;;</span>
  (define-syntax-rule
    (fn params body)
    (<span class="org-keyword">lambda</span> params body))

&gt; (def x 10)
&gt; x
$2 = 10


&gt; (def xs '(a b c d e f))
&gt; xs
$3 = (a b c d e f)

&gt; (defn f [x y] (+ (* 3 x) (* 4 y)))

&gt; (f 3 4)
$4 = 25


&gt; (<span class="org-keyword">map</span> (fn [x] (+ x 3)) '[1 2 3 4 5 6])
$5 = (4 5 6 7 8 9)
</pre>
</div>

<p>
<b>Clojure Doto Macro</b>
</p>

<p>
See also: <a href="https://clojuredocs.org/clojure.core/doto">https://clojuredocs.org/clojure.core/doto</a>
</p>

<p>
Applies a sequence of methods to a object and returns the object modified by the methods.
</p>

<p>
Usage:
</p>

<pre class="example">
(doto {&lt;object&gt;|&lt;object definition&gt;} 
    (&lt;method1&gt; &lt;args1&gt;)
    (&lt;method2&gt; &lt;args2&gt;)
    ...
    )
</pre>


<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">doto</span> 
(<span class="org-keyword">syntax-rules</span> () 
 ((doto object (method  args ...)  ...)
  (<span class="org-keyword">let</span>
      ((obj object))        
     (<span class="org-keyword">begin</span> 
      (method obj args ...) ...
      obj)))))

&gt; v
'#(#{Unspecific} #{Unspecific})
&gt; (doto v 
        (vector-set! 0 'foo) 
        (vector-set! 1 'bar))
'#(foo bar)
&gt; 

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Or</span>

&gt; (doto (make-vector 2) 
            (vector-set! 0 'foo) 
            (vector-set! 1 'bar))
'#(foo bar)
&gt; 

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Macro Expansion</span>
<span class="org-comment-delimiter">;;;</span><span class="org-comment">--------------------------------------;;</span>

&gt; ,expand (doto (make-vector 2) 
            (vector-set! 0 'foo) 
            (vector-set! 1 'bar))
$2 = (<span class="org-keyword">let</span> ((obj (make-vector 2)))
  (vector-set! obj 0 'foo)
  (vector-set! obj 1 'bar)
  obj)
</pre>
</div>


<p>
<b>While Loop</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">while</span>
    (<span class="org-keyword">syntax-rules</span> ()
    ((_ condition expr ...)
     (<span class="org-keyword">let</span> <span class="org-function-name">loop</span> ()
         (<span class="org-keyword">if</span> condition
             (<span class="org-keyword">begin</span>
                   expr ...
         (loop)))))))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 0) 


&gt; (while (&lt; x 10)    
   (display x)    
   (newline)    
   (set! x (+ x 2)))
0
2
4
6
8

&gt; ,expand (while (&lt; x 10)    
   (display x)    
   (newline)    
   (set! x (+ x 2)))
$3 = (<span class="org-keyword">let</span> <span class="org-function-name">loop</span> ()
  (<span class="org-keyword">if</span> (&lt; x 10)
    (<span class="org-keyword">begin</span>
      (display x)
      (newline)
      (set! x (+ x 2))
      (loop))))
</pre>
</div>

<p>
<b>Common Lisp dolist and dotimes</b>
</p>

<p>
See also: <a href="http://www.gigamonkeys.com/book/macros-standard-control-constructs.html">Macros: Standard Control Constructs</a>
</p>

<ul class="org-ul">
<li>Dotimes
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">dotimes macro</span>
<span class="org-comment-delimiter">;; </span>
(define-syntax-rule
(dotimes (var value)  body)
(<span class="org-keyword">letrec</span>
    [
     (loop (<span class="org-keyword">lambda</span> (var)
             (<span class="org-keyword">if</span> (&lt; var value)
                 (<span class="org-keyword">begin</span> body (loop (+ var 1)))
                 (values))))]

  (loop 0)))

&gt; (dotimes (i 5)
       (<span class="org-keyword">begin</span> (display i) (display <span class="org-string">"\n"</span>)))
0
1
2
3
4

&gt; ,expand (dotimes (i 5) (<span class="org-keyword">begin</span> (display i) (display <span class="org-string">"\n"</span>)))
$7 = (<span class="org-keyword">let</span> <span class="org-function-name">loop</span> ((i 0))
  (<span class="org-keyword">if</span> (&lt; i 5)
    (<span class="org-keyword">begin</span>
      (<span class="org-keyword">begin</span> (display i) (display <span class="org-string">"\n"</span>))
      (loop (+ i 1)))
    (values)))
</pre>
</div>

<ul class="org-ul">
<li>Dolist
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">(dolist (&lt;var&gt; &lt;list&gt;) (&lt;body&gt;))</span>
<span class="org-comment-delimiter">;;</span>
(define-syntax-rule
    (dolist (var alist) body)
    (<span class="org-keyword">letrec</span>
        (
         (loop (<span class="org-keyword">lambda</span> (xs)
                 (<span class="org-keyword">if</span> (null? xs)
                     (values)
                     (<span class="org-keyword">let</span>
                         ((var (car xs)))
                       (<span class="org-keyword">begin</span>
                         body
                         (loop (cdr xs))))))))

      (loop alist)))

&gt; (dolist (i '(a b c d e))  (<span class="org-keyword">begin</span> (display i) (display <span class="org-string">"\n"</span>)))
a
b
c
d
e

&gt; ,expand (dolist (i '(a b c d e))  (<span class="org-keyword">begin</span> (display i) (display <span class="org-string">"\n"</span>)))
$8 = (<span class="org-keyword">let</span> <span class="org-function-name">loop</span> ((xs '(a b c d e)))
  (<span class="org-keyword">if</span> (null? xs)
    (values)
    (<span class="org-keyword">let</span> ((i (car xs)))
      (display i)
      (display <span class="org-string">"\n"</span>)
      (loop (cdr xs)))))
</pre>
</div>
</div>
</li>

<li><a id="sec-1-6-2-2" name="sec-1-6-2-2"></a>Common Lisp Style Macros - Define-macro<br  /><div class="outline-text-5" id="text-1-6-2-2">
<p>
<b>defun and defvar</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-macro</span> (<span class="org-variable-name">defun</span> name args body)
  `(<span class="org-keyword">define</span> (,name ,@args) ,body))

(<span class="org-keyword">define-macro</span> (<span class="org-variable-name">defvar</span> name value)
  `(<span class="org-keyword">define</span> ,name ,value))

(defun f (x y z) (+ (* 3 x) (* -4 y) (* 2 z)))

&gt; (f 5 6 3)
$119 = -3

&gt; (defvar x 10)

&gt; x
$120 = 10
scheme@(guile-user) [31]&gt; 


&gt; ,expand (defun f (x y z) (+ (* 3 x) (* -4 y) (* 2 z)))
$121 = (<span class="org-keyword">define</span> (<span class="org-function-name">f</span> x y z) (+ (* 3 x) (* -4 y) (* 2 z)))

&gt; ,expand (defvar x 10)
$122 = (<span class="org-keyword">define</span> <span class="org-function-name">x</span> 10)
</pre>
</div>

<p>
<b>case-pred</b>
</p>

<p>
Task: Design a macro that expands the syntax:
</p>

<pre class="example">
(case-pred x
   (negative? "Negative")
   (positive? "Positive")
   (zero?     "Zero"))
</pre>

<p>
To the syntax:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">cond</span> 
 ((negative? x) <span class="org-string">"Neg"</span>)
 ((positive? x) <span class="org-string">"Pos"</span>)
 ((zero? x)    <span class="org-string">"Zero"</span>))
</pre>
</div>

<p>
Implementation using define-syntax:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define-syntax</span> <span class="org-variable-name">case-pred</span>
    (<span class="org-keyword">syntax-rules</span> () 
     ((case-pred value (predicate result) ...)
      (<span class="org-keyword">cond</span> ((predicate value) result) ...))))

&gt; (case-pred -100
   (negative? <span class="org-string">"Negative"</span>)
   (positive? <span class="org-string">"Positive"</span>)
   (zero?     <span class="org-string">"Zero"</span>))
$6 = <span class="org-string">"Negative"</span>


&gt; (case-pred 100
   (negative? <span class="org-string">"Negative"</span>)
   (positive? <span class="org-string">"Positive"</span>)
   (zero?     <span class="org-string">"Zero"</span>))
$7 = <span class="org-string">"Positive"</span>

,expand (case-pred -100
   (negative? <span class="org-string">"Negative"</span>)
   (positive? <span class="org-string">"Positive"</span>)
   (zero?     <span class="org-string">"Zero"</span>))
$8 = (<span class="org-keyword">cond</span> ((negative? -100) <span class="org-string">"Negative"</span>)
      ((positive? -100) <span class="org-string">"Positive"</span>)
      ((zero? -100) <span class="org-string">"Zero"</span>))
</pre>
</div>

<p>
Implementation using define-macro:
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (<span class="org-keyword">define</span> <span class="org-function-name">body</span> '((negative? <span class="org-string">"Negative"</span>) (positive? <span class="org-string">"Positive"</span>) (zero? <span class="org-string">"Zero"</span>)))

&gt; body
((negative? <span class="org-string">"Negative"</span>) (positive? <span class="org-string">"Positive"</span>) (zero? <span class="org-string">"Zero"</span>))

&gt; (<span class="org-keyword">map</span> car body)
(negative? positive? zero?)


&gt; (<span class="org-keyword">map</span> cadr body)
(<span class="org-string">"Negative"</span> <span class="org-string">"Positive"</span> <span class="org-string">"Zero"</span>)

&gt; (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (row) `((,(car row) value) ,(cadr row))) body)
(((negative? value) <span class="org-string">"Negative"</span>) ((positive? value) <span class="org-string">"Positive"</span>) ((zero? value) <span class="org-string">"Zero"</span>))

&gt; (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (row) `((,(car row) ,value) ,(cadr row))) body)
(((negative? 10) <span class="org-string">"Negative"</span>) ((positive? 10) <span class="org-string">"Positive"</span>) ((zero? 10) <span class="org-string">"Zero"</span>))

(<span class="org-keyword">define</span> (<span class="org-function-name">template</span> value body)
  (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (row) `((,(car row) ,value) ,(cadr row))) body))

&gt; (template 20 body)
(((negative? 20) <span class="org-string">"Negative"</span>) ((positive? 20) <span class="org-string">"Positive"</span>) ((zero? 20) <span class="org-string">"Zero"</span>))


&gt; (template 'x body)
(((negative? x) <span class="org-string">"Negative"</span>) ((positive? x) <span class="org-string">"Positive"</span>) ((zero? x) <span class="org-string">"Zero"</span>))

&gt; `(<span class="org-keyword">cond</span> ,@(template 'x body))
(<span class="org-keyword">cond</span> ((negative? x) <span class="org-string">"Negative"</span>) ((positive? x) <span class="org-string">"Positive"</span>) ((zero? x) <span class="org-string">"Zero"</span>))

(<span class="org-keyword">define-macro</span> (<span class="org-variable-name">case-pred</span> value . body)  
  `(<span class="org-keyword">cond</span> 
      ,@(template value body)))


&gt; (case-pred 10
   (negative? <span class="org-string">"Negative"</span>)
   (positive? <span class="org-string">"Positive"</span>)
   (zero?     <span class="org-string">"Zero"</span>))
$2 = <span class="org-string">"Positive"</span>


&gt; (case-pred -100
   (negative? <span class="org-string">"Negative"</span>)
   (positive? <span class="org-string">"Positive"</span>)
   (zero?     <span class="org-string">"Zero"</span>))
$3 = <span class="org-string">"Negative</span>

<span class="org-string">&gt; ,expand (case-pred -100</span>
<span class="org-string">   (negative? "</span>Negative<span class="org-string">")</span>
<span class="org-string">   (positive? "</span>Positive<span class="org-string">")</span>
<span class="org-string">   (zero?     "</span>Zero<span class="org-string">"))</span>
<span class="org-string">$4 = (cond ((negative? -100) "</span>Negative<span class="org-string">")</span>
<span class="org-string">      ((positive? -100) "</span>Positive<span class="org-string">")</span>
<span class="org-string">      ((zero? -100) "</span>Zero<span class="org-string">"))</span>
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> S-expressions and Serialization</h3>
<div class="outline-text-3" id="text-1-7">
<p>
S-expressions advantages:
</p>

<ul class="org-ul">
<li>Encode Arbitrary data structure and programs
</li>
<li>Easy to serialize, read and write
</li>
<li>There is no need to write specific parsers for configuration files.
</li>
<li>Human Readable
</li>
<li>S-expression parsers can be embedded in static typed languages like Ocaml, Haskell, Java to create GUIs, read configuration files.
</li>
<li>Compact and flexible like XML and lightweight like json.
</li>
</ul>


<p>
See also:
</p>

<ul class="org-ul">
<li><a href="https://realworldocaml.org/v1/en/html/data-serialization-with-s-expressions.html">Real World OCaml - Chapter 17. Data Serialization with S-Expressions</a>
</li>
<li><a href="http://www.seomastering.com/wiki/Comparison_of_data_serialization_formats">Comparison of data serialization formats</a>
</li>
</ul>
</div>

<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> Association Lists and Property Lists</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li><a href="https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_12.html">https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_12.html</a>
</li>
<li><a href="http://people.cs.aau.dk/~normark/prog3-03/html/notes/fu-intr-1_themes-list-section.html">http://people.cs.aau.dk/~normark/prog3-03/html/notes/fu-intr-1_themes-list-section.html</a>
</li>

<li><a href="https://www.reddit.com/r/lisp/comments/2wancz/why_property_lists/">Why property lists?</a>
</li>
<li><a href="http://emacswiki.org/emacs/AlistVsPlist">AlistVsPlist - Emacs Wiki</a>
</li>
<li><a href="http://lamberta.github.io/minispec/list-structure.html">List Structures / Common Lisp MiniSpec</a>
</li>
</ul>


<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;;; </span><span class="org-comment">Association Lists</span>

(<span class="org-keyword">define</span> <span class="org-function-name">data</span> '((name:  <span class="org-string">"Canada"</span>)  
               (lang:  (English French)) 
               (domain: <span class="org-string">".ca"</span>) 
               (ISO3166code: <span class="org-string">"CA"</span>)))          

(<span class="org-keyword">define</span> (<span class="org-function-name">get-keys</span> assocl)
  (<span class="org-keyword">map</span> car assocl))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-values</span> assocl)
  (<span class="org-keyword">map</span> cadr assocl))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-key</span> key assocl)
  (cadr (assoc key assocl )))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-key/c</span> key)
  (<span class="org-keyword">lambda</span> (assocl) (cadr (assoc key assocl))))

&gt; data
((name: <span class="org-string">"Canada"</span>) (lang: (English French)) (domain: <span class="org-string">".ca"</span>) (ISO3166code: <span class="org-string">"CA"</span>))  

&gt; (get-key 'name: data)
<span class="org-string">"Canada"</span>

&gt; (get-key 'domain: data)
<span class="org-string">".ca"</span>

&gt; (get-keys data)
(name: lang: domain: ISO3166code:)

&gt; (get-values data)
(<span class="org-string">"Canada"</span> (English French) (<span class="org-string">".ca"</span>) (<span class="org-string">"CA"</span>))

&gt; (get-key/c 'name:)
 #&lt;procedure (? assocl)&gt;

&gt; ((get-key/c 'name:) data)
<span class="org-string">"Canada"</span>

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">make-record-constructor</span> fields)
  (<span class="org-keyword">lambda</span> (values)
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (f v) (list f v)) fields values)))


&gt; (make-record-constructor '(name: lang: domain: ISO3166code:))
 #&lt;procedure (? values)&gt;

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">make-country</span> (make-record-constructor 
    '(name: lang: domain: ISO3166code:)))

&gt; (make-country '(<span class="org-string">"Netherlands"</span> (Dutch) <span class="org-string">".nl"</span> <span class="org-string">"NL"</span>  EUR))
((name: <span class="org-string">"Netherlands"</span>) (lang: (Dutch)) (domain: <span class="org-string">".nl"</span>) (ISO3166code: <span class="org-string">"NL"</span>))


&gt; (get-values data)
(<span class="org-string">"Canada"</span> (English French) (<span class="org-string">".ca"</span>) (<span class="org-string">"CA"</span>))

&gt; (make-country (get-values data))
((name: <span class="org-string">"Canada"</span>) (lang: (English French)) (domain: <span class="org-string">".ca"</span>) (ISO3166code: <span class="org-string">"CA"</span>))

<span class="org-comment-delimiter">;;;;;;;;;;;; </span><span class="org-comment">Property Lists/ plist</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Lists like:  '(name: "John" surname: "Galt" age: 25 gender: male country: US)</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">In which every symbol has a metadata. </span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p1</span> '(name: <span class="org-string">"John"</span> surname: <span class="org-string">"Galt"</span> age: 25 gender: male country: US))

&gt; p1
(name: <span class="org-string">"John"</span> surname: <span class="org-string">"Galt"</span> age: 25 gender: male country: US)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Convert plist to association list</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">plist-&gt;assoc</span> plist)
  (<span class="org-keyword">if</span> (null? plist)
      '()      
      (cons
       (list (car plist) (cadr plist))
       (plist-&gt;assoc (cddr plist)))))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Convert association list to plist      </span>
(<span class="org-keyword">define</span> (<span class="org-function-name">assoc-&gt;plist</span> assocl)
(<span class="org-keyword">if</span> (null? assocl)
      '()
      (<span class="org-keyword">let</span>
          ((hd (car assocl))
           (tl (cdr assocl)))
        (cons (car hd)
           (cons (cadr hd)
                 (assoc-&gt;plist tl))))))       


&gt; (plist-&gt;assoc p1)
((name: <span class="org-string">"John"</span>) (surname: <span class="org-string">"Galt"</span>) (age: 25) (gender: male) (country: US))


&gt; (assoc-&gt;plist (plist-&gt;assoc p1))
(name: <span class="org-string">"John"</span> surname: <span class="org-string">"Galt"</span> age: 25 gender: male country: US)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> Serialization and Deserialization</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Convert plist to association list</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">plist-&gt;assoc</span> plist)
  (<span class="org-keyword">if</span> (null? plist)
      '()      
      (cons
       (list (car plist) (cadr plist))
       (plist-&gt;assoc (cddr plist)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-key/c</span> key)
  (<span class="org-keyword">lambda</span> (assocl) (cadr (assoc key assocl))))


(<span class="org-keyword">define</span> (<span class="org-function-name">sexp-&gt;string</span> sexp)
  (call-with-output-string
   (<span class="org-keyword">lambda</span> (out)
     (write sexp out))))

(<span class="org-keyword">define</span> (<span class="org-function-name">string-&gt;sexp</span> str)
  (with-input-from-string str
    (<span class="org-keyword">lambda</span> () (read))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sexp-&gt;file</span> filename sexp)
  (<span class="org-keyword">define</span> <span class="org-function-name">out</span> (open-output-file filename))
  (<span class="org-keyword">begin</span>
    (write sexp out)
    (close-output-port out)))

(<span class="org-keyword">define</span> (<span class="org-function-name">file-&gt;sexp</span> filename)
  (<span class="org-keyword">define</span> <span class="org-function-name">in</span> (open-input-file filename))
  (<span class="org-keyword">define</span> <span class="org-function-name">sexp</span> (read in))
  (<span class="org-keyword">begin</span>
    (close-input-port in)
    sexp))

(<span class="org-keyword">define</span> (<span class="org-function-name">read-file</span> file-name)
  (<span class="org-keyword">let</span> ((p (open-input-file file-name)))
    (<span class="org-keyword">let</span> <span class="org-function-name">loop</span>((ls1 '()) (c (read-char p)))
      (<span class="org-keyword">if</span> (eof-object? c)
  (<span class="org-keyword">begin</span>
    (close-input-port p)
    (list-&gt;string (reverse ls1)))
  (loop (cons c ls1) (read-char p))))))

(<span class="org-keyword">define</span> <span class="org-function-name">countries</span> '(
               (
                name: <span class="org-string">"Netherlands"</span>
                lang: (Dutch)
                capital: <span class="org-string">"Amsterdam"</span>
                domain: <span class="org-string">".nl"</span>
                ISO3166code: <span class="org-string">"NL"</span>
                currency: EUR
                )
               (
                name: <span class="org-string">"Australia"</span>
                lang: (English)
                capital: <span class="org-string">"Camberra"</span>
                domain: <span class="org-string">".au"</span>
                ISO3166code: <span class="org-string">"AU"</span>
                currency: AUD
                )
               (
                name: <span class="org-string">"Canada"</span>
                lang: (English French)
                domain: <span class="org-string">".ca"</span>
                ISO3166code: <span class="org-string">"CA"</span>
                currency: CAD
                )))

&gt; countries
((name: <span class="org-string">"Netherlands"</span> lang: (Dutch) capital: <span class="org-string">"Amsterdam"</span> domain: <span class="org-string">".nl"</span> ISO3166code: <span class="org-string">"NL"</span> currency: EUR) (name: <span class="org-string">"Australia"</span> lang: (English) capital: <span class="org-string">"Camberra"</span> domain: <span class="org-string">".au"</span> ISO3166code: <span class="org-string">"AU"</span> currency: AUD) (name: <span class="org-string">"Canada"</span> lang: (English French) domain: <span class="org-string">".ca"</span> ISO3166code: <span class="org-string">"CA"</span> currency: CAD))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Serialize Scheme data (list)</span>
<span class="org-comment-delimiter">;;</span>
&gt; (sexp-&gt;string countries)
<span class="org-string">"((name: \"Netherlands\" lang: (Dutch) capital: \"Amsterdam\" domain: \".nl\" ISO3166code: \"NL\" currency: EUR) (name: \"Australia\" lang: (English) capital: \"Camberra\" domain: \".au\" ISO3166code: \"AU\" currency: AUD) (name: \"Canada\" lang: (English French) domain: \".ca\" ISO3166code: \"CA\" currency: CAD))"</span>

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Deserialize</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> <span class="org-function-name">raw-data</span> (sexp-&gt;string countries))

7&gt; (string-&gt;sexp raw-data)
((name: <span class="org-string">"Netherlands"</span> lang: (Dutch) capital: <span class="org-string">"Amsterdam"</span> domain: <span class="org-string">".nl"</span> ISO3166code: <span class="org-string">"NL"</span> currency: EUR) (name: <span class="org-string">"Australia"</span> lang: (English) capital: <span class="org-string">"Camberra"</span> domain: <span class="org-string">".au"</span> ISO3166code: <span class="org-string">"AU"</span> currency: AUD) (name: <span class="org-string">"Canada"</span> lang: (English French) domain: <span class="org-string">".ca"</span> ISO3166code: <span class="org-string">"CA"</span> currency: CAD))

<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">Save to a file as text (List code)</span>
<span class="org-comment-delimiter">;;</span>
&gt; (sexp-&gt;file <span class="org-string">"countries.scdata"</span> countries)

&gt; (read-file <span class="org-string">"countries.scdata"</span>)
<span class="org-string">"((name: \"Netherlands\" lang: (Dutch) capital: \"Amsterdam\" domain: \".nl\" ISO3166code: \"NL\" currency: EUR) (name: \"Australia\" lang: (English) capital: \"Camberra\" domain: \".au\" ISO3166code: \"AU\" currency: AUD) (name: \"Canada\" lang: (English French) domain: \".ca\" ISO3166code: \"CA\" currency: CAD))"</span>


<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Read the s-expression from the file </span>
<span class="org-comment-delimiter">;;</span>
&gt; (file-&gt;sexp <span class="org-string">"countries.scdata"</span>)
((name: <span class="org-string">"Netherlands"</span> lang: (Dutch) capital: <span class="org-string">"Amsterdam"</span> domain: <span class="org-string">".nl"</span> ISO3166code: <span class="org-string">"NL"</span> currency: EUR) (name: <span class="org-string">"Australia"</span> lang: (English) capital: <span class="org-string">"Camberra"</span> domain: <span class="org-string">".au"</span> ISO3166code: <span class="org-string">"AU"</span> currency: AUD) (name: <span class="org-string">"Canada"</span> lang: (English French) domain: <span class="org-string">".ca"</span> ISO3166code: <span class="org-string">"CA"</span> currency: CAD))


&gt; (<span class="org-keyword">map</span> plist-&gt;assoc (file-&gt;sexp <span class="org-string">"countries.scdata"</span>))
(((name: <span class="org-string">"Netherlands"</span>) (lang: (Dutch)) (capital: <span class="org-string">"Amsterdam"</span>) (domain: <span class="org-string">".nl"</span>) (ISO3166code: <span class="org-string">"NL"</span>) (currency: EUR)) ((name: <span class="org-string">"Australia"</span>) (lang: (English)) (capital: <span class="org-string">"Camberra"</span>) (domain: <span class="org-string">".au"</span>) (ISO3166code: <span class="org-string">"AU"</span>) (currency: AUD)) ((name: <span class="org-string">"Canada"</span>) (lang: (English French)) (domain: <span class="org-string">".ca"</span>) (ISO3166code: <span class="org-string">"CA"</span>) (currency: CAD)))

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">dataset</span> (<span class="org-keyword">map</span> plist-&gt;assoc (file-&gt;sexp <span class="org-string">"countries.scdata"</span>)))

&gt; (<span class="org-keyword">map</span> (get-key/c name:) dataset)
(<span class="org-string">"Netherlands"</span> <span class="org-string">"Australia"</span> <span class="org-string">"Canada"</span>)

&gt; (<span class="org-keyword">map</span> (get-key/c currency:) dataset)
(EUR AUD CAD)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Debugging</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> MIT Scheme</h4>
<div class="outline-text-4" id="text-1-8-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>(pp &lt;object&gt;)</code></td>
<td class="left">Print source code of a procedure</td>
</tr>

<tr>
<td class="left"><code>(pa &lt;procedure&gt;)</code></td>
<td class="left">Print arguments of a procedure</td>
</tr>

<tr>
<td class="left"><code>(trace &lt;procedure&gt;)</code></td>
<td class="left">Trace procedure, function calls</td>
</tr>

<tr>
<td class="left"><code>(untrace &lt;procedure&gt;)</code></td>
<td class="left">No longer trace procedure</td>
</tr>

<tr>
<td class="left"><code>(apropos "&lt;string&gt;")</code></td>
<td class="left">Print matching bound names</td>
</tr>
</tbody>
</table>

<p>
<b>Examples</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap -c -S <span class="org-string">"&gt; "</span> --remember scheme
MIT/GNU Scheme running under GNU/Linux
Type `^C' (control-C) followed by `H' to obtain information about interrupts.

&gt; Copyright (C) 2011 Massachusetts Institute of Technology
This is free software<span class="org-comment-delimiter">; </span><span class="org-comment">see the source for copying conditions. There is NO</span>
warranty<span class="org-comment-delimiter">; </span><span class="org-comment">not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>

Image saved on Tuesday October 22, 2013 at 12:31:09 PM
  Release 9.1.1 <span class="org-string">||</span> Microcode 15.3 <span class="org-string">||</span> Runtime 15.7 <span class="org-string">||</span> SF 4.41 <span class="org-string">||</span> LIAR/i386 4.118
  Edwin 3.116



(<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n)
   (<span class="org-keyword">if</span> (= n 1)
       1
       (* n (factorial (- n 1)))))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: factorial</span>

&gt; (pp factorial)
(named-lambda (factorial n)
  (<span class="org-keyword">if</span> (= n 1)
      1
      (* n (factorial (- n 1)))))
<span class="org-comment-delimiter">;</span><span class="org-comment">Unspecified return value</span>


&gt; (pa factorial)
(n)
<span class="org-comment-delimiter">;</span><span class="org-comment">Unspecified return value</span>

&gt; (trace factorial)

<span class="org-comment-delimiter">;</span><span class="org-comment">Unspecified return value</span>


&gt; (factorial 5)

[Entering #[compound-procedure 14 factorial]
    Args: 5]
[Entering #[compound-procedure 14 factorial]
    Args: 4]
[Entering #[compound-procedure 14 factorial]
    Args: 3]
[Entering #[compound-procedure 14 factorial]
    Args: 2]
[Entering #[compound-procedure 14 factorial]
    Args: 1]
[1
      &lt;== #[compound-procedure 14 factorial]
    Args: 1]
[2
      &lt;== #[compound-procedure 14 factorial]
    Args: 2]
[6
      &lt;== #[compound-procedure 14 factorial]
    Args: 3]
[24
      &lt;== #[compound-procedure 14 factorial]
    Args: 4]
[120
      &lt;== #[compound-procedure 14 factorial]
    Args: 5]
<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 120</span>


&gt; (untrace factorial)

<span class="org-comment-delimiter">;</span><span class="org-comment">Unspecified return value</span>

&gt; (factorial 6)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 720</span>

&gt; 

&gt; (apropos <span class="org-string">"string-&gt;"</span>)

 #[package 11 (user)]
 #[package 12 ()]
bit-string-&gt;signed-integer
bit-string-&gt;unsigned-integer
camel-case-string-&gt;lisp
ctime-string-&gt;decoded-time
ctime-string-&gt;file-time
ctime-string-&gt;universal-time
iso8601-string-&gt;decoded-time
iso8601-string-&gt;file-time
iso8601-string-&gt;universal-time
lisp-string-&gt;camel-case
rfc2822-string-&gt;decoded-time
string-&gt;absolute-uri$ rlwrap -c -S <span class="org-string">"&gt; "</span> --remember scheme
MIT/GNU Scheme running under GNU/Linux
Type `^C' (control-C) followed by `H' to obtain information about interrupts.

&gt; Copyright (C) 2011 Massachusetts Institute of Technology
This is free software<span class="org-comment-delimiter">; </span><span class="org-comment">see the source for copying conditions. There is NO</span>
warranty<span class="org-comment-delimiter">; </span><span class="org-comment">not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>

Image saved on Tuesday October 22, 2013 at 12:31:09 PM
  Release 9.1.1 <span class="org-string">||</span> Microcode 15.3 <span class="org-string">||</span> Runtime 15.7 <span class="org-string">||</span> SF 4.41 <span class="org-string">||</span> LIAR/i386 4.118
  Edwin 3.116


string-&gt;alphabet
string-&gt;char-set
string-&gt;char-syntax
string-&gt;day-of-week
string-&gt;decoded-time
string-&gt;file-time
...
</pre>
</div>


<p>
See also:
</p>

<ul class="org-ul">
<li><a href="http://cs.wellesley.edu/~cs251/spring02/mit-scheme.pdf">MIT Scheme debugging</a>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> GNU Guile</h4>
<div class="outline-text-4" id="text-1-8-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>(version)</code></td>
<td class="left">Return version string</td>
</tr>

<tr>
<td class="left">=,bt=</td>
<td class="left">Backtrace, display call stack</td>
</tr>

<tr>
<td class="left">=,trace (&lt;procedure&gt; &lt;args&gt;)=</td>
<td class="left">Trace procedure, fucntion calls</td>
</tr>

<tr>
<td class="left">=,time &lt;exp&gt;=</td>
<td class="left">Measure execution time.</td>
</tr>

<tr>
<td class="left">=,expand &lt;form&gt;=</td>
<td class="left">Show macro expansion of <code>&lt;form&gt;</code></td>
</tr>

<tr>
<td class="left">=,apropos "&lt;string&gt;"=</td>
<td class="left">Print matching bound names</td>
</tr>

<tr>
<td class="left"><code>(exit 0)</code></td>
<td class="left">Quit GNU Guile</td>
</tr>
</tbody>
</table>


<p>
<b>Examples</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap -c -S <span class="org-string">"&gt; "</span> --remember guile
&gt; GNU Guile 2.0.11
Copyright (C) 1995-2014 Free Software Foundation, Inc.

Guile comes with ABSOLUTELY NO WARRANTY<span class="org-comment-delimiter">; </span><span class="org-comment">for details type `,show w'.</span>
This program is free software, and you are welcome to redistribute it
under certain conditions<span class="org-comment-delimiter">; </span><span class="org-comment">type `,show c' for details.</span>

Enter `,help' for help

&gt; (version)
$2 = <span class="org-string">"2.0.11"</span>
&gt; 

(<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n)
    (<span class="org-keyword">if</span> (= n 1)
        1
        (* n (factorial (- n 1)))))


&gt; ,trace (factorial 5)
trace: <span class="org-string">|  (#&lt;procedure 9a94210&gt; #(#&lt;directory (guile-user) 979b630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 979b630&gt; factorial)
trace: (#&lt;procedure 9aaa820 at &lt;current input&gt;:11:7 ()&gt;)
trace: (factorial 5)
trace: <span class="org-string">|  (factorial 4)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  (factorial 3)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  (factorial 2)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (factorial 1)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  1
trace: <span class="org-string">|  |</span>  <span class="org-string">|  2</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  6</span>
<span class="org-string">trace: |</span>  24
trace: 120
&gt; 

&gt; ,time (factorial 10)
$9 = 3628800
<span class="org-comment-delimiter">;; </span><span class="org-comment">0.001000s real time, 0.002000s run time.  0.000000s spent in GC.</span>
&gt; 


(define-syntax-rule (swap! x y) <span class="org-comment-delimiter">; </span><span class="org-comment">-! is idomatic for mutation</span>
    (<span class="org-keyword">let</span> ((tmp x))
    (set! x y)
    (set! y tmp)))

&gt; 
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">a</span> 10)
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">b</span> 20)
&gt; a
$1 = 10
&gt; b
$2 = 20

&gt; (swap! a b)
&gt; a
$3 = 20
&gt; b
$4 = 10
&gt; 

&gt; ,expand (swap! a b)
$6 = (<span class="org-keyword">let</span> ((tmp a)) (set! a b) (set! b tmp))
&gt; 

&gt; ,apropos <span class="org-string">"string-&gt;"</span>
(guile): string-&gt;char-set!  #&lt;procedure string-&gt;char-set! (_ _)&gt;
(guile): string-&gt;char-set   #&lt;procedure string-&gt;char-set (_ <span class="org-builtin">#:optional</span> _)&gt;
(guile): string-&gt;number #&lt;procedure string-&gt;number (_ <span class="org-builtin">#:optional</span> _)&gt;
(guile): string-&gt;symbol #&lt;procedure string-&gt;symbol (_)&gt;
(guile): string-&gt;list   #&lt;procedure string-&gt;list (_ <span class="org-builtin">#:optional</span> _ _)&gt;
(guile): string-&gt;obarray-symbol #&lt;procedure string-&gt;obarray-symbol (_ _ <span class="org-builtin">#:optional</span> _)&gt;
&gt; 

&gt; ,apropos <span class="org-string">"digit"</span>
(guile): char-set:hex-digit
(guile): char-set:letter+digit
(guile): char-set:digit
&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> SCIP</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Notes about SCIP
</p>


<p>
<b>Strategies to handle complexity</b>
</p>

<ul class="org-ul">
<li>Build Abstractions
</li>
<li>Hide Details
</li>
<li>Separate specification from implementation
</li>
<li>Stablishing conventional interfaces
</li>
<li>Standard Modules
</li>
</ul>
</div>


<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> Tail Recursion (Iteration)</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
The examples bellow are in GNU Guile.
</p>


<p>
Non tail recursive functions:
</p>

<ul class="org-ul">
<li>Uses a growing amount of stack frames, for a big number of iterations it can cause a stack overflow.
</li>
</ul>


<p>
Tail recursive functions:
</p>

<ul class="org-ul">
<li>A function is said to be <b>tail recursive</b> when the recursive call
is the last function executed in the body of the function.
</li>
<li>It uses a fixed amount stack frame, therefore there is no risk of
stack overflow.
</li>
<li>It can be turned into loops
</li>
<li>Sometimes non tail recursive functions can be changed to tail
recursive by adding a new function with extra parameters
(accumulators) to store partial results (state).
</li>
</ul>

<p>
Example1: Factorial
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (= n 0) (= n 1))
        1
        (* n  (factorial (- n 1)))))

&gt; (factorial 10)
$1 = 3628800
&gt; 

<span class="org-comment-delimiter">;;  </span><span class="org-comment">For a very big number of iterations, non tail recursive functions</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">will cause a stack overflow.</span>
<span class="org-comment-delimiter">;;</span>
&gt; (factorial 20000000)
warnings can be silenced by the --no-warnings (-n) option
Aborted (core dumped)

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">This execution requires 5 stack frames</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(factorial 5)</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (factorial 4))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (factorial 3)))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (3 * (factorial 2))))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (* 3 (factorial 2))))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (* 3 (* 2 (factorial 1)))))</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (* 3 (* 2 1))))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 (* 3 2)))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 (* 4 6))</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">(* 5 24)</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">120</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
&gt; ,trace (factorial 5)
trace: <span class="org-string">|  (#&lt;procedure 99450c0&gt; #(#&lt;directory (guile-user) 95c3630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 95c3630&gt; factorial)
trace: (#&lt;procedure 9953350 at &lt;current input&gt;:8:7 ()&gt;)
trace: (factorial 5)
trace: <span class="org-string">|  (factorial 4)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  (factorial 3)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  (factorial 2)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (factorial 1)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  1
trace: <span class="org-string">|  |</span>  <span class="org-string">|  2</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  6</span>
<span class="org-string">trace: |</span>  24
trace: 120
&gt; 

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">It requires 10 stack frames</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;        </span>
&gt; ,trace (factorial 10)
trace: <span class="org-string">|  (#&lt;procedure 985cbd0&gt; #(#&lt;directory (guile-user) 95c3630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 95c3630&gt; factorial)
trace: (#&lt;procedure 9880800 at &lt;current input&gt;:6:7 ()&gt;)
trace: (factorial 10)
trace: <span class="org-string">|  (factorial 9)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  (factorial 8)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  (factorial 7)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (factorial 6)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (factorial 5)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (factorial 4)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (factorial 3)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (factorial 2)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (factorial 1)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  1
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  2
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  6</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  24</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  120
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  720
trace: <span class="org-string">|  |</span>  <span class="org-string">|  5040</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  40320</span>
<span class="org-string">trace: |</span>  362880
trace: 3628800
&gt;        

(<span class="org-keyword">define</span> (<span class="org-function-name">factorial-aux</span> n acc)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (= n 0) (= n 1))
        acc
        (factorial-aux (- n 1) (* n acc))))

&gt; (factorial-aux 5 1)
$1 = 120
&gt; 
&gt; (factorial-aux 10 1)
$2 = 3628800
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">factorial2</span> n) (factorial-aux n 1))

&gt; (factorial2 5)
$3 = 120

&gt; (factorial2 10)
$4 = 3628800
&gt; 


<span class="org-comment-delimiter">;; </span><span class="org-comment">It only uses one stack frame</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>
&gt; ,trace (factorial-aux 5 1)
trace: <span class="org-string">|  (#&lt;procedure 85d6340&gt; #(#&lt;directory (guile-user) 82ca630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 82ca630&gt; factorial-aux)
trace: (#&lt;procedure 85eb910 at &lt;current input&gt;:10:7 ()&gt;)
trace: (factorial-aux 5 1)
trace: (factorial-aux 4 5)
trace: (factorial-aux 3 20)
trace: (factorial-aux 2 60)
trace: (factorial-aux 1 120)
trace: 120
&gt; 

&gt; ,trace (factorial-aux 10 1)
trace: <span class="org-string">|  (#&lt;procedure 8644730&gt; #(#&lt;directory (guile-user) 82ca630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 82ca630&gt; factorial-aux)
trace: (#&lt;procedure 8657a00 at &lt;current input&gt;:13:7 ()&gt;)
trace: (factorial-aux 10 1)
trace: (factorial-aux 9 10)
trace: (factorial-aux 8 90)
trace: (factorial-aux 7 720)
trace: (factorial-aux 6 5040)
trace: (factorial-aux 5 30240)
trace: (factorial-aux 4 151200)
trace: (factorial-aux 3 604800)
trace: (factorial-aux 2 1814400)
trace: (factorial-aux 1 3628800)
trace: 3628800
&gt;


<span class="org-comment-delimiter">;;; </span><span class="org-comment">Assembling all pieces of code </span>
<span class="org-comment-delimiter">;;</span>


(<span class="org-keyword">define</span> (<span class="org-function-name">factorial3</span> n) 
    (<span class="org-keyword">define</span> (<span class="org-function-name">factorial-aux</span> n acc)
        (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (= n 0) (= n 1))
            acc
            (factorial-aux (- n 1) (* n acc))))        
    (factorial-aux n 1))

&gt; (factorial3 4)
$2 = 24
&gt; (factorial3 5)
$3 = 120
&gt; (factorial3 10)
$4 = 3628800
&gt;
</pre>
</div>

<p>
Example 2: Summation
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">sum-ints</span> a b)
    (<span class="org-keyword">if</span> (&gt; a b)
        0
        (+ a (sum-ints (+ a 1) b))))

&gt; (sum-ints 1 10)
$5 = 55

&gt; (sum-ints 1 100)
$6 = 5050
&gt; 

<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">Stack Overflow Error</span>
<span class="org-comment-delimiter">;;</span>
&gt; (sum-ints 1 10000)
&gt; &lt;unnamed port&gt;:4:13: In procedure sum-ints:
&lt;unnamed port&gt;:4:13: Throw to key `vm-error' with args `(vm-run <span class="org-string">"VM: Stack overflow"</span> ())'.

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Using the trace command is possible to see the growing amount of stack frame</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">In this case it requires 11 stack frames.</span>

&gt; ,trace (sum-ints 1 10)
trace: <span class="org-string">|  (#&lt;procedure a415810&gt; #(#&lt;directory (guile-user) a00e630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) a00e630&gt; sum-ints)
trace: (#&lt;procedure a41abc0 at &lt;current input&gt;:10:7 ()&gt;)
trace: (sum-ints 1 10)
trace: <span class="org-string">|  (sum-ints 2 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  (sum-ints 3 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  (sum-ints 4 10)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (sum-ints 5 10)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (sum-ints 6 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (sum-ints 7 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (sum-ints 8 10)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  (sum-ints 9 10)
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (sum-ints 10 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  (sum-ints 11 10)</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  0</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  10
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  19
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  27</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  34</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  40
trace: <span class="org-string">|  |</span>  <span class="org-string">|  |</span>  45
trace: <span class="org-string">|  |</span>  <span class="org-string">|  49</span>
<span class="org-string">trace: |</span>  <span class="org-string">|  52</span>
<span class="org-string">trace: |</span>  54
trace: 55
&gt; 

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-ints-aux</span> a b acc)
    (<span class="org-keyword">if</span> (&gt; a b)
        acc
        (sum-ints-aux (+ a 1) b (+ a acc))))

&gt; (sum-ints-aux 1 10 0)
$4 = 55
&gt; 

<span class="org-comment-delimiter">;; </span><span class="org-comment">It didn't fail like before.</span>
<span class="org-comment-delimiter">;;</span>
&gt; (sum-ints-aux 1 10000 0)
$5 = 50005000
&gt; 

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">It uses only one stack frame each call</span>
<span class="org-comment-delimiter">;;</span>
&gt; ,trace (sum-ints-aux 1 10 0)
trace: <span class="org-string">|  (#&lt;procedure 985a270&gt; #(#&lt;directory (guile-user) 93fd630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 93fd630&gt; sum-ints-aux)
trace: (#&lt;procedure 98646a0 at &lt;current input&gt;:31:7 ()&gt;)
trace: (sum-ints-aux 1 10 0)
trace: (sum-ints-aux 2 10 1)
trace: (sum-ints-aux 3 10 3)
trace: (sum-ints-aux 4 10 6)
trace: (sum-ints-aux 5 10 10)
trace: (sum-ints-aux 6 10 15)
trace: (sum-ints-aux 7 10 21)
trace: (sum-ints-aux 8 10 28)
trace: (sum-ints-aux 9 10 36)
trace: (sum-ints-aux 10 10 45)
trace: (sum-ints-aux 11 10 55)
trace: 55
&gt; 

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-ints-safe</span> a b)
    (<span class="org-keyword">define</span> (<span class="org-function-name">sum-ints-aux</span> a b acc)
        (<span class="org-keyword">if</span> (&gt; a b)
            acc
            (sum-ints-aux (+ a 1) b (+ a acc))))    
    (sum-ints-aux a b 0))

&gt; (sum-ints-safe 1 10)
$6 = 55
&gt; (sum-ints-safe 1 100)
$7 = 5050
&gt; 

&gt; (sum-ints-safe 1 10000)
$8 = 50005000
&gt; 

&gt; (sum-ints-safe 1 100000)
&gt; $9 = 5000050000
&gt;
</pre>
</div>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Tail_call">Tail call - Wikipedia</a>
</li>

<li><a href="https://inst.eecs.berkeley.edu/~cs61a/fa14/assets/slides/28-Tail_Calls_8pp.pdf">Berkeley lecture - Tail calls</a>
</li>

<li><a href="http://web.info.uvt.ro/~mmarin/lectures/FP/lecture-05.pdf">Repetition through recursion. Tail-recursive function definitions</a>
</li>

<li><a href="http://www.owlnet.rice.edu/~comp210/96spring/Labs/lab09.html">Tail recursion and loops</a>
</li>

<li><a href="http://academic.udayton.edu/SaverioPerugini/courses/cps343/lecture_notes/CPS.html">CPS 343/543 Lecture notes: Tail calls and continuation-passing style</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> Higher Order Procedure</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
Higher order functions or procedures are a powerful abstraction mechanism.
</p>

<p>
Page 63. Summation
</p>

<pre class="example">
Summation:

 b=0
___
\     
/__   f(n) = f(a) + ... + f(b)
 n =a
 
Pi Sum 
 
 /8 = 1/1*3 + 1/5*7 + 1/9*11 + 1/13*15 + ...
</pre>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">summation</span> term next)

    (<span class="org-keyword">define</span> (<span class="org-function-name">summation_</span> term next a b)
        (<span class="org-keyword">if</span> (&gt; a b)
            0
            (+ (term a)
               (summation_ term next (next a) b))))

    (<span class="org-keyword">lambda</span> (a b) (summation_ term next a b))

) <span class="org-comment-delimiter">;; </span><span class="org-comment">End of summation</span>


(<span class="org-keyword">define</span> <span class="org-function-name">sum-cubes</span>     
     (summation 
        (<span class="org-keyword">lambda</span> (x) (* x x x))
        (<span class="org-keyword">lambda</span> (n) (+ n 1))
))

scheme@(guile-user)&gt; (sum-cubes 1 10)
$1 = 3025
scheme@(guile-user)&gt;   


(<span class="org-keyword">define</span> <span class="org-function-name">sum-integers</span>
    (summation
        (<span class="org-keyword">lambda</span> (x) x)          <span class="org-comment-delimiter">;; </span><span class="org-comment">Identity Function</span>
        (<span class="org-keyword">lambda</span> (n) (+ n 1))))


scheme@(guile-user) [1]&gt; (sum-integers 1 10)
$2 = 55

(<span class="org-keyword">define</span> <span class="org-function-name">pi-sum</span> 
    (summation
        (<span class="org-keyword">lambda</span> (x) (/ 1.0 (* x (+ x 2))))
        (<span class="org-keyword">lambda</span> (x) (+ x 4))))

scheme@(guile-user) [1]&gt; (* 8 (pi-sum 1 1000))
$4 = 3.139592655589783
</pre>
</div>

<p>
Integral of f from a to b
</p>

<pre class="example">
 a
  f = [f( a + dx/2) + f(a + 2dx/2) + f(a + 3dx/2) + f(a + 4dx/2) ...].dx
 b
</pre>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">integral</span> f dx)
    (<span class="org-keyword">lambda</span> (a b)
        (* dx 
           ((summation
            f
            (<span class="org-keyword">lambda</span> (x) (+ x dx)))
             (+ a (/ dx 2.0)) b))))

scheme@(guile-user) [1]&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Create a new function that computes the intergral from the cube function</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">from a to b</span>
<span class="org-comment-delimiter">;;</span>
scheme@(guile-user) [1]&gt; (<span class="org-keyword">define</span> <span class="org-function-name">integral-cube</span> (integral cube 0.01))

scheme@(guile-user)&gt; (integral-cube 0 1)
$2 = 0.24998750000000042
scheme@(guile-user)&gt; 

scheme@(guile-user)&gt; ((integral cube 0.001) 0 1)
$3 = 0.249999875000001

<span class="org-comment-delimiter">;; </span><span class="org-comment">This function is not tail recursive, it will fail for a big number of</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">iterations</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;;;;;;;;;;;;</span>
scheme@(guile-user) [1]&gt; ((integral cube 0.001) 0 1)
$1 = 0.249999875000001
scheme@(guile-user) [1]&gt; ((integral cube 0.0001) 0 1)
&lt;unnamed port&gt;:8:37: In procedure summation_:
&lt;unnamed port&gt;:8:37: Throw to key `vm-error' with args `(vm-run <span class="org-string">"VM: Stack overflow"</span> ())'.

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [2]&gt; ((integral cube 0.00001) 0 1)
rlwrap: warning: guile crashed, killed by SIGABRT (core dumped).
rlwrap itself has not crashed, but for transparency,
it will now kill itself with the same signal


warnings can be silenced by the --no-warnings (-n) option
Aborted (core dumped)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3"><span class="section-number-4">1.9.3</span> Procedure as returned value</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
<b>Fixed Point</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">tolerance</span> 0.0001)

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">abs(v1 -v2) &lt; tolerance</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">close-enough?</span> v1 v2)
        (&lt; (abs (- v1 v2)) tolerance)) 


(<span class="org-keyword">define</span> (<span class="org-function-name">fixed-point</span> f first-guess)

    (<span class="org-keyword">define</span> (<span class="org-function-name">try</span> guess)
        (<span class="org-keyword">let</span> ((next (f guess)))
            (<span class="org-keyword">if</span> (close-enough? guess next)
            next
            (try next))))

    (try first-guess))           

&gt;  (fixed-point cos 1.0)

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: .7390547907469174</span>

&gt;
</pre>
</div>


<p>
<b>Derivate Higher Order Function</b>
</p>

<pre class="example">
df(x) = (f(x +dx) - f(x))/dx
</pre>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">deriv</span> dx f) 
    (<span class="org-keyword">lambda</span> (x)
        (/  (- (f (+ x dx)) (f x)) dx)))

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))
&gt; 

 &gt; ((deriv 0.00001 cube) 5)
$26 = 75.00014999664018
&gt; 
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">dcube</span> (deriv 0.00001 cube))
&gt; 
&gt; (dcube 5)
$27 = 75.00014999664018
&gt;
</pre>
</div>

<p>
Newton Method 
</p>

<pre class="example">
f(x) = x  - g(x)/Dg(x)
</pre>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">newton-transform</span> g)
    (<span class="org-keyword">lambda</span> (x)
        (- 
            x
            (/ (g x) ((deriv 0.001 g) x)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">newton-method</span> g guess)
    (fixed-point (newton-transform g) guess))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt2</span> x)
    (newton-method (<span class="org-keyword">lambda</span> (y) (- (square x) x)) 1.0))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-4" class="outline-4">
<h4 id="sec-1-9-4"><span class="section-number-4">1.9.4</span> Exercises</h4>
<div class="outline-text-4" id="text-1-9-4">
<p>
<b>Exercise 1.3</b> 
</p>

<p>
The sum procedure above generates a linear recursion. The procedure
can be rewritten so that the sum is performed iteratively. Show how to
do this by filling in the missing expressions in the following
definition:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> a result)
    (<span class="org-keyword">if</span> <span class="org-type">&lt;??&gt;</span>
        <span class="org-type">&lt;??&gt;</span>
        (iter <span class="org-type">&lt;??&gt;</span> <span class="org-type">&lt;??&gt;</span>)))
  (iter <span class="org-type">&lt;??&gt;</span> <span class="org-type">&lt;??&gt;</span>))
</pre>
</div>


<p>
Solution: The assignment is asking to turn the function sum into a tail recursive function.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> a result)
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> n) (* n n n ))
&gt; 
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">sum-cubes</span> a b)
&gt;     (sum cube a inc b))
&gt; 
&gt; (sum-cubes 1 10)
$13 = 3025
&gt; 

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">As any tail recursive function, it uses a fixed amount of stack frames.</span>
<span class="org-comment-delimiter">;;</span>

&gt; ,trace (sum cube 1 inc 4)
trace: <span class="org-string">|  (#&lt;procedure 9cde860&gt; #(#&lt;directory (guile-user) 955f630&gt; &#8230;))</span>
<span class="org-string">trace: |</span>  #(#&lt;directory (guile-user) 955f630&gt; sum cube inc)
trace: (#&lt;procedure 9ce4910 at &lt;current input&gt;:72:7 ()&gt;)
trace: (sum #&lt;procedure cube (n)&gt; 1 #&lt;procedure inc (n)&gt; 4)
trace: <span class="org-string">|  (inc 1)</span>
<span class="org-string">trace: |</span>  2
trace: <span class="org-string">|  (cube 1)</span>
<span class="org-string">trace: |</span>  1
trace: <span class="org-string">|  (inc 2)</span>
<span class="org-string">trace: |</span>  3
trace: <span class="org-string">|  (cube 2)</span>
<span class="org-string">trace: |</span>  8
trace: <span class="org-string">|  (inc 3)</span>
<span class="org-string">trace: |</span>  4
trace: <span class="org-string">|  (cube 3)</span>
<span class="org-string">trace: |</span>  27
trace: <span class="org-string">|  (inc 4)</span>
<span class="org-string">trace: |</span>  5
trace: <span class="org-string">|  (cube 4)</span>
<span class="org-string">trace: |</span>  64
trace: 100
&gt;
</pre>
</div>

<p>
<b>Exercise 1.31.</b>
</p>

<p>
a.  The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.51 Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to using the formula 52.
</p>

<pre class="example">
/4 = 2/3 * 4/3 * 4/5 * 6/5 * 6/7 * 8/7 ...
</pre>

<p>
b.  If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process. 
</p>


<p>
Solution:
</p>

<p>
.a 
.b The function below is already tail recursive ( iterative process).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> a result)
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))


&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">id</span> n) n)
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))
&gt; 
&gt; (product id 1 inc 5)
$24 = 120
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n) (product id 1 inc n))

&gt; (factorial 5)
$25 = 120
&gt; (factorial 6)
$26 = 720
&gt;
</pre>
</div>


<p>
<b>Exercise 1.32.</b>  
</p>

<p>
a. Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:
</p>

<pre class="example">
(accumulate combiner null-value term a next b)
</pre>

<p>
Accumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate.
</p>

<p>
b. If your accumulate procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process. 
</p>

<p>
Solution:
</p>

<p>
a.
b. It is already tail recursive.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">accumulate</span> combiner null-value term a next b)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> a result)
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b) (accumulate + 0 term a next b))
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b) (accumulate * 1 term a next b))
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> n) (* n n n ))
&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">id</span> n) n)
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">sum-cubes</span> a b) (sum cube a inc b))
&gt;  (sum-cubes 1 10)
$1 = 3025
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n) (product id 1 inc n))

&gt; (factorial 5)
$2 = 120

&gt; (factorial 6)
$3 = 720
&gt;
</pre>
</div>

<p>
<b>Exercise 1.33.</b>  
</p>

<p>
You can obtain an even more general version of accumulate (exercise 1.32) by introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting filtered-accumulate abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the following using filtered-accumulate:
</p>

<p>
a. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a prime? predicate already written)
</p>

<p>
b. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i &lt; n such that GCD(i,n) = 1). 
</p>

<p>
Solution:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">filtered-accumulate</span> combiner null-value term a next b pred?)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> a result)
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (<span class="org-keyword">if</span> (pred? a) 
                           (combiner (term a) result)
                           result))))
  (iter a null-value))

(<span class="org-keyword">define</span> (<span class="org-function-name">divisor?</span> n) (<span class="org-keyword">lambda</span> (i) (= 0 (modulo n i))))

(<span class="org-keyword">define</span> (<span class="org-function-name">range</span> a b step)
  (<span class="org-keyword">if</span> (&gt; a b)
      '()
      (cons a  (range (+ a step) b step))))

(<span class="org-keyword">define</span> (<span class="org-function-name">prime?</span> n)
  (null? (filter (divisor? n) (range 2 (- n 1) 1))))

&gt; (filter prime? (range 1 100 1))
$8 = (1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)
&gt; 


<span class="org-comment-delimiter">;;;;;;;;; </span><span class="org-comment">Letter .a</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))
(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> n) (* n n))
(<span class="org-keyword">define</span> (<span class="org-function-name">id</span> n) n)


(<span class="org-keyword">define</span> (<span class="org-function-name">sum-of-square-primes</span> a b)
    (filtered-accumulate + 0 square a inc b prime?))

&gt; (sum-of-square-primes 1 10)
$9 = 88
&gt; 

&gt; (sum-of-square-primes 1 100)
$17 = 65797
&gt; 


&gt; (filter prime? (range 1 10 1))
$10 = (1 2 3 5 7)
&gt; (<span class="org-keyword">map</span> square (filter prime? (range 1 10 1)))
$11 = (1 4 9 25 49)
&gt; (apply + (<span class="org-keyword">map</span> square (filter prime? (range 1 10 1))))
$12 = 88
&gt; 

&gt; (<span class="org-keyword">define</span> (<span class="org-function-name">ssum-of-square-primes2</span> a b) (apply + (<span class="org-keyword">map</span> square (filter prime? (range a b 1)))))
&gt; 
&gt; (sum-of-square-primes2 10)
$14 = 88
&gt; (sum-of-square-primes2 1 100)
$15 = 65797
&gt; 

<span class="org-comment-delimiter">;;;;;;;;;   </span><span class="org-comment">letter b</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">relprime?</span> n) 
    (<span class="org-keyword">lambda</span> (i) (= (gcd i n) 1)))


(<span class="org-keyword">define</span> (<span class="org-function-name">product-primes</span> n)
    (filtered-accumulate * 1 id 1 inc (- n 1) (relprime? n)))

&gt; (filter (relprime? 18) (range 1 18 1))
$22 = (1 5 7 11 13 17)

&gt; (apply * (filter (relprime? 18) (range 1 18 1)))
$23 = 85085
&gt; 

&gt; (product-primes 18)
$24 = 85085
&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Applications</h3>
<div class="outline-text-3" id="text-1-10">
</div><div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1"><span class="section-number-4">1.10.1</span> Lisp Evaluator written in Lisp</h4>
<div class="outline-text-4" id="text-1-10-1">
<p>
Task: Write an s-expression evaluator (prefix notation evaluator)  in lisp without using eval function. This evaluator can be useful to execute untrusted code on a restricted environment.
</p>


<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">function-table</span>
  (list
   (cons 'cons cons)
   (cons  'car  car)
   (cons  'cdr  cdr)
   (cons 'list list)
   (cons '+ +)
   (cons '- -)
   (cons '* *)
   (cons '/ *)
   (cons '** expt)
   (cons 'expt expt)
   (cons 'sin sin)
   (cons 'cos cos)
   (cons 'tan tan)
   (cons 'exp exp)
   (cons 'sqrt sqrt)
   (cons 'sqr (<span class="org-keyword">lambda</span> (x) (* x x)))
   (cons 'log log)))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-key</span>  key assoclist)
      (cdr (assoc key assoclist)))

(<span class="org-keyword">define</span> (<span class="org-function-name">has-key?</span> key assoclist)
  (member key (<span class="org-keyword">map</span> car assoclist)))

(<span class="org-keyword">define</span> (<span class="org-function-name">func?</span> sym) (has-key? sym function-table))
(<span class="org-keyword">define</span> (<span class="org-function-name">func-dispatch</span> sym) (get-key sym function-table))

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Evaluate s-expressions in prefix notation</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">eval-prefix</span> expr)
  (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (number? expr) (string? expr) (null? expr))
      expr
      (<span class="org-keyword">let</span>  ((p (car expr)))

          (<span class="org-keyword">cond</span>
           ((list? p)  (eval-prefix p))
           ((func? p)(apply (func-dispatch p)
                       (<span class="org-keyword">map</span> eval-prefix (cdr expr)))))                          

         )<span class="org-comment-delimiter">;; </span><span class="org-comment">End let</span>
 ))<span class="org-comment-delimiter">;; </span><span class="org-comment">End of prefix-eval</span>




&gt; (eval-prefix '(+ 10 20 5 6))
$62 = 41

&gt; (eval-prefix '(+ (* 3 4) (* 7 8) (/ 5 (+ 4 1))))
$63 = 69

&gt; (eval-prefix 100)
$64 = 100

&gt; (eval-prefix 10)
$65 = 10

&gt; (eval-prefix '(+ (exp 2) (log 10) (cos (+ 2 3))))
$75 = 9.975303377387922

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">sexp</span>  '(+ (exp 2) (log 10) (cos (+ 2 3))))

&gt; sexp
$76 = (+ (exp 2) (log 10) (cos (+ 2 3)))

&gt; (eval-prefix sexp)
$77 = 9.975303377387922
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2"><span class="section-number-4">1.10.2</span> Reverse Polish Notation Evaluator</h4>
<div class="outline-text-4" id="text-1-10-2">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-stack</span>)   
  (<span class="org-keyword">define</span> <span class="org-function-name">stack</span> '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">show</span>) stack)
  (<span class="org-keyword">define</span> (<span class="org-function-name">top</span>) (car stack))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty?</span>)
    (null? stack))

  (<span class="org-keyword">define</span> (<span class="org-function-name">reset</span>)
    (set! stack '()))

  (<span class="org-keyword">define</span> (<span class="org-function-name">push</span> x)
    (set! stack (cons x stack)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">pop</span>)
    (<span class="org-keyword">let</span>
        ((p (car stack)))
      (<span class="org-keyword">begin</span>
        (set! stack (cdr stack))
        p)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">pop-all</span>)
    (<span class="org-keyword">let</span>
        ((p stack))
      (<span class="org-keyword">begin</span>
        (set! stack '())
        p)))
  (<span class="org-keyword">lambda</span> (selector . args)
    (<span class="org-keyword">case</span> selector
      ((show)    (apply show args))
      ((reset)   (apply reset args))
      ((push)    (apply push args))
      ((pop)     (apply pop args))
      ((top)    (apply top args))
      ((pop-all) (apply pop-all args)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">operator?</span> sym)
  (member sym '(+ - * / ^)))

(<span class="org-keyword">define</span> <span class="org-function-name">operators</span>
  (list (cons '+ +) (cons '- -) (cons '* *) (cons '/ /)))

(<span class="org-keyword">define</span> (<span class="org-function-name">operator-func</span> sym)
  (cdr (assoc sym operators)))

(<span class="org-keyword">define</span> <span class="org-function-name">functions-list</span>
  (list (cons 'sin sin)
        (cons 'cos cos)
        (cons 'exp exp)
        (cons 'expt expt)
        (cons 'log log)
        (cons 'sqrt sqrt)
        (cons 'sqr (<span class="org-keyword">lambda</span> (x) (* x x)))
        ))


(<span class="org-keyword">define</span> (<span class="org-function-name">function?</span> sym)
  (assoc sym functions-list))

(<span class="org-keyword">define</span> (<span class="org-function-name">find-function</span> sym)
  (cdr (assoc sym functions-list)))




(<span class="org-keyword">define</span> (<span class="org-function-name">evaluate-postfix</span> expr)

  (<span class="org-keyword">define</span> <span class="org-function-name">s</span> (make-stack))
  (<span class="org-keyword">define</span> (<span class="org-function-name">evaluate-function</span> expr)
    (s 'push ((find-function expr) (s 'pop))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">evaluate-operator</span> op)
    (<span class="org-keyword">let</span>
        ((a (s 'pop))
         (b (s 'pop))
         )
      (s 'push ((operator-func op) b a))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">evaluator</span> expr)
    (<span class="org-keyword">if</span> (null? expr)
        (s 'pop)
        (<span class="org-keyword">begin</span> 
          (<span class="org-keyword">cond</span>
           ((number? (car expr))    (s 'push (car expr)))
           ((operator? (car expr))  (evaluate-operator (car expr)))
           ((function? (car expr))  (evaluate-function (car expr))))

          (evaluator (cdr expr)))))

  (evaluator expr))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">10 + 20</span>
1 ]=&gt; (evaluate-postfix '( 10 20 +))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 30</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">10 + 20 * 30</span>
1 ]=&gt; (evaluate-postfix '( 10 20 30 * +))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 610</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">log 10</span>
 ]=&gt; (evaluate-postfix '(10 log))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 2.302585092994046</span>

<span class="org-comment-delimiter">;;; </span><span class="org-comment">exp (log 10)</span>

1 ]=&gt; (evaluate-postfix '(10 log exp))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 10.000000000000002</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">(exp 3) + 3 * (cos 4)</span>
<span class="org-comment-delimiter">;;</span>
1 ]=&gt; (evaluate-postfix '( 3 exp 3 4 cos * +))

<span class="org-comment-delimiter">;</span><span class="org-comment">Value: 18.124606060596836</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Scheme Implementations</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1"><span class="section-number-4">1.11.1</span> Racket</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
Racket, former known as PLT Scheme, is an extension of Scheme language
that has multi OS support, IDE: Dr. Racket, debugger, package system
and repository, great documentation, large library and a powerful
ffi - Foreign Function Interface. Racket has also support to many
languages like pure Scheme, typed racket and others.
</p>
</div>


<ol class="org-ol"><li><a id="sec-1-11-1-1" name="sec-1-11-1-1"></a>String Functions<br  /><div class="outline-text-5" id="text-1-11-1-1">
<p>
<b>Basic String Functions</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (string-&gt;list <span class="org-string">"hello world"</span>)
'(#\h #\e #\l #\l #\o #\space #\w #\o #\r #\l #\d)
&gt;

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">list-of-chars</span> (string-&gt;list <span class="org-string">"hello world"</span>))
&gt; list-of-chars
'(#\h #\e #\l #\l #\o #\space #\w #\o #\r #\l #\d)
&gt; 
(list-&gt;string list-of-chars)
<span class="org-string">"hello world"</span>
&gt; 


&gt; (string-length <span class="org-string">"0123456789"</span>)
10
&gt;
</pre>
</div>

<p>
<b>Format</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (format <span class="org-string">"x = ~a"</span> (sqrt (+ 40 10 50)))
<span class="org-string">"x = 10"</span>

&gt; (format <span class="org-string">"x = ~a"</span> '(sqrt (+ 40 10 50)))
<span class="org-string">"x = (sqrt (+ 40 10 50))"</span>

&gt; (format <span class="org-string">"~a = ~a\nxs = ~a\n"</span> '(sqrt (+ 90 10)) (sqrt (+ 90 10)) '(1 2 3 4 5 6))
<span class="org-string">"(sqrt (+ 90 10)) = 10\nxs = (1 2 3 4 5 6)\n"</span>

&gt; (display (format <span class="org-string">"~a = ~a\nxs = ~a\n"</span> '(sqrt (+ 90 10)) (sqrt (+ 90 10)) '(1 2 3 4 5 6)))
(sqrt (+ 90 10)) = 10
xs = (1 2 3 4 5 6)
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-2" name="sec-1-11-1-2"></a>Input / Output Functions<br  /><div class="outline-text-5" id="text-1-11-1-2">
<p>
<b>Display</b>
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (display 100)
100&gt; 

&gt; (display 20)
20&gt; 

&gt; (display 100)
100&gt; 

&gt; (display <span class="org-string">"Hello world racket"</span>)
Hello world racket&gt; 

&gt; (display <span class="org-string">"Hello world racket\n"</span>)
Hello world racket
&gt; 
&gt; (display '(1 2 3 4 5))
(1 2 3 4 5)&gt;
</pre>
</div>

<p>
<b>Displayln</b>
</p>

<p>
Print expression in the screen with character "\n" at the end.
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (displayln 100)
100

&gt; (displayln '(1 2 3 4 5))
(1 2 3 4 5)

&gt; (displayln "hello world racket")
hello world racket
&gt; 

&gt; (printf "x = ~a\n" '(sqrt (+ 40 10 50)))
x = (sqrt (+ 40 10 50))

&gt; (printf "~a = ~a\nxs = ~a\n" '(sqrt (+ 90 10)) (sqrt (+ 90 10)) '(1 2 3 4 5 6))
(sqrt (+ 90 10)) = 10
xs = (1 2 3 4 5 6)


&gt; (begin
  (displayln 10)
  (displayln "Testing display")
  (displayln "begin is to execute multiple s-expressions with side effects")
  (displayln 'a-symbol))
10
Testing display
begin is to execute multiple s-expressions with side effects
a-symbol
&gt; 

&gt; (for-each displayln 
    '[ 10 
      "Testing display" 
      "begin is to execute multiple s-expressions with side effects" 
      'a-symbol
    ])
10
Testing display
begin is to execute multiple s-expressions with side effects
(quote a-symbol)
&gt;
</pre>
</div>

<p>
<b>Printf</b>
</p>

<p>
Formated output.
</p>

<div class="org-src-container">

<pre class="src src-scheme">&gt; (printf <span class="org-string">"x = ~a\n"</span> (sqrt (+ 40 10 50)))
x = 10
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-3" name="sec-1-11-1-3"></a>Data Structures<br  /><ol class="org-ol"><li><a id="sec-1-11-1-3-1" name="sec-1-11-1-3-1"></a>Cons - Cell / Pair<br  /><div class="outline-text-6" id="text-1-11-1-3-1">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">(cons &lt;first&gt; &lt;second&gt;)</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">'( &lt;first&gt; . &lt;second&gt;)</span>


&gt; (cons 10 20)
'(10 . 20)

&gt; (cons 'a 100.23)
'(a . 100.23)

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p1</span> (cons 10 20))
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p2</span> (cons 'a 20))
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p3</span> (cons 'x '(+ 20 50)))

&gt; p1
'(10 . 20)
&gt; p2
'(a . 20)
&gt; p3
'(x + 20 50)
&gt; 

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Every cons cell or a list is a pair.</span>
<span class="org-comment-delimiter">;;</span>
&gt; (<span class="org-keyword">map</span> pair? (list p1 p2 p3))
'(#t #t #t)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Not all pairs is a list</span>
<span class="org-comment-delimiter">;;</span>
&gt; (<span class="org-keyword">map</span> list? (list p1 p2 p3))
'(#f #f #t)

<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">'(1 2 3 4) = (cons 1 '(2 3 4))</span>
<span class="org-comment-delimiter">;;</span>
&gt; (pair? '(1 2 3 4))
 #t
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-3-2" name="sec-1-11-1-3-2"></a>List<br  /><div class="outline-text-6" id="text-1-11-1-3-2">
<div class="org-src-container">

<pre class="src src-scheme">&gt; '(1 2 3 4 5 6)
'(1 2 3 4 5 6)

&gt; (quote (+ 2 3))
'(+ 2 3)
&gt; 

&gt; '[a b c d e f]
'(a b c d e f)

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">a</span> 10)
&gt; (<span class="org-keyword">define</span> <span class="org-function-name">b</span> 20)
&gt; (list 'a a 'b b)
'(a 10 b 20)
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-3-3" name="sec-1-11-1-3-3"></a>Association List<br  /></li>
<li><a id="sec-1-11-1-3-4" name="sec-1-11-1-3-4"></a>Vector<br  /><div class="outline-text-6" id="text-1-11-1-3-4">
<p>
<a href="http://docs.racket-lang.org/reference/vectors.html">Vector Documentation</a>
</p>

<div class="org-src-container">

<pre class="src src-racket">;; Make a vector
;-----------------------

&gt; (vector 1 2 3 4 )
'#(1 2 3 4)

&gt; (define v  (vector 1 2 3 4 ))

&gt; (make-vector 3)
'#(0 0 0)

&gt; (make-vector 3 'a)
'#(a a a)
&gt; 


;; Vector Length
;;--------------------
&gt; (vector-length v)
4
&gt; 

&gt; #(a b c d e)
'#(a b c d e)
&gt; 
&gt; #(1 2 3 4 )
'#(1 2 3 4)
&gt; 

;;; Test if it is a vector.

&gt; (vector? v)
 #t
&gt; 
&gt; (vector? '(1 2 3 ))
 #f
&gt; 

;;;; Pick the nth element 
;--------------------------
&gt; (vector-ref v 0)
1
&gt; (vector-ref v 1)
2
&gt; (vector-ref v 2)
3
&gt; (vector-ref v 3)
4
&gt; (vector-ref v 5)
vector-ref: index is out of range
  index: 5
  valid range: [0, 3]
  vector: '#(1 2 3 4)
&gt; 

;; List Vector / Transformations
;-------------------------

&gt; (vector-&gt;list #(a 1 b 2 c 3))
'(a 1 b 2 c 3)
&gt; 

&gt; (list-&gt;vector '(a 1 b 2 c 3))
'#(a 1 b 2 c 3)


;;; Map a vector
;--------------------------
&gt; (define (f x) (* 3 x))
&gt; 

&gt; v
'#(1 2 3 4)
&gt; 
&gt; (vector-map f v)
'#(3 6 9 12)
&gt; 


&gt; (vector-map 
   (lambda (x y) (+ (* 3 x) (* 2 y)))
   #(1 2 3 4 5) #(5 4 3 2 1))
'#(13 14 15 16 17)
&gt; 

;; Zip
;;-------------------------

&gt; (map vector  '(1 2 3 4) '(a b c d))
'(#(1 a) #(2 b) #(3 c) #(4 d))


&gt; (map vector '(1 2 3 4 ) '(a b c d) '("x" "y" "z" "w"))
'(#(1 a "x") #(2 b "y") #(3 c "z") #(4 d "w"))
&gt; 

&gt; (define-syntax-rule
    (zipm xs ...)
    (map vector xs ...))

&gt; (zipm '(1 2 3) '(a b c))
'(#(1 a) #(2 b) #(3 c))

&gt; (zipm '(1 2 3) '(a b c) '("x" "y" "z"))
'(#(1 a "x") #(2 b "y") #(3 c "z"))


;; Set a  vector element
;;---------------------------

&gt; (define v1 (make-vector 3))
&gt; v1
'#(0 0 0)
&gt; 

&gt; (vector-set! v1 0 'a)
&gt; v1
'#(a 0 0)
&gt; (vector-set! v1 1 343.34)
&gt; v1
'#(a 343.34 0)
&gt; (vector-set! v1 2 "test")
&gt; v1
'#(a 343.34 "test")
&gt; 

;; Append Vectors
;;--------------------------

&gt; (vector-append #(a b c) #(w x y z))
'#(a b c w x y z)
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-3-5" name="sec-1-11-1-3-5"></a>Hash Table<br  /></li></ol>
</li>
<li><a id="sec-1-11-1-4" name="sec-1-11-1-4"></a>Struct<br  /><div class="outline-text-5" id="text-1-11-1-4">
<div class="org-src-container">

<pre class="src src-scheme">(defstruct point-3d (x y z))
defstruct: undefined<span class="org-comment-delimiter">;</span>
 cannot reference undefined identifier
&gt; 

&gt; (struct point-3d (x y z))

&gt; (point-3d 10 20 30)
 #&lt;point-3d&gt;

&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p1</span> (point-3d 10 20 30))


&gt; (<span class="org-keyword">define</span> <span class="org-function-name">p2</span> (apply point-3d '(20 30 40)))
&gt; p1
 #&lt;point-3d&gt;
&gt; p2
 #&lt;point-3d&gt;

&gt; (point-3d-x p1)
10
&gt; (point-3d-y p1)
20
&gt; (point-3d-z p1)
30
&gt; 

&gt; (defstruct point-3d (x y z))
defstruct: undefined<span class="org-comment-delimiter">;</span>
 cannot reference undefined identifier
&gt; 

(struct point-3d (x y z))
&gt; 

(point-3d 10 20 30)
 #&lt;point-3d&gt;
&gt; 
(<span class="org-keyword">define</span> <span class="org-function-name">p1</span> (point-3d 10 20 30))
&gt; 

(<span class="org-keyword">define</span> <span class="org-function-name">p2</span> (apply point-3d '(20 30 40)))
&gt; p1
 #&lt;point-3d&gt;
&gt; p2
 #&lt;point-3d&gt;

&gt; (point-3d-x p1)
10
&gt; (point-3d-y p1)
20
&gt; (point-3d-z p1)
30
&gt; 

&gt; (<span class="org-keyword">map</span> point-3d-x (list p1 p2))
'(10 20)

&gt; (point-3d? p2)
 #t
&gt; (point-3d? '(1 2 4))
 #f
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-5" name="sec-1-11-1-5"></a>Pattern Matching<br  /><div class="outline-text-5" id="text-1-11-1-5">
<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="http://plt.eecs.northwestern.edu/snapshots/current/doc/reference/match.html">Pattern Matching</a>
</li>

<li><a href="http://www.ccs.neu.edu/home/samth/match-ifl-full.pdf">Extensible Pattern Matching in an Extensible Language</a>
</li>

<li><a href="http://docs.racket-lang.org/guide/match.html">Racket Guide - Pattern Matching</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">(require racket/match)

(<span class="org-keyword">define</span> (<span class="org-function-name">perimeter</span> picture)
    (match picture
        [(list 'triangle a b c)   (+ a b c)]
        [(list 'rectangle a b)    (* 2 (+ a b))]
        [(list 'circle r)         (* 2 pi r)]))

&gt; (perimeter '(triangle 3 4 5))
12
&gt; (perimeter '(rectangle 3 4))
14
&gt; (perimeter '(circle 3))
18.84955592153876
&gt; 

&gt; (perimeter '(x 3))
match: no matching clause for '(x 3)
&gt; 

&gt; (<span class="org-keyword">map</span> perimeter
    '[(triangle 3 4 5)
      (rectangle 3 4)
      (circle 3)])
'(12 14 18.84955592153876)


<span class="org-comment-delimiter">;;; </span><span class="org-comment">List recursive functions with pattern matching</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">--------------------------------------------------</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">count-list</span> alist)
    (match alist
        ['()            0]
        [(cons hd tl)   (+ 1 (count-list tl))]))

&gt; (count-list '(a b c d ))
4
&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-6" name="sec-1-11-1-6"></a>Plotting<br  /><div class="outline-text-5" id="text-1-11-1-6">
<p>
Racket has a rich built-in plot library.
</p>

<p>
<a href="http://docs.racket-lang.org/plot/intro.html#(part._.Plotting_2.D_.Graphs)">Documentation</a>
</p>

<p>
<b>Plot a function</b>
</p>

<div class="org-src-container">

<pre class="src src-racket"> #lang racket
(require plot)
(plot-new-window? #t)
(plot (function exp -2 2))
</pre>
</div>


<div class="figure">
<p><img src="images/chart_exp_racket.png" alt="chart_exp_racket.png" />
</p>
</div>


<p>
<b>Plot Points</b>
</p>

<div class="org-src-container">

<pre class="src src-racket"> #lang racket
(require plot)
(plot-new-window? #t)

&gt; (define xys '[#(-2 4) #(-1 1) #(0 0) #(1 1) #(2 4) #(3 9) #(4 16) #(5 25) ])
&gt; 
&gt; (require plot)
&gt; (plot (points xys))
&gt;
</pre>
</div>


<div class="figure">
<p><img src="images/chart_points_racket.png" alt="chart_points_racket.png" />
</p>
</div>


<p>
<b>Plot Lines between points</b>
</p>

<div class="org-src-container">

<pre class="src src-racket"> #lang racket
(require plot)
(plot-new-window? #t)

&gt; (define xys '[#(-2 4) #(-1 1) #(0 0) #(1 1) #(2 4) #(3 9) #(4 16) #(5 25) ])
&gt; 
&gt; (require plot)
&gt; (plot (lines xys))
&gt;
</pre>
</div>


<div class="figure">
<p><img src="images/chart_lines_points_racket.png" alt="chart_lines_points_racket.png" />
</p>
</div>

<p>
<b>Parametric Plot</b>
</p>

<p>
Example: Parametric Equation of an Ellipse
</p>

<ul class="org-ul">
<li>See also: <a href="http://jwilson.coe.uga.edu/EMAT6680Fa09/Yun/jyun_assign10/Parametric_eq_yun.html">Parametric Equation</a>
</li>
</ul>

<pre class="example">
x^2/a^2 + y^2/b^2 = 1

x = a cos(t)
y = b sin(t)

Plot the equation:  x^2/9 + y^2/64 = 1
</pre>

<div class="org-src-container">

<pre class="src src-racket"> #lang racket
(require plot)
(plot-new-window? #t)

 ;;; Ellipse function factory 
 ;;; 
 ;;; ellip-xy :: num -&gt; num -&gt; (num -&gt; (vector [num num]))
 ;;;              a      b       t
 ;;;
(define (ellipse a b)
   (lambda (t) (vector (* a (cos t)) (* b (sin t)))))

(plot (parametric [ellipse 3 8] 0 (* 2 pi)))
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-1-7" name="sec-1-11-1-7"></a>Resources<br  /><ol class="org-ol"><li><a id="sec-1-11-1-7-1" name="sec-1-11-1-7-1"></a>Miscellaneous<br  /><div class="outline-text-6" id="text-1-11-1-7-1">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Racket_(programming_language">Racket programming language</a>)
</li>
<li><a href="https://en.wikipedia.org/wiki/Racket_features">Racket Features / Wikipedia</a>
</li>

<li><a href="http://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-1-Intro.pdf">Introduction to Racket Advanced Functional Programming Jean-Nol Monette - November 2013</a>
</li>

<li><a href="http://jpolitz.github.io/blog/2012/11/21/racket-contributing-tutorial.html">Tutorial: Contributing to Racket</a>
</li>

<li><a href="http://youngracketeer.blogspot.com.br/2013/01/learning-resources.html">Stories of a young Racketeer / Learning Resources</a>
</li>

<li><a href="https://cs.uwaterloo.ca/~plragde/tyr/Impure_Functional_Programming.html">Impure Functional Programming</a>
</li>

<li><a href="http://qerub.se/using-racket-to-configure-apache">Using Racket to Configure Apache</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-11-1-7-2" name="sec-1-11-1-7-2"></a>Documentation<br  /><div class="outline-text-6" id="text-1-11-1-7-2">
<ul class="org-ul">
<li><a href="http://www.racket-lang.org/download/">Download</a>
</li>
<li><a href="http://docs.racket-lang.org/guide/modules.html">Modules</a>
</li>

<li><a href="http://docs.racket-lang.org/reference/pairs.html?q=list#(def._((quote._~23~25kernel)._list))">Pairs and Lists</a>
</li>

<li><a href="http://docs.racket-lang.org/guide/hash-tables.html">Hash Tables / Guide</a>
</li>
<li><a href="http://docs.racket-lang.org/reference/hashtables.html">Hash  Tables / Reference</a>
</li>
</ul>
</div>
</li></ol>
</li>

<li><a id="sec-1-11-1-8" name="sec-1-11-1-8"></a>Videos<br  /><div class="outline-text-5" id="text-1-11-1-8">
<ul class="org-ul">
<li><a href="https://vimeo.com/6630691">Scribble: Closing the Book on Ad Hoc Documentation Tools</a>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2"><span class="section-number-4">1.11.2</span> Kawa Scheme - Access Java API from Scheme</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
<a href="http://www.gnu.org/software/kawa">Kawa Scheme</a> is a implementation of the language in Java that can compile to Java bytecodes and has access to the Java API.
</p>

<p>
Features:
</p>

<ul class="org-ul">
<li>Compiles to JVM
</li>
<li>Can be embedded as  scripting language for Java applications.
</li>
<li>Can call Java API in the REPL, provides interactive Java development.
</li>
<li>With some tricks can compile to Android "Java", Dalvik VM.
</li>
<li>Product built with Kawa Scheme: <a href="https://en.wikipedia.org/wiki/App_Inventor_for_Android">App Inventor for Android</a>
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-1-11-2-1" name="sec-1-11-2-1"></a>Install and Run<br  /><div class="outline-text-5" id="text-1-11-2-1">
<pre class="example">
$ curl -O ftp://ftp.gnu.org/pub/gnu/kawa/kawa-2.0.jar

$ java -jar kawa-2.0.jar 
#|kawa:1|# 
#|kawa:2|# 

$ java -jar kawa-2.0.jar 
#|kawa:1|# 

#|kawa:2|# (+ 1 2 3 4 5 6)
21

#|kawa:3|# (define (foldl f_el_acc acc alist)
    (if (null? alist)
        acc
        (foldl f_el_acc (f_el_acc acc (car alist)) (cdr alist))))
#|kawa:7|# (foldl (lambda (el acc) (+ (* 10 el)  acc)) 0 '(1 2 3 4 5 6))
123456
#|kawa:8|#
</pre>
</div>
</li>


<li><a id="sec-1-11-2-2" name="sec-1-11-2-2"></a>Calling Java Methods in Kawa Scheme<br  /><div class="outline-text-5" id="text-1-11-2-2">
<p>
Apis Used:
</p>

<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html">java.lang.Math</a>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html">java.util.Date</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme"> $ rlwrap java -jar kawa-2.0.jar 

 <span class="org-comment">#|kawa:9|#</span> (kawa.Version:getVersion)
 2.0
 <span class="org-comment">#|kawa:10|#</span> 

 <span class="org-comment">#|kawa:27|#</span>  (invoke java.lang.System:out 'println <span class="org-string">"\n   Hello world\n"</span>)

    Hello world


 <span class="org-comment">#|kawa:66|#</span> (java.lang.System:getProperties)
 {java.runtime.name=OpenJDK Runtime Environment, sun.boot.library.path=/usr/lib/jvm/java-7-openjdk-i386/jre/lib/i386, java.vm.version=24.79-b02, user.country.format=BR, java.vm.vendor=Oracle Corporation, java.vendor.url=http://java.oracle.com/, path.separator=:, java.vm.name=OpenJDK Server VM, file.encoding.pkg=sun.io, user.country=US, sun.java.launcher=SUN_STANDARD, sun.os.patch.level=unknown, java.vm.specification.name=Java Virtual Machine Specification, user.dir=/home/tux/PycharmProjects/scheme, java.runtime.version=1.7.0_79-b14, java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment, java.endorsed.dirs=/usr/lib/jvm/java-7-openjdk-i386/jre/lib/endorsed, os.arch=i386, java.io.tmpdir=/tmp, line.separator=


 <span class="org-comment">#|kawa:69|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">p</span> (java.lang.System:getProperties))
 <span class="org-comment">#|kawa:70|#</span> p

 <span class="org-comment">#|kawa:72|#</span> (p:getProperty <span class="org-string">"java.version"</span>)
 /dev/stdin:72:2: warning - no known slot 'getProperty' in java.lang.Object
 1.7.0_79


 <span class="org-comment">#|kawa:84|#</span> (p:getProperty <span class="org-string">"java.home"</span>)
 /dev/stdin:84:2: warning - no known slot 'getProperty' in java.lang.Object
 /usr/lib/jvm/java-7-openjdk-i386/jre
 <span class="org-comment">#|kawa:85|#</span> 
 <span class="org-comment">#|kawa:86|#</span> 


 <span class="org-comment">#|kawa:87|#</span> (p:getProperty <span class="org-string">"java.class.path"</span>)
 /dev/stdin:87:2: warning - no known slot 'getProperty' in java.lang.Object
 /opt/kawa.jar


 <span class="org-comment">#|kawa:88|#</span> (p:getProperty <span class="org-string">"java.library.path"</span>)
 /dev/stdin:88:2: warning - no known slot 'getProperty' in java.lang.Object
 /usr/java/packages/lib/i386:/usr/lib/i386-linux-gnu/jni:/lib/i386-linux-gnu:/usr/lib/i386-linux-gnu:/usr/lib/jni:/lib:/usr/lib


 <span class="org-comment">#|kawa:91|#</span> (p:getProperty <span class="org-string">"java.library.path"</span>)
 /dev/stdin:91:2: warning - no known slot 'getProperty' in java.lang.Object
 /usr/java/packages/lib/i386:/usr/lib/i386-linux-gnu/jni:/lib/i386-linux-gnu:/usr/lib/i386-linux-gnu:/usr/lib/jni:/lib:/usr/lib

 <span class="org-comment-delimiter">;;   </span><span class="org-comment">// this will list the current system properties</span>
 <span class="org-comment-delimiter">;;   </span><span class="org-comment">Properties p = System.getProperties();</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">p.list(System.out);</span>
 <span class="org-comment-delimiter">;;</span>
 <span class="org-comment">#|kawa:98|#</span> (p:list java.lang.System:out)
 /dev/stdin:98:2: warning - no known slot 'list' in java.lang.Object
 -- listing properties --
 java.runtime.name=OpenJDK Runtime Environment
 sun.boot.library.path=/usr/lib/jvm/java-7-openjdk-i386/jre/...
 java.vm.version=24.79-b02
 user.country.format=BR
 java.vm.vendor=Oracle Corporation
 java.vendor.url=http://java.oracle.com/
 path.separator=:
 java.vm.name=OpenJDK Server VM
 file.encoding.pkg=sun.io
 user.country=US
 sun.java.launcher=SUN_STANDARD
 sun.os.patch.level=unknown
 java.vm.specification.name=Java Virtual Machine Specification
 user.dir=/home/tux/PycharmProjects/scheme
 java.runtime.version=1.7.0_79-b14

 <span class="org-comment-delimiter">;; </span><span class="org-comment">Which Java is being used openjdk-java? or  Oracle-java ??</span>
 <span class="org-comment-delimiter">;;</span>
 <span class="org-comment">#|kawa:101|#</span> 
 <span class="org-comment">#|kawa:102|#</span> (p:getProperty <span class="org-string">"java.runtime.name"</span>)
 /dev/stdin:102:2: warning - no known slot 'getProperty' in java.lang.Object
 OpenJDK Runtime Environment
 <span class="org-comment">#|kawa:103|#</span> (p:getProperty <span class="org-string">"java.vm.name"</span>)
 /dev/stdin:103:2: warning - no known slot 'getProperty' in java.lang.Object
 OpenJDK Server VM
 <span class="org-comment">#|kawa:104|#</span> 


 <span class="org-comment">#|kawa:1|#</span> 
 <span class="org-comment">#|kawa:2|#</span> (java.lang.Math:sqrt 9.0)
 3.0
 <span class="org-comment">#|kawa:3|#</span> (java.lang.Math:log10 100.0)
 2.0
 <span class="org-comment">#|kawa:4|#</span> (java.lang.Math:log10 1000.0)
 3.0

 <span class="org-comment">#|kawa:9|#</span> (<span class="org-keyword">define</span> (<span class="org-function-name">log10</span> x ) (java.lang.Math:log10 x))
 <span class="org-comment">#|kawa:10|#</span> 
 <span class="org-comment">#|kawa:11|#</span> (log10 100)
 2.0
 <span class="org-comment">#|kawa:12|#</span> (log10 1000)
 3.0
 <span class="org-comment">#|kawa:13|#</span> 

 <span class="org-comment">#|kawa:13|#</span> (<span class="org-keyword">map</span> log10 '(10 100 1000 1000))
 (1.0 2.0 3.0 3.0)
 <span class="org-comment">#|kawa:14|#</span> 

 <span class="org-comment-delimiter">;;;  </span><span class="org-comment">java.util.Date </span>
 <span class="org-comment-delimiter">;;;</span><span class="org-comment">----------------------------</span>

 <span class="org-comment">#|kawa:28|#</span> (java.util.Date )
 Thu Aug 20 09:44:57 BRT 2015
 <span class="org-comment">#|kawa:29|#</span> 
 <span class="org-comment">#|kawa:30|#</span> 

 <span class="org-comment">#|kawa:30|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">today</span> (java.util.Date))
 <span class="org-comment">#|kawa:31|#</span> today
 Thu Aug 20 09:45:37 BRT 2015
 <span class="org-comment">#|kawa:32|#</span> 

 <span class="org-comment">#|kawa:38|#</span> (today:getTime)
 /dev/stdin:38:2: warning - no known slot 'getTime' in java.lang.Object
 1440074737071
 <span class="org-comment">#|kawa:39|#</span> 

 <span class="org-comment">#|kawa:40|#</span> (today:getMonth)
 /dev/stdin:40:2: warning - no known slot 'getMonth' in java.lang.Object
 7
 <span class="org-comment">#|kawa:41|#</span> 

 <span class="org-comment">#|kawa:41|#</span> (today:toString)
 Thu Aug 20 09:45:37 BRT 2015
 <span class="org-comment">#|kawa:42|#</span>

 <span class="org-comment-delimiter">;;; </span><span class="org-comment">Java.util.Calendar</span>
 <span class="org-comment-delimiter">;;;</span><span class="org-comment">--------------------------------------</span>

 <span class="org-comment">#|kawa:2|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">Calendar</span> java.util.Calendar)
 <span class="org-comment">#|kawa:3|#</span> 


 <span class="org-comment">#|kawa:5|#</span> (Calendar:getInstance)
 java.util.GregorianCalendar[time=1440075518905,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=<span class="org-string">"America/Recife"</span>,offset=-10800000,dstSavings=0,useDaylight=false,transitions=41,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2015,MONTH=7,WEEK_OF_YEAR=34,WEEK_OF_MONTH=4,DAY_OF_MONTH=20,DAY_OF_YEAR=232,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=9,HOUR_OF_DAY=9,MINUTE=58,SECOND=38,MILLISECOND=905,ZONE_OFFSET=-10800000,DST_OFFSET=0]
 <span class="org-comment">#|kawa:6|#</span> 


 <span class="org-comment">#|kawa:44|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">cal</span> (Calendar:getInstance))
 <span class="org-comment">#|kawa:45|#</span> 

 <span class="org-comment">#|kawa:9|#</span> cal
 java.util.GregorianCalendar[time=1440075574190,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=<span class="org-string">"America/Recife"</span>,offset=-10800000,dstSavings=0,useDaylight=false,transitions=41,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2015,MONTH=7,WEEK_OF_YEAR=34,WEEK_OF_MONTH=4,DAY_OF_MONTH=20,DAY_OF_YEAR=232,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=9,HOUR_OF_DAY=9,MINUTE=59,SECOND=34,MILLISECOND=190,ZONE_OFFSET=-10800000,DST_OFFSET=0]
 <span class="org-comment">#|kawa:10|#</span> 


 <span class="org-comment">#|kawa:16|#</span> (cal:get Calendar:ERA)
 /dev/stdin:16:2: warning - no known slot 'get' in java.lang.Object
 /dev/stdin:16:10: warning - no known slot 'ERA' in java.lang.Object
 1
 <span class="org-comment">#|kawa:17|#</span> 


 <span class="org-comment">#|kawa:51|#</span> (cal:get Calendar:DATE)
 /dev/stdin:51:2: warning - no known slot 'get' in java.lang.Object
 20
 <span class="org-comment">#|kawa:52|#</span> 

 <span class="org-comment">#|kawa:14|#</span> (cal:getTime)
 Thu Aug 20 09:59:34 BRT 2015
 <span class="org-comment">#|kawa:15|#</span> 

 <span class="org-comment">#|kawa:17|#</span> (cal:toString)
 java.util.GregorianCalendar[time=1440075574190,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=<span class="org-string">"America/Recife"</span>,offset=-10800000,dstSavings=0,useDaylight=false,transitions=41,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2015,MONTH=7,WEEK_OF_YEAR=34,WEEK_OF_MONTH=4,DAY_OF_MONTH=20,DAY_OF_YEAR=232,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=9,HOUR_OF_DAY=9,MINUTE=59,SECOND=34,MILLISECOND=190,ZONE_OFFSET=-10800000,DST_OFFSET=0]
 <span class="org-comment">#|kawa:18|#</span> 

 <span class="org-comment">#|kawa:18|#</span> (cal:getTimeZone)
 /dev/stdin:18:2: warning - no known slot 'getTimeZone' in java.lang.Object
 sun.util.calendar.ZoneInfo[id=<span class="org-string">"America/Recife"</span>,offset=-10800000,dstSavings=0,useDaylight=false,transitions=41,lastRule=null]
 <span class="org-comment">#|kawa:19|#</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-2-3" name="sec-1-11-2-3"></a>Create a GUI<br  /><div class="outline-text-5" id="text-1-11-2-3">
<p>
<b>Create a GUI in the REPL</b>
</p>


<div class="figure">
<p><img src="images/java_swing_window1.png" alt="java_swing_window1.png" />
</p>
</div>

<p>
Original Java Code: <a href="http://www.wideskills.com/java-tutorial/java-swing-tutorial">Java Swing Tutorial</a>
</p>

<p>
Int the REPL:
</p>

<div class="org-src-container">

<pre class="src src-scheme">$ rlwrap java -jar kawa-2.0.jar 
<span class="org-comment">#|kawa:1|#</span> 

<span class="org-comment">#|kawa:4|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">JFrame</span> javax.swing.JFrame)
<span class="org-comment">#|kawa:5|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">JLabel</span> javax.swing.JLabel)
<span class="org-comment">#|kawa:6|#</span> 

<span class="org-comment">#|kawa:10|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">jlbHelloWorld</span> (JLabel))

<span class="org-comment">#|kawa:7|#</span> (<span class="org-keyword">define</span> <span class="org-function-name">HelloWorldFrame</span> (JFrame))
<span class="org-comment">#|kawa:8|#</span> HelloWorldFrame
javax.swing.JFrame[frame0,0,0,0x0,invalid,hidden,layout=java.awt.BorderLayout,title=,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,0,0x0,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]
<span class="org-comment">#|kawa:9|#</span> 


<span class="org-comment">#|kawa:13|#</span> jlbHelloWorld
javax.swing.JLabel[,0,0,0x0,invalid,alignmentX=0.0,alignmentY=0.0,border=,flags=8388608,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,horizontalAlignment=LEADING,horizontalTextPosition=TRAILING,iconTextGap=4,labelFor=,text=,verticalAlignment=CENTER,verticalTextPosition=CENTER]
<span class="org-comment">#|kawa:14|#</span> 

<span class="org-comment">#|kawa:18|#</span> (HelloWorldFrame:add jlbHelloWorld)
/dev/stdin:18:2: warning - no known slot 'add' in java.lang.Object
javax.swing.JLabel[,0,0,0x0,invalid,alignmentX=0.0,alignmentY=0.0,border=,flags=8388608,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,horizontalAlignment=LEADING,horizontalTextPosition=TRAILING,iconTextGap=4,labelFor=,text=Hello World Kawa,verticalAlignment=CENTER,verticalTextPosition=CENTER]
<span class="org-comment">#|kawa:19|#</span> 

<span class="org-comment">#|kawa:22|#</span> (HelloWorldFrame:setSize 100 100)
/dev/stdin:22:2: warning - no known slot 'setSize' in java.lang.Object
#!null

<span class="org-comment">#|kawa:23|#</span> (HelloWorldFrame:setVisible #t)
/dev/stdin:23:2: warning - no known slot 'setVisible' in java.lang.Object
#!null
<span class="org-comment">#|kawa:24|#</span>
</pre>
</div>

<p>
In the file: <i>java_swing_gui1.scm</i>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">Creates Java GUI</span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Similar to: http://www.wideskills.com/java-tutorial/java-swing-tutorial </span>
<span class="org-comment-delimiter">;; </span>
(<span class="org-keyword">define</span> <span class="org-function-name">JFrame</span> javax.swing.JFrame)
(<span class="org-keyword">define</span> <span class="org-function-name">JLabel</span> javax.swing.JLabel)

(<span class="org-keyword">define</span> <span class="org-function-name">jlbHelloWorld</span> (JLabel <span class="org-string">"Hello World Kawa"</span>))

(<span class="org-keyword">define</span> <span class="org-function-name">HelloWorldFrame</span> (JFrame))

(HelloWorldFrame:add jlbHelloWorld)
(HelloWorldFrame:setSize 100 100)
(HelloWorldFrame:setVisible #t)
</pre>
</div>

<p>
Run the file:
</p>

<pre class="example">
$ java -jar kawa-2.0.jar java_swing_gui1.scm
</pre>

<p>
<b>Temperature Conversion GUI</b>
</p>


<div class="figure">
<p><img src="images/temperature_conversion_gui.png" alt="temperature_conversion_gui.png" />
</p>
</div>

<p>
File: <i>FahrenheitGUI.scm</i>
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">Must be used with Kawa</span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Based on: http://www.cs.dartmouth.edu/~cs5/lectures/0509/FahrenheitGUI.java </span>
<span class="org-comment-delimiter">;; </span>
<span class="org-comment-delimiter">;;</span>
<span class="org-comment-delimiter">;;</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">import java.awt.*;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">import java.awt.event.*;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">import javax.swing.*;</span>
<span class="org-comment-delimiter">;;</span>

(<span class="org-keyword">define</span> <span class="org-function-name">JFrame</span> javax.swing.JFrame)
(<span class="org-keyword">define</span> <span class="org-function-name">JLabel</span> javax.swing.JLabel)
(<span class="org-keyword">define</span> <span class="org-function-name">JPanel</span> javax.swing.JPanel)
(<span class="org-keyword">define</span> <span class="org-function-name">JTextField</span> javax.swing.JTextField)

(<span class="org-keyword">define</span> <span class="org-function-name">WIDTH</span> 300)
(<span class="org-keyword">define</span> <span class="org-function-name">HEIGHT</span> 75)

(<span class="org-keyword">define</span> (<span class="org-function-name">fahrenheit2celcius</span> f) (* (- f 32.0) (/ 5.0 9.0)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">frame = new JFrame("Temperature Conversion");</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> <span class="org-function-name">frame</span> (JFrame <span class="org-string">"Temperature Conversion"</span>))

<span class="org-comment-delimiter">;;</span><span class="org-comment">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span>
<span class="org-comment-delimiter">;;</span>
(frame:setDefaultCloseOperation JFrame:EXIT_ON_CLOSE)

(<span class="org-keyword">define</span> <span class="org-function-name">inputLabel</span> (JLabel <span class="org-string">"Enter Fahrenheit temperature (Hit Return to Compute the temperature):"</span>))

<span class="org-comment-delimiter">;;</span><span class="org-comment">JLabel outputLabel = new JLabel("Temperature in Celsius: ") </span>
(<span class="org-keyword">define</span> <span class="org-function-name">outputLabel</span> (JLabel <span class="org-string">"Temperature in Celsius: "</span>)) 

(<span class="org-keyword">define</span> <span class="org-function-name">resultLabel</span> (JLabel <span class="org-string">"---"</span>))  

<span class="org-comment-delimiter">;; </span><span class="org-comment">fahrenheit = new JTextField(5); </span>
<span class="org-comment-delimiter">;; </span>
(<span class="org-keyword">define</span> <span class="org-function-name">fahrenheit</span> (JTextField 5))  

<span class="org-comment-delimiter">;; </span><span class="org-comment">panel = new JPanel(); </span>
<span class="org-comment-delimiter">;; </span>
(<span class="org-keyword">define</span> <span class="org-function-name">panel</span> (JPanel))

<span class="org-comment-delimiter">;; </span><span class="org-comment">panel.setPreferredSize(new Dimension(WIDTH, HEIGHT));</span>
(panel:setPreferredSize (java.awt.Dimension WIDTH HEIGHT))
(panel:setBackground java.awt.Color:yellow)

<span class="org-comment-delimiter">;;</span><span class="org-comment">(panel:setPreferredSize (new Dimension(WIDTH, HEIGHT))</span>

(panel:add inputLabel)
(panel:add fahrenheit)
(panel:add outputLabel)
(panel:add resultLabel)
(frame:add panel)
(frame:pack)

(<span class="org-keyword">define</span> <span class="org-function-name">show_frame</span> (<span class="org-keyword">lambda</span> () (frame:setVisible #t)))


(<span class="org-keyword">define</span> (<span class="org-function-name">update-temperature</span>)   
   (resultLabel:setText 
     (number-&gt;string (fahrenheit2celcius (string-&gt;number (fahrenheit:getText))))))

(define-namespace ActionListener <span class="org-type">&lt;java.awt.event.ActionListener&gt;</span>)
(define-namespace ActionEvent <span class="org-type">&lt;java.awt.event.ActionEvent&gt;</span>)


<span class="org-comment-delimiter">; </span><span class="org-comment">; fahrenheit.addActionListener(new TempListener());    </span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">(frame:addActionListener (lambda (evt) (update-temperature)))</span>
<span class="org-comment-delimiter">;;</span>
(<span class="org-keyword">define</span> <span class="org-function-name">action-listener</span>
  (object (ActionListener)
    ((action-performed e <span class="org-builtin">::</span> ActionEvent) <span class="org-builtin">::</span> <span class="org-type">&lt;void&gt;</span>
      (update-temperature))))

(fahrenheit:addActionListener action-listener)

(show_frame)
</pre>
</div>
</div>
</li>

<li><a id="sec-1-11-2-4" name="sec-1-11-2-4"></a>See also<br  /><div class="outline-text-5" id="text-1-11-2-4">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Kawa_(Scheme_implementation">Kawa Scheme Implementation - Wikipedia</a>
</li>

<li><a href="https://lwn.net/Articles/623349/">Kawa  fast scripting on the Java platform</a>
</li>

<li><a href="http://www.redmountainsw.com/wordpress/1395/kawa-scheme-and-event-handlers/">Kawa scheme and event handlers</a>
</li>

<li><a href="http://www.infoq.com/articles/lisp-for-jvm">Exploring LISP on the JVM</a>
</li>
<li><a href="http://pjacobsson.com/articles/lisp-on-the-jvm.html">EXPLORING LISP ON THE JVM</a>
</li>

<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.5572&rep=rep1&type=pdf">Kawa: Compiling Scheme to Java - citeseerx</a>
</li>
<li><a href="http://www.delorie.com/gnu/docs/kawa/kawa-tour_2.html">Kawa: Compiling Scheme to Java - Delorie</a>
</li>
</ul>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> Resources</h3>
<div class="outline-text-3" id="text-1-12">
</div><div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1"><span class="section-number-4">1.12.1</span> Books</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
<b>Scheme</b>
</p>

<ul class="org-ul">
<li><a href="http://www.phyast.pitt.edu/~micheles/scheme/index.html">The Adventures of a Pythonista in Schemeland</a>
</li>

<li><a href="http://download.plt-scheme.org/doc/205/pdf/t-y-scheme.pdf">Teach Yourself Scheme in Fixnum Days - Dorai Sitaram, 19982003</a>
</li>

<li><a href="https://mitpress.mit.edu/sicp/">Structure and Interpretation of Computer Programs - SCIP / Abelson, Sussman, and Sussman.</a>
</li>
<li><a href="http://www.bookshelf.jp/texi/sicp/sicp_toc.html#SEC_Contents">Structure and Interpretation of Computer Programs - SCIP / Abelson, Sussman, and Sussman / Alternative Link</a>
</li>

<li><a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/">Structure and Interpretation of Computer Programs - Video Lectures by Hal Abelson and Gerald Jay Sussman</a>
</li>

<li><a href="http://community.schemewiki.org/?SICP-Solutions">SCIP Solutions</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="https://mitpress.mit.edu/books/structure-and-interpretation-classical-mechanics">Structure and Interpretation of Classical Mechanics - Geral Jay Sussman and Jack Wisdom</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://www.scheme.com/tspl2d/">The Scheme Programming Language, Second Edition - R. Kent Dybvig</a>
</li>

<li><a href="http://download.plt-scheme.org/doc/360/html/t-y-scheme/t-y-scheme-Z-H-1.html">Teach Yourself Scheme in Fixnum Day</a>
</li>

<li><a href="http://htdp.org/">How to Design Programs - by Felleisen, Findler, Flatt and Krishnamurthi</a>
</li>

<li><a href="https://en.wikibooks.org/wiki/Scheme_Programming">Wikibok - Programming with Scheme</a>
</li>

<li><a href="http://www.scheme.com/tspl4/">The Scheme Programming Language Fourth Edition - R. Kent Dybvig - Illustrations by Jean-Pierre Hbert</a>
</li>

<li><a href="https://mitpress.mit.edu/books/little-schemer">The Little Schemer, fourth edition</a>
</li>

<li><a href="http://pleac.sourceforge.net/pleac_guile/index.html">PLEAC GUILE Cookbook</a>
</li>

<li><a href="http://www.schemers.org/Documents/#all-texts">Schemers.org Textbook selection</a>
</li>
</ul>

<p>
<b>Common Lisp</b>
</p>

<ul class="org-ul">
<li><a href="http://lamberta.github.io/minispec/list-structure.html">Common Lisp MiniSpec</a>
</li>

<li><a href="http://cl-cookbook.sourceforge.net/macros.html">The Common Lisp Cookbook - Macros and Backquote</a>
</li>

<li><a href="http://learnxinyminutes.com/docs/common-lisp/">Learn X in Y minutes</a>
</li>

<li><a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>
</li>

<li><a href="http://unintelligible.org/onlisp/onlisp.html">On Lisp - by Paul Graham</a>
</li>
<li><a href="http://www.bookshelf.jp/texi/onlisp/onlisp.html">On Lisp - by Paul Graham / Alternative Link</a>
</li>

<li><a href="http://norvig.com/paip.html">Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2"><span class="section-number-4">1.12.2</span> Community</h4>
<div class="outline-text-4" id="text-1-12-2">
<ul class="org-ul">
<li><a href="http://www.schemers.org/">http://www.schemers.org/</a>
</li>
<li><a href="http://www.reddit.com/r/scheme">http://www.reddit.com/r/scheme</a>
</li>
<li><a href="http://www.reddit.com/r/racket">http://www.reddit.com/r/racket</a>
</li>
<li><a href="http://srfi.schemers.org">http://srfi.schemers.org</a>
</li>

<li><a href="http://www.cliki.net">The common lisp wiki</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-3" class="outline-4">
<h4 id="sec-1-12-3"><span class="section-number-4">1.12.3</span> Articles</h4>
<div class="outline-text-4" id="text-1-12-3">
<ul class="org-ul">
<li><a href="http://www.paulgraham.com/avg.html">Beating the Average - The Secret Weapon - By Paul Graham</a>
</li>

<li><a href="https://www.cs.berkeley.edu/~bh/sicp.html">Why Structure and Interpretation of Computer Programs matters</a>
</li>

<li><a href="http://matt.might.net/articles/implementing-a-programming-language/">7 lines of code, 3 minutes: Implement a programming language from scratch</a>
</li>
</ul>


<ul class="org-ul">
<li>[IBM - The art of metaprogramming, Part 1: Introduction to metaprogramming
</li>
</ul>
<p>
Write programs to generate other programs](<a href="http://www.ibm.com/developerworks/library/l-metaprog1/">http://www.ibm.com/developerworks/library/l-metaprog1/</a>)
</p>


<ul class="org-ul">
<li><a href="http://norvig.com/design-patterns/design-patterns.pdf">Design Patterns in Dynamic Programming - Peter Norvig Chief Designer, Adaptive Systems Harlequin Inc.</a>
</li>

<li><a href="https://kuomarc.wordpress.com/2012/01/27/why-i-love-common-lisp-and-hate-java/">Why I love Common Lisp and hate Java</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-4" class="outline-4">
<h4 id="sec-1-12-4"><span class="section-number-4">1.12.4</span> Blogs, Workshops, Conferences</h4>
<div class="outline-text-4" id="text-1-12-4">
<ul class="org-ul">
<li><a href="http://racket-metaprogramming.com/">Racket Metaprogramming</a>
</li>

<li><a href="https://jaortega.wordpress.com/category/scheme/">Programming Musings</a>
</li>

<li><a href="http://www.schemeworkshop.org/">Scheme and Functional Programming Workshop</a>
</li>

<li><a href="http://people.csail.mit.edu/jhbrown/scheme/">Advanced Scheme: Some Naughty Bits</a>
</li>

<li><a href="http://www.wisdomandwonder.com/link/1910/why-should-programmers-care-about-currying-in-practice-in-scheme">Why should programmers care about currying in practice in Scheme?</a>
</li>

<li><a href="http://calculist.blogspot.com.br/2008/10/clojure-metadata.html">The Little Calculist - DAVE HERMAN'S RESEARCH BLOG</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://www.blogbyben.com/2009/08/plt-scheme-gui-accessor-pattern.html">http://www.blogbyben.com/2009/08/plt-scheme-gui-accessor-pattern.html</a>
</li>

<li><a href="http://www.blogbyben.com/2008/04/tackling-desktop-gui-project-consider.html">http://www.blogbyben.com/2008/04/tackling-desktop-gui-project-consider.html</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-5" class="outline-4">
<h4 id="sec-1-12-5"><span class="section-number-4">1.12.5</span> University Courses</h4>
<div class="outline-text-4" id="text-1-12-5">
<ul class="org-ul">
<li><a href="https://www.cs.unm.edu/~williams/cs491s06.html">CS 491/591: Advanced Scheme Programming and Implementation *</a>
</li>

<li><a href="http://www.iro.umontreal.ca/%CB%9Cfeeley/cours/ift3065-ift6232/">Cours IFT3065/IFT6232, Hiver 2012 - University of Montreal in French</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-6" class="outline-4">
<h4 id="sec-1-12-6"><span class="section-number-4">1.12.6</span> Repositories</h4>
<div class="outline-text-4" id="text-1-12-6">
<ul class="org-ul">
<li><a href="https://github.com/scheme-requests-for-implementation">scheme-requests-for-implementation</a>
</li>

<li><a href="https://github.com/mpacula/Scheme-Power-Tools">Scheme Power Tools - Github</a>
</li>

<li><a href="https://github.com/propella/abcsx">The ActionScript Byte Code assembler / disassembler in PLT Scheme and Gauche</a>
</li>

<li><a href="https://gitlab.com/cloje/cloje">Cloje - A clone of Clojure built atop Scheme/Lisp</a>
</li>

<li><a href="http://sourceforge.net/projects/readable/"> Readable Lisp S-expressions - Readable Lisp/S-expressions with infix, functions, and indentation</a>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-12-7" class="outline-4">
<h4 id="sec-1-12-7"><span class="section-number-4">1.12.7</span> Misc</h4>
<div class="outline-text-4" id="text-1-12-7">
<ul class="org-ul">
<li><a href="http://hyperpolyglot.org/lisp">Hyperpolyglot / Lisp: Common Lisp, Racket, Clojure, Emacs Lisp</a>
</li>
<li><a href="http://courses.cs.washington.edu/courses/cse341/10sp/notes/transition.html">Scheme/ML Comparison</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://c2.com/cgi/wiki?LispSchemeDifferences">Lisp Scheme Differences</a>
</li>

<li><a href="http://srfi.schemers.org/">Scheme Requests for Implementation</a>
</li>

<li><a href="http://arxiv.org/pdf/1305.4584.pdf">Functional Package Management with Guix</a>
</li>

<li><a href="https://pavpanchekha.com/blog/adtscm.html">Algebraic Data Types in Scheme</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://www.ccs.neu.edu/home/stamourv/papers/picobit.pdf">PICOBIT: A Compact Scheme System for Microcontrollers Vincent St-Amour and Marc Feeley</a>
</li>
<li><a href="http://cs.northwestern.edu/~ian/grl-paper.pdf">Functional Programming of Behavior-Based Systems Ian Douglas Horswill</a>
</li>
<li><a href="http://www.ijcai.org/Past%20Proceedings/IJCAI-91-VOL1/PDF/034.pdf">Composing Real-Time Systems</a>
</li>

<li><a href="https://google.github.io/styleguide/lispguide.xml">Google Common Lisp Style Guide</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-8" class="outline-4">
<h4 id="sec-1-12-8"><span class="section-number-4">1.12.8</span> Documentation by Subject</h4>
<div class="outline-text-4" id="text-1-12-8">
</div><ol class="org-ol"><li><a id="sec-1-12-8-1" name="sec-1-12-8-1"></a>Manual<br  /><div class="outline-text-5" id="text-1-12-8-1">
<ul class="org-ul">
<li><a href="https://www.gnu.org/software/guile/manual/">GNU Guile 2.0.11 Reference Manual</a>
</li>

<li><a href="http://sicp.ai.mit.edu/Fall-2004/manuals/scheme-7.5.5/doc/scheme_toc.html">MIT/GNU Scheme Reference Manual</a>
</li>

<li><a href="http://www.s48.org/1.9.2/manual/manual.html">The Incomplete Scheme 48 Reference Manual for release 1.9.2</a>
</li>

<li><a href="http://wiki.call-cc.org/">Chicken Scheme Wiki</a>
</li>

<li><a href="http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html">Gambit Scheme</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-2" name="sec-1-12-8-2"></a>Libraries and Standards<br  /><div class="outline-text-5" id="text-1-12-8-2">
<p>
<b>Standards</b>
</p>

<ul class="org-ul">
<li><a href="http://www.schemers.org/Documents/Standards/R5RS/r5rs.pdf">Revised 5 Report on Scheme</a>
</li>
<li><a href="http://www.r6rs.org/final/r6rs.pdf">Revised 6 Report on Scheme</a>
</li>
<li><a href="http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs.pdf">Revised 7 Report on Scheme</a>
</li>
</ul>

<p>
<b>Libraries</b>
</p>

<ul class="org-ul">
<li><a href="https://github.com/scheme-requests-for-implementation">Scheme Requests for implementation - Github Repository</a>
</li>

<li><a href="http://srfi.schemers.org/srfi-implementers.html">Scheme Systems Supporting SRFIs</a>
</li>

<li><a href="http://people.csail.mit.edu/jaffer/SLIB">The SLIB Portable Scheme Library</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-3" name="sec-1-12-8-3"></a>Syntax<br  /><div class="outline-text-5" id="text-1-12-8-3">
<ul class="org-ul">
<li><a href="http://home.adelphi.edu/sbloch/class/archive/270/scheme.shtml">The Scheme language</a>
</li>

<li><a href="http://courses.cs.washington.edu/courses/cse341/03wi/scheme/basics.html">CSE 341 &#x2013; Scheme Basics</a>
</li>

<li><a href="http://www.shido.info/lisp/idx_scm_e.html">Yet Another Scheme Tutorial</a>
</li>

<li><a href="http://cs.gettysburg.edu/~tneller/cs341/scheme-intro/index.html">CS 341 - Survey of Programming Languages Scheme for Java Programmers</a>
</li>

<li><a href="http://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html">Syntax Overview</a>
</li>

<li><a href="http://www.eecs.wsu.edu/~hauser/teaching/Languages-F09/lectures/scheme/index.html">LISP/Scheme CptS 355 - Programming Language Design Washington State University</a>
</li>

<li><a href="http://schemers.org/Documents/Standards/R5RS/HTML/">R5RS Standard</a>
</li>

<li><a href="http://dept-info.labri.u-bordeaux.fr/~strandh/Teaching/Langages-Enchasses/Common/Strandh-Tutorial/diff-scheme.html">Differences between Scheme and Common Lisp</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-4" name="sec-1-12-8-4"></a>Object Orientated Programming<br  /><div class="outline-text-5" id="text-1-12-8-4">
<ul class="org-ul">
<li><a href="http://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/swob.txt">Scheming  with  Objects</a>
</li>

<li><a href="http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent">Closures And Objects Are Equivalent</a>
</li>

<li><a href="http://www.cs.rpi.edu/courses/fall00/ai/scheme/reference/schintro-v14/schintro_133.html">Records and Object Orientation</a>
</li>

<li><a href="http://community.schemewiki.org/?object-systems">Object Systems</a>
</li>

<li><a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">Common Lisp Object System</a>
</li>

<li><a href="https://pschombe.wordpress.com/2006/04/03/why-scheme-shouldn%E2%80%99t-have-an-official-object-system/">Why Scheme Shouldnt Have An Official Object System</a>
</li>
</ul>
</div>
</li>


<li><a id="sec-1-12-8-5" name="sec-1-12-8-5"></a>Macros and Metaprogramming<br  /><div class="outline-text-5" id="text-1-12-8-5">
<p>
<b>Metaprogramming</b>
</p>

<ul class="org-ul">
<li><a href="http://racket-metaprogramming.com/blog/2015/08/07/what-is-meta-programming/">What is meta-programming?</a>
</li>

<li><a href="http://web.archive.org/web/20080221002034/http://www.math.grin.edu/~stone/courses/scheme/readings/metaprogramming.xhtml">Metaprogramming - Programs as data</a>
</li>

<li><a href="http://racket-metaprogramming.com/">Racket Metaprogramming</a>
</li>
</ul>

<p>
<b>Macros</b>
</p>

<ul class="org-ul">
<li><a href="http://community.schemewiki.org/?scheme-faq-macros">scheme-faq-macros</a>
</li>

<li><a href="http://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt">JRM's Syntax-rules Primer for the Merely Eccentric</a>
</li>

<li><a href="http://docs.racket-lang.org/guide/macros.html">Racket Macros</a>
</li>

<li><a href="https://www.cs.utah.edu/~mflatt/past-courses/cs6510/public_html/macros.pdf">Scheme-Style Macros: Patterns and Lexical Scope</a>
</li>

<li><a href="http://wiki.epfl.ch/edicpublic/documents/Candidacy%20exam/2012-09-10-eugeneburmako-researchproposal.pdf">Metaprogramming with Macros</a>
</li>

<li><a href="http://www.willdonnelly.net/blog/scheme-syntax-rules/">A Scheme Syntax-Rules Primer</a>
</li>

<li><a href="http://www.phyast.pitt.edu/~micheles/scheme/scheme28.html">The Adventures of a Pythonista in Schemeland v0.1 documentation  Hygienic macros</a>
</li>

<li><a href="http://www.scheme.com/tspl2d/syntax.html">Chapter 8. Syntactic Extension</a>
</li>

<li><a href="http://pereckerdal.com/2010/05/17/macro-systems/">Macro systems in Scheme</a>
</li>

<li><a href="https://csl.name/post/scheme-tutorial/">A Short RRS Scheme Tutorial</a>
</li>

<li><a href="https://www.cs.utah.edu/~mflatt/past-courses/cs6520/public_html/s04/macro-tutorial.pdf">Scheme-Style Macros: Patterns and Lexical Scope</a>
</li>

<li><a href="https://www.cs.indiana.edu/~dyb/pubs/tr356.pdf">Writing Hygienic Macros in Scheme with Syntax-Case - R. Kent Dybvig - Indiana University Computer Science Department Bloomington</a>
</li>

<li><a href="https://ifl2014.github.io/submissions/ifl2014_submission_6.pdf">Source-to-Source Compilation in Racket You Want it in Which Language?</a>
</li>

<li><a href="http://okmij.org/ftp/Scheme/macros.html">Low- and high-level macro programming in Scheme - <a href="http://okmij.org">http://okmij.org</a></a>
</li>
</ul>
</div>
</li>


<li><a id="sec-1-12-8-6" name="sec-1-12-8-6"></a>Serialization and Data Representation<br  /><div class="outline-text-5" id="text-1-12-8-6">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/S-expression">S-expression - Wikipedia</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/SXML">SXML format</a>
</li>
<li><a href="http://okmij.org/ftp/Scheme/SXML.html">Oleg Kiselyov's SXML tools</a>
</li>

<li><a href="https://en.wikipedia.org/wiki/Canonical_S-expressions">Canonical S-expression</a>
</li>
<li><a href="http://people.csail.mit.edu/rivest/sexp.html">SEXP&#x2014;(S-expressions)</a>
</li>
<li><a href="http://people.csail.mit.edu/rivest/Sexp.txt">S-Expressions</a>
</li>
<li><a href="http://www.kludgecode.com/index.php/s-expression-isomorphism-between-lisp-and-markup/">S-Expression Isomorphism Between Lisp and Markup</a>
</li>
<li><a href="http://www.jonathanfischer.net/s-expressions/">S-expressions for fun and profit</a>
</li>

<li><a href="https://realworldocaml.org/v1/en/html/data-serialization-with-s-expressions.html">Real World OCaml - Chapter 17. Data Serialization with S-Expressions</a>
</li>

<li><a href="http://www.seomastering.com/wiki/Comparison_of_data_serialization_formats">Comparison of data serialization formats</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-7" name="sec-1-12-8-7"></a>Scheme as Extension Language<br  /><div class="outline-text-5" id="text-1-12-8-7">
<ul class="org-ul">
<li><a href="http://wiki.gnucash.org/wiki/Custom_Reports">GNU Cash - Custom Reports</a>
</li>

<li><a href="http://wiki.geda-project.org/geda:gnetlist_scheme_tutorial">GEDA - Scripting a gnetlist backend in Scheme</a>
</li>

<li><a href="http://festvox.org/festvox-1.2/festvox_6.html">Festival Speech Synthesis systems</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-8" name="sec-1-12-8-8"></a>Algebraic Data Types - Monads, Monoids<br  /><div class="outline-text-5" id="text-1-12-8-8">
<ul class="org-ul">
<li><a href="http://dorophone.blogspot.com/2011/11/understanding-haskell-io-monad.html">Understanding the Haskell IO Monad. By Building a Toy Model in Scheme</a>
</li>

<li><a href="http://tobilehman.com/blog/2013/09/07/monoids-in-scheme/">Monoids in Scheme</a>
</li>

<li><a href="http://planet.racket-lang.org/package-source/toups/functional.plt/1/0/better-monads-guide.html">Racket / Better Monads</a>
</li>

<li><a href="http://okmij.org/ftp/Scheme/monad-in-Scheme.html">Monadic Programming in Scheme</a>
</li>

<li><a href="http://d.hatena.ne.jp/reinyannyan/20080812/p1">Monadic parser combinator library in PLT Scheme. (Racket)</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-9" name="sec-1-12-8-9"></a>Continuation<br  /><div class="outline-text-5" id="text-1-12-8-9">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Delimited_continuation">Delimited continuation - Wikipedia</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Call-with-current-continuation">Call-with-current-continuation - Wikipedia</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="https://karczmarczuk.users.greyc.fr/TEACH/Doc/appcont.pdf">Applications of Continuations - Daniel P. Friedman - Indiana University</a>
</li>

<li><a href="http://blog.theincredibleholk.org/blog/2013/11/27/continuation-passing-style-interpreters/">Continuation Passing Style Interpreters</a>
</li>

<li><a href="http://wingolog.org/archives/2010/02/26/guile-and-delimited-continuations">guile and delimited continuations</a>
</li>

<li><a href="https://www.shido.info/lisp/scheme_cc_e.html">shido.info - 16. Continuation</a>
</li>

<li><a href="http://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/continuations.html">CPS 343/543 Lecture notes: Continuations and call/cc</a>
</li>

<li><a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">Continuations by example: Exceptions, time-traveling search, generators, threads, and coroutines</a>
</li>

<li><a href="http://www.cs.rochester.edu/~brown/173/lectures/functional/scheme/Scheme.html">Scheme WHY STUDY FUNCTIONAL LANGUAGES</a>
</li>
</ul>
</div>
</li>

<li><a id="sec-1-12-8-10" name="sec-1-12-8-10"></a>Compilation<br  /><div class="outline-text-5" id="text-1-12-8-10">
<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/480083/what-is-a-lisp-image">What is a Lisp image?</a>
</li>

<li><a href="http://stackoverflow.com/questions/3960140/have-some-way-to-save-the-repl-state-of-common-lisp-or-scheme">Have some way to save the REPL state of Common Lisp or Scheme?</a>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-12-9" class="outline-4">
<h4 id="sec-1-12-9"><span class="section-number-4">1.12.9</span> Hacker News Threads</h4>
<div class="outline-text-4" id="text-1-12-9">
<ul class="org-ul">
<li><a href="https://news.ycombinator.com/item?id=2506485">Systems Programming with Racket (racket-lang.org)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=8616918">Reproducible Development Environments with GNU Guix (dthompson.us)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=3847242">Interviews with Lisp Hackers: Pascal Costanza (lisp-univ-etc.blogspot.com)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=58558"> Ask news.YC: For the lisp experts - tell me how you learned the language.</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=48657">Is Scheme as good as Common Lisp?</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=7595098">A Haskell Programmer Tries to Learn Racket (artyom.me)</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12-10" class="outline-4">
<h4 id="sec-1-12-10"><span class="section-number-4">1.12.10</span> Lambda Ultimate Threads</h4>
<div class="outline-text-4" id="text-1-12-10">
<ul class="org-ul">
<li><a href="http://c2.com/cgi/wiki?SchemeUnit">Scheme Unit</a>
</li>
<li><a href="http://c2.com/cgi/wiki?LispMeUnit">Lisp Me Unit</a>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: arch</p>
<p class="date">Created: 2017-03-06 seg 13:09</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>